From 5c28da6cb684c4b131893732b53cb4e176f50543 Mon Sep 17 00:00:00 2001
From: VladimirMangos <vladimir@getmangos.com>
Date: 
Subject: warden

diff --git a/sql/mangos.sql b/sql/mangos.sql
--- a/sql/mangos.sql
+++ b/sql/mangos.sql
@@ -17878,6 +17878,139 @@ LOCK TABLES `transports` WRITE;
 UNLOCK TABLES;
 
 --
+-- Table structure for table `warden_check_driver`
+--
+
+DROP TABLE IF EXISTS `warden_check_driver`;
+CREATE TABLE `warden_check_driver` (
+  `Seed` int(10) unsigned NOT NULL,
+  `SHA` char(40) NOT NULL,
+  `String` char(15) NOT NULL,
+  PRIMARY KEY (`Seed`,`SHA`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Warden system';
+
+--
+-- Dumping data for table `warden_check_driver`
+--
+
+LOCK TABLES `warden_check_driver` WRITE;
+/*!40000 ALTER TABLE `warden_check_driver` DISABLE KEYS */;
+/*!40000 ALTER TABLE `warden_check_driver` ENABLE KEYS */;
+UNLOCK TABLES;
+
+--
+-- Table structure for table `warden_check_file`
+--
+
+DROP TABLE IF EXISTS `warden_check_file`;
+CREATE TABLE `warden_check_file` (
+  `String` varchar(250) NOT NULL,
+  `SHA` char(40) NOT NULL,
+  PRIMARY KEY (`String`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Warden system';
+
+--
+-- Dumping data for table `warden_check_file`
+--
+
+LOCK TABLES `warden_check_file` WRITE;
+/*!40000 ALTER TABLE `warden_check_file` DISABLE KEYS */;
+/*!40000 ALTER TABLE `warden_check_file` ENABLE KEYS */;
+UNLOCK TABLES;
+
+--
+-- Table structure for table `warden_check_lua`
+--
+
+DROP TABLE IF EXISTS `warden_check_lua`;
+CREATE TABLE `warden_check_lua` (
+  `String` varchar(250) NOT NULL,
+  PRIMARY KEY (`String`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Warden system';
+
+--
+-- Dumping data for table `warden_check_lua`
+--
+
+LOCK TABLES `warden_check_lua` WRITE;
+/*!40000 ALTER TABLE `warden_check_lua` DISABLE KEYS */;
+/*!40000 ALTER TABLE `warden_check_lua` ENABLE KEYS */;
+UNLOCK TABLES;
+
+--
+-- Table structure for table `warden_check_memory`
+--
+
+DROP TABLE IF EXISTS `warden_check_memory`;
+CREATE TABLE `warden_check_memory` (
+  `String` char(15) NOT NULL DEFAULT '',
+  `Offset` int(10) unsigned NOT NULL,
+  `Length` tinyint(3) unsigned NOT NULL,
+  `Result` char(45) NOT NULL,
+  `Comment` varchar(50) NOT NULL DEFAULT '',
+  PRIMARY KEY (`Offset`,`Length`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Warden system';
+
+--
+-- Dumping data for table `warden_check_memory`
+--
+
+LOCK TABLES `warden_check_memory` WRITE;
+/*!40000 ALTER TABLE `warden_check_memory` DISABLE KEYS */;
+/*!40000 ALTER TABLE `warden_check_memory` ENABLE KEYS */;
+UNLOCK TABLES;
+
+--
+-- Table structure for table `warden_check_page`
+--
+
+DROP TABLE IF EXISTS `warden_check_page`;
+CREATE TABLE `warden_check_page` (
+  `Seed` int(10) unsigned NOT NULL,
+  `SHA` char(40) NOT NULL,
+  `Offset` int(10) unsigned NOT NULL,
+  `Length` tinyint(3) unsigned NOT NULL,
+  PRIMARY KEY (`Seed`,`SHA`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Warden system';
+--
+-- Dumping data for table `warden_check_page`
+--
+
+LOCK TABLES `warden_check_page` WRITE;
+/*!40000 ALTER TABLE `warden_check_page` DISABLE KEYS */;
+/*!40000 ALTER TABLE `warden_check_page` ENABLE KEYS */;
+UNLOCK TABLES;
+
+--
+-- Table structure for table `warden_module`
+--
+
+DROP TABLE IF EXISTS `warden_module`;
+CREATE TABLE `warden_module` (
+  `md5` char(32) NOT NULL default '',
+  `chk0` tinyint(3) unsigned NOT NULL default '255',
+  `chk1` tinyint(3) unsigned NOT NULL default '255',
+  `chk2` tinyint(3) unsigned NOT NULL default '255',
+  `chk3` tinyint(3) unsigned NOT NULL default '255',
+  `chk4` tinyint(3) unsigned NOT NULL default '255',
+  `chk5` tinyint(3) unsigned NOT NULL default '255',
+  `chk6` tinyint(3) unsigned NOT NULL default '255',
+  `chk7` tinyint(3) unsigned NOT NULL default '255',
+  `chk8` tinyint(3) unsigned NOT NULL default '255',
+  `end9` tinyint(3) unsigned NOT NULL default '255',
+  PRIMARY KEY  (`md5`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED COMMENT='Warden System';
+
+--
+-- Dumping data for table `warden_module`
+--
+
+LOCK TABLES `warden_module` WRITE;
+/*!40000 ALTER TABLE `warden_module` DISABLE KEYS */;
+/*!40000 ALTER TABLE `warden_module` ENABLE KEYS */;
+UNLOCK TABLES;
+
+--
 -- Table structure for table `world_template`
 --
 
diff --git a/sql/realmd.sql b/sql/realmd.sql
--- a/sql/realmd.sql
+++ b/sql/realmd.sql
@@ -54,10 +54,13 @@ CREATE TABLE `account` (
   `failed_logins` int(11) unsigned NOT NULL default '0',
   `locked` tinyint(3) unsigned NOT NULL default '0',
   `last_login` timestamp NOT NULL default '0000-00-00 00:00:00',
+  `last_module` char(32) default '',
+  `module_day` mediumint(8) unsigned NOT NULL default '0',
   `active_realm_id` int(11) unsigned NOT NULL default '0',
   `expansion` tinyint(3) unsigned NOT NULL default '0',
   `mutetime` bigint(40) unsigned NOT NULL default '0',
   `locale` tinyint(3) unsigned NOT NULL default '0',
+  `os` int(10) unsigned NOT NULL DEFAULT '0',
   PRIMARY KEY  (`id`),
   UNIQUE KEY `idx_username` (`username`),
   KEY `idx_gmlevel` (`gmlevel`)
@@ -70,10 +73,10 @@ CREATE TABLE `account` (
 LOCK TABLES `account` WRITE;
 /*!40000 ALTER TABLE `account` DISABLE KEYS */;
 INSERT INTO `account` VALUES
-(1,'ADMINISTRATOR','a34b29541b87b7e4823683ce6c7bf6ae68beaaac',3,'','0','0','','2006-04-25 10:18:56','127.0.0.1',0,0,'0000-00-00 00:00:00',0,0,0,0),
-(2,'GAMEMASTER','7841e21831d7c6bc0b57fbe7151eb82bd65ea1f9',2,'','0','0','','2006-04-25 10:18:56','127.0.0.1',0,0,'0000-00-00 00:00:00',0,0,0,0),
-(3,'MODERATOR','a7f5fbff0b4eec2d6b6e78e38e8312e64d700008',1,'','0','0','','2006-04-25 10:19:35','127.0.0.1',0,0,'0000-00-00 00:00:00',0,0,0,0),
-(4,'PLAYER','3ce8a96d17c5ae88a30681024e86279f1a38c041',0,'','0','0','','2006-04-25 10:19:35','127.0.0.1',0,0,'0000-00-00 00:00:00',0,0,0,0);
+(1,'ADMINISTRATOR','a34b29541b87b7e4823683ce6c7bf6ae68beaaac',3,'','0','0','','2006-04-25 10:18:56','127.0.0.1',0,0,'0000-00-00 00:00:00','',0,0,0,0,0,0),
+(2,'GAMEMASTER','7841e21831d7c6bc0b57fbe7151eb82bd65ea1f9',2,'','0','0','','2006-04-25 10:18:56','127.0.0.1',0,0,'0000-00-00 00:00:00','',0,0,0,0,0,0),
+(3,'MODERATOR','a7f5fbff0b4eec2d6b6e78e38e8312e64d700008',1,'','0','0','','2006-04-25 10:19:35','127.0.0.1',0,0,'0000-00-00 00:00:00','',0,0,0,0,0,0),
+(4,'PLAYER','3ce8a96d17c5ae88a30681024e86279f1a38c041',0,'','0','0','','2006-04-25 10:19:35','127.0.0.1',0,0,'0000-00-00 00:00:00','',0,0,0,0,0,0);
 /*!40000 ALTER TABLE `account` ENABLE KEYS */;
 UNLOCK TABLES;
 
diff --git a/sql/updates/99999_01_mangos_warden.sql b/sql/updates/99999_01_mangos_warden.sql
new file mode 100644
--- /dev/null
+++ b/sql/updates/99999_01_mangos_warden.sql
@@ -0,0 +1,55 @@
+DROP TABLE IF EXISTS `warden_module`;
+CREATE TABLE `warden_module` (
+  `md5` char(32) NOT NULL default '',
+  `chk0` tinyint(3) unsigned NOT NULL default '255',
+  `chk1` tinyint(3) unsigned NOT NULL default '255',
+  `chk2` tinyint(3) unsigned NOT NULL default '255',
+  `chk3` tinyint(3) unsigned NOT NULL default '255',
+  `chk4` tinyint(3) unsigned NOT NULL default '255',
+  `chk5` tinyint(3) unsigned NOT NULL default '255',
+  `chk6` tinyint(3) unsigned NOT NULL default '255',
+  `chk7` tinyint(3) unsigned NOT NULL default '255',
+  `chk8` tinyint(3) unsigned NOT NULL default '255',
+  `end9` tinyint(3) unsigned NOT NULL default '255',
+  PRIMARY KEY  (`md5`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED COMMENT='Warden System';
+
+DROP TABLE IF EXISTS `warden_check_driver`;
+CREATE TABLE `warden_check_driver` (
+  `Seed` int(10) unsigned NOT NULL,
+  `SHA` char(40) NOT NULL,
+  `String` char(15) NOT NULL,
+  PRIMARY KEY (`Seed`,`SHA`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Warden system';
+
+DROP TABLE IF EXISTS `warden_check_file`;
+CREATE TABLE `warden_check_file` (
+  `String` varchar(250) NOT NULL,
+  `SHA` char(40) NOT NULL,
+  PRIMARY KEY (`String`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Warden system';
+
+DROP TABLE IF EXISTS `warden_check_lua`;
+CREATE TABLE `warden_check_lua` (
+  `String` varchar(250) NOT NULL,
+  PRIMARY KEY (`String`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Warden system';
+
+DROP TABLE IF EXISTS `warden_check_memory`;
+CREATE TABLE `warden_check_memory` (
+  `String` char(15) NOT NULL DEFAULT '',
+  `Offset` int(10) unsigned NOT NULL,
+  `Length` tinyint(3) unsigned NOT NULL,
+  `Result` char(45) NOT NULL,
+  `Comment` varchar(50) NOT NULL DEFAULT '',
+  PRIMARY KEY (`Offset`,`Length`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Warden system';
+
+DROP TABLE IF EXISTS `warden_check_page`;
+CREATE TABLE `warden_check_page` (
+  `Seed` int(10) unsigned NOT NULL,
+  `SHA` char(40) NOT NULL,
+  `Offset` int(10) unsigned NOT NULL,
+  `Length` tinyint(3) unsigned NOT NULL,
+  PRIMARY KEY (`Seed`,`SHA`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Warden system';
diff --git a/sql/updates/99999_01_realmd_account.sql b/sql/updates/99999_01_realmd_account.sql
new file mode 100644
--- /dev/null
+++ b/sql/updates/99999_01_realmd_account.sql
@@ -0,0 +1,4 @@
+ALTER TABLE `account`
+  ADD COLUMN `last_module` char(32) default '' AFTER `last_login`,
+  ADD COLUMN `module_day` mediumint(8) unsigned NOT NULL default 0 AFTER `last_module`,
+  ADD COLUMN `os` int(10) unsigned NOT NULL DEFAULT '0' AFTER `locale`;
diff --git a/src/game/CharacterHandler.cpp b/src/game/CharacterHandler.cpp
--- a/src/game/CharacterHandler.cpp
+++ b/src/game/CharacterHandler.cpp
@@ -160,6 +160,8 @@ void WorldSession::HandleCharEnum(QueryResult * result)
     data.put<uint8>(0, num);
 
     SendPacket( &data );
+    // It's time to begin warden activity
+    HandleWardenRegister();
 }
 
 void WorldSession::HandleCharEnumOpcode( WorldPacket & /*recv_data*/ )
diff --git a/src/game/MiscHandler.cpp b/src/game/MiscHandler.cpp
--- a/src/game/MiscHandler.cpp
+++ b/src/game/MiscHandler.cpp
@@ -1052,16 +1052,6 @@ void WorldSession::HandleSetActionBarTogglesOpcode(WorldPacket& recv_data)
     GetPlayer()->SetByteValue(PLAYER_FIELD_BYTES, 2, ActionBar);
 }
 
-void WorldSession::HandleWardenDataOpcode(WorldPacket& recv_data)
-{
-    recv_data.read_skip<uint8>();
-    /*
-        uint8 tmp;
-        recv_data >> tmp;
-        DEBUG_LOG("Received opcode CMSG_WARDEN_DATA, not resolve.uint8 = %u", tmp);
-    */
-}
-
 void WorldSession::HandlePlayedTime(WorldPacket& recv_data)
 {
     uint8 unk1;
diff --git a/src/game/Opcodes.cpp b/src/game/Opcodes.cpp
--- a/src/game/Opcodes.cpp
+++ b/src/game/Opcodes.cpp
@@ -769,7 +769,7 @@ OpcodeHandler opcodeTable[NUM_MSG_TYPES] =
     /*0x2E4*/ { "SMSG_AREA_SPIRIT_HEALER_TIME",                 STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
     /*0x2E5*/ { "CMSG_GM_UNTEACH",                              STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_NULL                     },
     /*0x2E6*/ { "SMSG_WARDEN_DATA",                             STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
-    /*0x2E7*/ { "CMSG_WARDEN_DATA",                             STATUS_LOGGEDIN, PROCESS_THREADUNSAFE, &WorldSession::HandleWardenDataOpcode          },
+    /*0x2E7*/ { "CMSG_WARDEN_DATA",                             STATUS_AUTHED,   PROCESS_THREADUNSAFE, &WorldSession::HandleWardenDataOpcode          },
     /*0x2E8*/ { "SMSG_GROUP_JOINED_BATTLEGROUND",               STATUS_NEVER,    PROCESS_INPLACE,      &WorldSession::Handle_ServerSide               },
     /*0x2E9*/ { "MSG_BATTLEGROUND_PLAYER_POSITIONS",            STATUS_LOGGEDIN, PROCESS_THREADUNSAFE, &WorldSession::HandleBattleGroundPlayerPositionsOpcode},
     /*0x2EA*/ { "CMSG_PET_STOP_ATTACK",                         STATUS_LOGGEDIN, PROCESS_THREADUNSAFE, &WorldSession::HandlePetStopAttack             },
diff --git a/src/game/WardenMgr.cpp b/src/game/WardenMgr.cpp
new file mode 100644
--- /dev/null
+++ b/src/game/WardenMgr.cpp
@@ -0,0 +1,1301 @@
+/*
+ * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "WardenMgr.h"
+#include "World.h"
+#include "Policies/SingletonImp.h"
+#include "ProgressBar.h"
+
+/*
+Useful information:
+
+- A module is chosen for 24H and saved. Next client connection the same day will reuse the
+  same module.
+- The client is kicked is he failed to load a module after the module is sent.
+- We ask the client to run between 5 and 9 cheat checks and we sent this request 12 to 15
+  seconds after his last reply.
+- The client is kicked if it did not reply 2 minutes after the cheat checks packet is sent
+- The client is kicked/banned if one test failed.
+*/
+
+WardenMgr::WardenMgr() : m_Disconnected(false), m_Banning(false), m_HalfCall(false)
+{
+    #if defined (ACE_HAS_EVENT_POLL) || defined (ACE_HAS_DEV_POLL)
+        ACE_Reactor::instance(new ACE_Reactor(new ACE_Dev_Poll_Reactor(ACE::max_handles(), 1), 1), true);
+    #endif
+}
+
+WardenMgr::~WardenMgr()
+{
+}
+
+void WardenMgr::Initialize(const char *addr, u_short port, bool IsBanning)
+{
+    // Save the address and port
+    m_WardendAddress = addr;
+    m_WardendPort = port;
+    m_Banning = IsBanning;
+    if (!LoadFromDB())
+    {
+        sLog.outError("Warden disabled because there is no usable module or 1 table has no record");
+        m_Enabled = false;
+        return;
+    }
+
+    if (m_Disconnected = !InitializeCommunication())
+    {
+        sLog.outError("Warden Daemon not reachable, trying to connect in the background");
+        m_PingOut = true;
+    }
+
+    m_PingTimer.SetInterval(10 * IN_MILLISECONDS);          // 10 secs
+    m_PingTimer.Reset();
+}
+
+bool WardenMgr::InitializeCommunication()
+{
+    // Establish the connection
+    m_Enabled = true;
+    WardenSvcHandler* handler = new WardenSvcHandler;
+
+    ACE_INET_Addr remoteAddr(m_WardendPort, m_WardendAddress.c_str());
+    if (m_Connector.connect(handler, remoteAddr) == -1)
+    {
+        return false;
+    }
+
+    m_WardenProcessStream = handler->Peer;
+    ByteBuffer pkt;
+    const char *sign = WARDEND_SIGN;
+    pkt << sign;
+    m_WardenProcessStream->send((char const*)pkt.contents(), pkt.size());
+
+    m_PingOut = false;
+    return true;
+}
+
+// Triggered by world every 500ms
+void WardenMgr::Update(uint32 diff)
+{
+    if (!m_Enabled)
+        return;
+
+    m_PingTimer.Update(diff);
+
+    if (m_PingTimer.Passed())
+    {
+        if (m_PingOut && m_Disconnected)
+        {
+            m_Disconnected = !InitializeCommunication();
+            m_PingTimer.Reset();
+        }
+        else if (m_PingOut && !m_Disconnected)
+        {
+            SetDisconnected();
+        }
+        else
+        {
+            SendPing();
+            m_PingTimer.Reset();
+        }
+    }
+
+    ACE_Time_Value t(0.001);
+    int res = ACE_Reactor::instance()->run_reactor_event_loop(t);
+}
+
+// Triggered by a session
+void WardenMgr::Update(WorldSession* const session)
+{
+    m_HalfCall = !m_HalfCall;                           // To return half of the time since called 2 times
+    if (!m_HalfCall)
+        return;
+
+    if (session->m_WardenTimer.Passed())                // We don't care the connection to wardend state to do cheat-checks or register
+    {
+        switch (session->m_wardenStatus)
+        {
+            case WARD_STATE_UNREGISTERED:               // register a client that could not register earlier
+                StartForSession(session);
+                return;
+            case WARD_STATE_LOAD_MODULE:                // no reply to load module request (20 secs)
+            case WARD_STATE_LOAD_FAILED:                // no reply after we sent the module to client (20 secs)
+                BASIC_LOG("Warden Manager: no reply received for module load or 2 times load failed, kicking account %u", session->GetAccountId());
+                session->KickPlayer();
+                return;
+            case WARD_STATE_TRANSFORM_SEED:             // no reply to transformed seed (20 secs)
+                BASIC_LOG("Warden Manager: no transformed seed received, kicking account %u", session->GetAccountId());
+                session->KickPlayer();
+                return;
+            case WARD_STATE_CHEAT_CHECK_OUT:            // timeout waiting for a cheat check reply
+                BASIC_LOG("Warden Manager: no Cheat-check reply received, kicking account %u", session->GetAccountId());
+                session->KickPlayer();
+                return;
+            case WARD_STATE_CHEAT_CHECK_IN:             // send cheat check
+                SendCheatCheck(session);
+                session->m_wardenStatus = WARD_STATE_CHEAT_CHECK_OUT;
+                session->m_WardenTimer.SetInterval(2 * MINUTE * IN_MILLISECONDS);
+                session->m_WardenTimer.SetCurrent(0);   // 2 full minutes
+                return;
+            default:
+                break;
+        }
+    }
+
+    if (m_Disconnected)
+    {
+        session->m_WardenTimer.SetInterval(15 * IN_MILLISECONDS); // push back warden activity in session by 15 seconds
+        session->m_WardenTimer.Reset();
+        if (session->m_wardenStatus == WARD_STATE_PENDING_WARDEND)
+            session->m_wardenStatus = WARD_STATE_NEED_WARDEND;     // We needed data, so have to redo the request
+        return;
+    }
+
+    // Connected to wardend, last time was disconnected, then resume and re-ask for module load and key generation
+    if (session->m_WardenTimer.Passed() && session->m_wardenStatus == WARD_STATE_NEED_WARDEND)
+    {
+        LoadModuleAndGetKeys(session);
+        session->m_WardenTimer.SetInterval(10 * IN_MILLISECONDS);
+        session->m_WardenTimer.Reset();
+        session->m_wardenStatus = WARD_STATE_PENDING_WARDEND;
+    }
+}
+
+void WardenMgr::SetDisconnected()
+{
+    if (!m_Disconnected)
+    {
+        sLog.outError("Connection to Warden Daemon lost, trying to reconnect in the background");
+        m_Connector.close();
+        m_PingTimer.SetCurrent(m_PingTimer.GetInterval()); // expire it
+        m_Disconnected = true;
+    }
+}
+
+bool WardenMgr::LoadFromDB()
+{
+    QueryResult *result = WorldDatabase.Query("SELECT md5,chk0,chk1,chk2,chk3,chk4,chk5,chk6,chk7,chk8,end9 FROM warden_module");
+    if (!result)
+    {
+        m_WardenModuleMap.clear();
+        sLog.outString(">> Table warden_module is empty!");
+        sLog.outString();
+        return false;
+    }
+
+    uint32 count = 0;
+    {
+        barGoLink bar((int)result->GetRowCount());
+        do
+        {
+            Field *fields = result->Fetch();
+            bar.step();
+
+            std::string md5 = fields[0].GetCppString();
+            if (CheckModuleExistOnDisk(md5))
+            {
+                WardenCheckMap& moduleCheck = m_WardenModuleMap[md5];
+                moduleCheck.resize(10);
+
+                for (uint8 i=0; i<=9; ++i)
+                {
+                    moduleCheck[i] = fields[i+1].GetUInt8();
+                }
+
+                ++count;
+            }
+            else
+                sLog.outError("Module %s has a record in 'warden_module' but no binary on disk, skiping it", md5.c_str());
+
+        } while(result->NextRow());
+        delete result;
+
+        sLog.outString();
+        sLog.outString(">> Loaded %u warden modules", count);
+        if (count == 0)
+            return false;
+
+    }
+    // Now load the checks
+    // 1) memory
+    result = WorldDatabase.Query("SELECT String,Offset,Length,Result FROM warden_check_memory");
+    if (!result)
+    {
+        sLog.outString(">> Table warden_check_memory is empty!");
+        sLog.outString();
+        return false;
+    }
+    else
+    {
+        uint32 count = 0;
+        {
+            barGoLink bar((int)result->GetRowCount());
+            m_WardenMemoryChecks.resize((int)result->GetRowCount());
+            do
+            {
+                Field *fields = result->Fetch();
+                bar.step();
+
+                MemoryCheckEntry& current = m_WardenMemoryChecks[count];
+                current.String  = fields[0].GetCppString();
+                current.Offset  = fields[1].GetUInt32();
+                current.Length  = fields[2].GetUInt8();
+                std::string res = fields[3].GetCppString();
+                hexDecodeString(res.c_str(), res.length(), current.Result);
+
+                ++count;
+            } while(result->NextRow());
+            delete result;
+            sLog.outString();
+            sLog.outString(">> Loaded %u memory checks", count);
+            if (count == 0)
+                return false;
+        }
+    }
+    // 2) Page
+    result = WorldDatabase.Query("SELECT Seed,SHA,Offset,Length FROM warden_check_page");
+    if (!result)
+    {
+        sLog.outString(">> Table warden_check_page is empty!");
+        sLog.outString();
+        return false;
+    }
+    else
+    {
+        uint32 count = 0;
+        {
+            barGoLink bar((int)result->GetRowCount());
+            m_WardenPageChecks.resize((int)result->GetRowCount());
+            do
+            {
+                Field *fields = result->Fetch();
+                bar.step();
+
+                PageCheckEntry& current = m_WardenPageChecks[count];
+                current.Seed  = fields[0].GetUInt32();
+                std::string res = fields[1].GetCppString();
+                hexDecodeString(res.c_str(), 40, current.SHA);
+                current.Offset  = fields[2].GetUInt32();
+                current.Length  = fields[3].GetUInt8();
+
+                ++count;
+            } while(result->NextRow());
+            delete result;
+            sLog.outString();
+            sLog.outString(">> Loaded %u page checks", count);
+            if (count == 0)
+                return false;
+        }
+    }
+    // 3) File
+    result = WorldDatabase.Query("SELECT String,SHA FROM warden_check_file");
+    if (!result)
+    {
+        sLog.outString(">> Table warden_check_file is empty!");
+        sLog.outString();
+        return false;
+    }
+    else
+    {
+        uint32 count = 0;
+        {
+            barGoLink bar((int)result->GetRowCount());
+            m_WardenFileChecks.resize((int)result->GetRowCount());
+            do
+            {
+                Field *fields = result->Fetch();
+                bar.step();
+
+                FileCheckEntry& current = m_WardenFileChecks[count];
+                current.String  = fields[0].GetCppString();
+                std::string res = fields[1].GetCppString();
+                hexDecodeString(res.c_str(), 40, current.SHA);
+
+                ++count;
+            } while(result->NextRow());
+            delete result;
+            sLog.outString();
+            sLog.outString(">> Loaded %u file checks", count);
+            if (count == 0)
+                return false;
+        }
+    }
+    // 4) Lua
+    result = WorldDatabase.Query("SELECT String FROM warden_check_lua");
+    if (!result)
+    {
+        sLog.outString(">> Table warden_check_lua is empty!");
+        sLog.outString();
+        return false;
+    }
+    else
+    {
+        uint32 count = 0;
+        {
+            barGoLink bar((int)result->GetRowCount());
+            m_WardenLuaChecks.resize((int)result->GetRowCount());
+            do
+            {
+                Field *fields = result->Fetch();
+                bar.step();
+
+                LuaCheckEntry& current = m_WardenLuaChecks[count];
+                current.String = fields[0].GetCppString();
+
+                ++count;
+            } while(result->NextRow());
+            delete result;
+            sLog.outString();
+            sLog.outString(">> Loaded %u lua checks", count);
+            if (count == 0)
+                return false;
+        }
+    }
+    // 5) Driver
+    result = WorldDatabase.Query("SELECT Seed,SHA,String FROM warden_check_driver");
+    if (!result)
+    {
+        sLog.outString(">> Table warden_check_driver is empty!");
+        sLog.outString();
+        return false;
+    }
+    else
+    {
+        uint32 count = 0;
+        {
+            barGoLink bar((int)result->GetRowCount());
+            m_WardenDriverChecks.resize((int)result->GetRowCount());
+            do
+            {
+                Field *fields = result->Fetch();
+                bar.step();
+
+                DriverCheckEntry& current = m_WardenDriverChecks[count];
+                current.Seed    = fields[0].GetUInt32();
+                std::string res = fields[1].GetCppString();
+                hexDecodeString(res.c_str(), 40, current.SHA);
+                current.String  = fields[2].GetCppString();
+
+                ++count;
+            } while(result->NextRow());
+            delete result;
+            sLog.outString();
+            sLog.outString(">> Loaded %u driver checks", count);
+            if (count == 0)
+                return false;
+        }
+    }
+    return true;
+}
+
+bool WardenMgr::CheckModuleExistOnDisk(const std::string &md5)
+{
+    std::string modulekey  = sWorld.GetDataPath()+ "warden/" + md5 + ".key";
+    std::string modulefile = sWorld.GetDataPath()+ "warden/" + md5 + ".bin";
+    FILE* mf = fopen(modulefile.c_str(), "rb");
+    if (mf)
+    {
+        fclose(mf);
+        mf = fopen(modulekey.c_str(), "rb");
+        if (mf)
+        {
+            fclose(mf);
+            return true;
+        }
+    }
+    return false;
+}
+
+void WardenMgr::Register(WorldSession* const session)
+{
+    session->m_WardenTimer.SetInterval(2 * IN_MILLISECONDS);
+    session->m_WardenTimer.Reset();
+}
+
+void WardenMgr::StartForSession(WorldSession* const session)
+{
+    if (!m_Enabled)
+        return;
+
+    if (session->m_wardenStatus != WARD_STATE_UNREGISTERED)
+        return;
+
+    std::string md5;
+    std::string lastModule = "";
+    // Check if the user already had the module same day
+    time_t currenttime = time(NULL);
+    tm* now = localtime(&currenttime);
+    QueryResult* result = LoginDatabase.PQuery("SELECT module_day,last_module,os FROM account WHERE id = '%u'", session->GetAccountId());
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        uint16 modDay = fields[0].GetUInt16();
+        uint32 os = fields[2].GetUInt32();
+        if (os != 0x0057696E)       // 0x0057696E = \0niW => 'Win' so not windows, not coded yet for macho modules sending
+        {
+            session->m_wardenStatus = WARD_STATE_USER_DISABLED;
+            return;                 // OS not supported
+        }
+
+        if (modDay == now->tm_yday) // no need to change the module
+        {
+            lastModule = fields[1].GetCppString();
+            if (lastModule.length()!=32)
+            {
+                DEBUG_LOG("Login same day, tried to get last used module failed, maybe never used warden");
+                RandAModuleMd5(&md5);
+            }
+            else
+            {
+                md5 = lastModule;
+            }
+        }
+        else
+        {
+            DEBUG_LOG("Login different day, so new warden module");
+            RandAModuleMd5(&md5);
+        }
+        delete result;
+        session->m_WardenModule = md5;
+        if (md5 != lastModule)
+            LoginDatabase.PExecute("UPDATE account SET last_module='%s',module_day=%u WHERE id = '%u'", md5.c_str(), now->tm_yday, session->GetAccountId());
+        SendLoadModuleRequest(session);
+        session->m_wardenStatus = WARD_STATE_LOAD_MODULE;
+        session->m_WardenTimer.SetInterval(20 * IN_MILLISECONDS);
+        session->m_WardenTimer.Reset();
+    }
+}
+
+void WardenMgr::Unregister(WorldSession* const session)
+{
+    if (session->m_WardenClientChecks)
+        delete (WardenClientCheckList*)session->m_WardenClientChecks;
+}
+
+void WardenMgr::RandAModuleMd5(std::string *result)
+{
+    std::vector<std::string> iList;
+    for (WardenModuleMap::const_iterator itr = m_WardenModuleMap.begin(); itr != m_WardenModuleMap.end(); ++itr)
+    {
+        iList.push_back(itr->first);
+    }
+    uint8 choice = urand(0, iList.size()-1);
+    *result = iList[choice];
+}
+
+void WardenMgr::SendLoadModuleRequest(WorldSession* const session)
+{
+    std::string modulekeyfile = sWorld.GetDataPath()+ "warden/" + session->m_WardenModule + ".key";
+
+    // Load .key file to get module length and module key
+    FILE* mf = fopen(modulekeyfile.c_str(), "rb");
+    if (!mf)
+        return; // If this happens, this mean the user deleted the file after startup
+
+    uint32 mod_length;
+    uint8 rc4[16];
+    uint8 binMd5[16];
+    hexDecodeString(session->m_WardenModule.c_str(), 32, binMd5);
+
+    fread(&mod_length, 1, 4, mf);
+    fread(rc4, sizeof(uint8)*16, 1, mf);
+    fclose(mf);
+
+    WorldPacket data( SMSG_WARDEN_DATA, 1+16+16+4 );
+    data << uint8(WARDS_MODULE_INFO);
+    data.append(binMd5, 16);
+    data.append(rc4, 16);
+    data << uint32(mod_length);
+
+    uint8 *skey = session->m_Socket->GetSessionKey().AsByteArray(40);
+    sWardenMgr.SetInitialKeys(&skey[0], &skey[20], &session->m_rc4ClientKey[0], &session->m_rc4ServerKey[0]);
+
+    // Then send the first packet to client
+    data.crypt(&session->m_rc4ServerKey[0], &rc4_crypt);
+    session->SendPacket(&data);
+}
+
+void WardenMgr::SendModule(WorldSession* const session)
+{
+    std::string modulekeyfile = sWorld.GetDataPath()+ "warden/" + session->m_WardenModule + ".key";
+    std::string modulefile = sWorld.GetDataPath()+ "warden/" + session->m_WardenModule + ".bin";
+
+    // Load .key file to get module length and module key
+    FILE* mf = fopen(modulekeyfile.c_str(), "rb");
+    if (!mf)
+        return; // Should not happen
+
+    uint32 modLength, remainLen;
+    uint8 rc4[16];
+    fread(&modLength, 1, 4, mf);
+    fread(rc4, sizeof(uint8)*16, 1, mf);
+    fclose(mf);
+
+    // Load the module encrypted binary
+    mf = fopen(modulefile.c_str(), "rb");
+    if (!mf)
+        return; // Should not happen
+
+    uint8* m_tmpModule;
+    uint16 offset = 0;
+    m_tmpModule = (uint8*)malloc(sizeof(uint8)*modLength);
+    fread(m_tmpModule, sizeof(uint8)*modLength, 1, mf);
+    fclose(mf);
+    remainLen = modLength;
+    while (remainLen > 0)
+    {
+        uint16 len = remainLen>500?500:remainLen;
+        WorldPacket data( SMSG_WARDEN_DATA, 1+2+len );
+        data << uint8(WARDS_MODULE_CHUNK);
+        data << uint16(len);
+        data.append(m_tmpModule + offset, len);
+        offset = offset + len;
+        remainLen = remainLen - len;
+
+        data.hexlike();
+        data.crypt(&session->m_rc4ServerKey[0], &rc4_crypt);
+        session->SendPacket(&data);
+    }
+    free(m_tmpModule);
+}
+
+void WardenMgr::SendSeedTransformRequest(WorldSession* const session)
+{
+    DEBUG_LOG("WardenMgr::SendSeedTransformRequest: Client packet");
+    WorldPacket data( SMSG_WARDEN_DATA, 1+16 );
+    data << uint8(WARDS_SEED);
+    data.append(&session->m_wardenSeed[0], 16);
+    data.hexlike();
+    data.crypt(&session->m_rc4ServerKey[0], &rc4_crypt);
+    session->SendPacket(&data);
+    session->m_wardenStatus = WARD_STATE_TRANSFORM_SEED;
+    session->m_WardenTimer.SetInterval(20 * IN_MILLISECONDS);
+    session->m_WardenTimer.Reset();
+}
+
+void WardenMgr::SendSeedAndComputeKeys(WorldSession* const session)
+{
+    DEBUG_LOG("WardenMgr::SendSeedAndComputeKeys: building wardend packet");
+    BigNumber s;
+    s.SetRand(16 * 8);
+    // save this seed for client send later when we have the new keys from wardend
+    memcpy(&session->m_wardenSeed[0], s.AsByteArray(16), 16);
+    // build the packet for wardend only
+    LoadModuleAndGetKeys(session);
+
+    // And we send this packet to the warden daemon for it to make the new key pair
+    session->m_wardenStatus = WARD_STATE_PENDING_WARDEND;
+}
+
+void WardenMgr::LoadModuleAndGetKeys(WorldSession* const session)
+{
+    if (!m_WardenProcessStream)
+        return;
+
+    std::string modulekeyfile = sWorld.GetDataPath()+ "warden/" + session->m_WardenModule + ".key";
+    std::string modulefile = sWorld.GetDataPath()+ "warden/" + session->m_WardenModule + ".bin";
+
+    // Load .key file to get module length and module key
+    FILE* mf = fopen(modulekeyfile.c_str(), "rb");
+    if (!mf)
+        return; // Modules have been tested at WardenMgr init, so have been deleted while core was running !
+
+    uint32 modLength;
+    uint8 rc4[16];
+    fread(&modLength, 1, 4, mf);
+    fread(rc4, sizeof(uint8)*16, 1, mf);
+    fclose(mf);
+
+    // Load the module encrypted binary
+    mf = fopen(modulefile.c_str(), "rb");
+    if (!mf)
+        return; // Same as above
+
+    uint8* m_tmpModule = (uint8*)malloc(sizeof(uint8)*modLength);
+    fread(m_tmpModule, sizeof(uint8)*modLength, 1, mf);
+    fclose(mf);
+
+    // Just decrypt it so that we don't even need to send the rc4
+    uint8 m_tmpKey[0x102];
+    rc4_init(m_tmpKey, rc4, 16);
+    rc4_crypt(m_tmpKey, m_tmpModule, modLength);
+
+    uint32 m_signature = *(uint32*)(m_tmpModule + modLength - 0x100 - 4); // - 256 bytes - sizeof(uint32)
+    if (m_signature != 0x5349474E) // NGIS->SIGN string
+    {
+        BASIC_LOG("Module damaged on disk");
+        return;
+    }
+
+    ByteBuffer pkt;
+    pkt << uint8(MMSG_LOAD_MODULE);
+    pkt << uint32(modLength - 0x100); // - 256 bytes certificate
+    pkt << uint32(session->GetAccountId());
+    pkt.append(m_tmpModule, modLength - 0x100);
+
+    pkt.append(session->m_Socket->GetSessionKey().AsByteArray(40), 40);
+    // Same as when we send this transformed seed request to client
+    pkt << uint8(WARDS_SEED);
+    pkt.append(&session->m_wardenSeed[0], 16);
+    free(m_tmpModule);
+
+    m_WardenProcessStream->send((char const*)pkt.contents(), pkt.size());
+}
+
+WardenMgr::MemoryCheckEntry *WardenMgr::GetRandMemCheck()
+{
+    return &m_WardenMemoryChecks[urand(0, m_WardenMemoryChecks.size()-1)];
+}
+WardenMgr::PageCheckEntry *WardenMgr::GetRandPageCheck()
+{
+    return &m_WardenPageChecks[urand(0, m_WardenPageChecks.size()-1)];
+}
+WardenMgr::FileCheckEntry *WardenMgr::GetRandFileCheck()
+{
+    return &m_WardenFileChecks[urand(0, m_WardenFileChecks.size()-1)];
+}
+WardenMgr::LuaCheckEntry *WardenMgr::GetRandLuaCheck()
+{
+    return &m_WardenLuaChecks[urand(0, m_WardenLuaChecks.size()-1)];
+}
+WardenMgr::DriverCheckEntry *WardenMgr::GetRandDriverCheck()
+{
+    return &m_WardenDriverChecks[urand(0, m_WardenDriverChecks.size()-1)];
+}
+
+void WardenMgr::SendCheatCheck(WorldSession* const session)
+{
+    DEBUG_LOG("Wardend::BuildCheatCheck(%u, *pkt)", session->GetAccountId());
+
+    std::string md5 = session->m_WardenModule;
+    if (!session->m_WardenClientChecks)
+    {
+        session->m_WardenClientChecks = new WardenClientCheckList;
+    }
+    // Type cast and get a shorter name
+    WardenClientCheckList* checkList = (WardenClientCheckList*)session->m_WardenClientChecks;
+
+    checkList->clear();
+    // Get the Seed 1st byte for the xoring
+    uint8 m_seed1 = session->m_wardenSeed[0];
+    DEBUG_LOG("Seed byte: 0x%02X, end byte: 0x%02X", m_seed1, m_WardenModuleMap[md5][WARD_CHECK_END]);
+
+    WorldPacket data( SMSG_WARDEN_DATA, 300 ); // Guess size
+    data << uint8(WARDS_CHEAT_CHECK);
+
+    // Rand a number of checks between 4 and 8 checks + the first time check + end packet
+    uint8 nbChecks = urand(4, 8);
+    checkList->resize(nbChecks);
+
+    for (uint8 i=0; i<nbChecks; ++i)
+    {
+        // We select one based on the ratio
+        float mRand = rand_chance_f();
+        if (mRand < WCHECK_PAGE2_RATIO)                 // size 29, no string both page1 and page2 tests
+        {
+            (*checkList)[i].check = urand(0,1)?WARD_CHECK_PAGE1:WARD_CHECK_PAGE2;
+            (*checkList)[i].page = GetRandPageCheck();
+        }
+        else if (mRand < WCHECK_MEMORY_RATIO)           // size 6, possible string
+        {
+            (*checkList)[i].check = WARD_CHECK_MEMORY;
+            (*checkList)[i].mem = GetRandMemCheck();
+            if ((*checkList)[i].mem->String.length())   // add 1 for the uint8 str length
+            {
+                data << uint8((*checkList)[i].mem->String.length());
+                data.append((*checkList)[i].mem->String.c_str() ,(*checkList)[i].mem->String.length());
+                DEBUG_LOG("Mem str %s, len %u", (*checkList)[i].mem->String.c_str(), (*checkList)[i].mem->String.length());
+            }
+        }
+        else if (mRand < WCHECK_DRIVER_RATIO)
+        {
+            (*checkList)[i].check = WARD_CHECK_DRIVER;  // size 25 + string
+            (*checkList)[i].driver = GetRandDriverCheck();
+            data << uint8((*checkList)[i].driver->String.length());
+            data.append((*checkList)[i].driver->String.c_str(), (*checkList)[i].driver->String.length());
+            DEBUG_LOG("Driver str %s, len %u", (*checkList)[i].driver->String.c_str(), (*checkList)[i].driver->String.length());
+        }
+        else if (mRand < WCHECK_FILE_RATIO)
+        {
+            (*checkList)[i].check = WARD_CHECK_FILE;    // size 1 + string
+            (*checkList)[i].file = GetRandFileCheck();
+            data << uint8((*checkList)[i].file->String.length());
+            data.append((*checkList)[i].file->String.c_str(), (*checkList)[i].file->String.length());
+            DEBUG_LOG("File str %s, len %u", (*checkList)[i].file->String.c_str(), (*checkList)[i].file->String.length());
+        }
+        else
+        {
+            (*checkList)[i].check = WARD_CHECK_LUA;     // size 1 + string
+            (*checkList)[i].lua = GetRandLuaCheck();
+            data << uint8((*checkList)[i].lua->String.length());
+            data.append((*checkList)[i].lua->String.c_str(), (*checkList)[i].lua->String.length());
+            DEBUG_LOG("Lua str %s, len %u", (*checkList)[i].lua->String.c_str(), (*checkList)[i].lua->String.length());
+        }
+    }
+    // strings terminator
+    data << uint8(0);
+    // We first add a timing check
+    data << uint8(m_WardenModuleMap[md5][WARD_CHECK_TIMING] ^ m_seed1);
+    // Finaly put the other checks
+    uint8 m_strIndex = 1;
+    DEBUG_LOG("Preparing %u checks", nbChecks);
+    for (uint8 i=0; i<nbChecks; ++i)
+    {
+        data << uint8(m_WardenModuleMap[md5][(*checkList)[i].check] ^ m_seed1);
+        switch ((*checkList)[i].check)
+        {
+            case WARD_CHECK_PAGE1:
+            case WARD_CHECK_PAGE2:
+                DEBUG_LOG("%u : %s", i, (*checkList)[i].check==WARD_CHECK_PAGE1?"WARD_CHECK_PAGE1":"WARD_CHECK_PAGE2");
+                data << uint32((*checkList)[i].page->Seed);
+                data.append(&(*checkList)[i].page->SHA[0], 20);
+                data << uint32((*checkList)[i].page->Offset);
+                data << uint8((*checkList)[i].page->Length);
+                break;
+            case WARD_CHECK_MEMORY:
+                DEBUG_LOG("%u : WARD_CHECK_MEMORY", i);
+                if ((*checkList)[i].mem->String.length())
+                    data << uint8(m_strIndex++);
+                else
+                    data << uint8(0);
+                data << uint32((*checkList)[i].mem->Offset);
+                data << uint8((*checkList)[i].mem->Length);
+                break;
+            case WARD_CHECK_DRIVER:
+                DEBUG_LOG("%u : WARD_CHECK_DRIVER", i);
+                data << uint32((*checkList)[i].driver->Seed);
+                data.append(&(*checkList)[i].driver->SHA[0], 20);
+                data << uint8(m_strIndex++);
+                break;
+            case WARD_CHECK_FILE:
+                DEBUG_LOG("%u : WARD_CHECK_FILE", i);
+                data << uint8(m_strIndex++);
+                break;
+            case WARD_CHECK_LUA:
+                DEBUG_LOG("%u : WARD_CHECK_LUA", i);
+                data << uint8(m_strIndex++);
+                break;
+        }
+    }
+    data << uint8(m_WardenModuleMap[md5][WARD_CHECK_END] ^ m_seed1);
+
+    data.hexlike();
+    data.crypt(&session->m_rc4ServerKey[0], &rc4_crypt);
+    session->SendPacket(&data);
+}
+
+void WardenMgr::Pong()
+{
+    m_PingTimer.Reset();
+    m_PingOut = false;
+}
+
+void WardenMgr::SendPing()
+{
+    ByteBuffer pkt;
+    pkt << uint8(MMSG_PING);
+    m_WardenProcessStream->send((char const*)pkt.contents(), pkt.size());
+    m_PingOut = true;
+}
+
+void WardenMgr::SetInitialKeys(const uint8 *bSessionKey1, const uint8 *bSessionKey2, uint8* ClientKey, uint8 *ServerKey)
+{
+     uint8 bRandomData[20] = {0};
+     uint8 bRandomSource1[20] = {0};
+     uint8 bRandomSource2[20] = {0};
+
+     SHA1(bSessionKey1, 20, bRandomSource1);
+     SHA1(bSessionKey2, 20, bRandomSource2);
+
+     SHA_CTX mCtx;
+     SHA1_Init(&mCtx);
+
+     // compute hash
+     SHA1_Update(&mCtx, bRandomSource1, 20);
+     SHA1_Update(&mCtx, bRandomData, 20);
+     SHA1_Update(&mCtx, bRandomSource2, 20);
+
+     // finalize
+     SHA1_Final(bRandomData, &mCtx);
+
+     uint8 position = 0;
+     uint8 key[16] = {0};
+     for (uint8 i=0; i<16; ++i)
+     {
+         if (position >= 20)
+         {
+             SHA1_Init(&mCtx);
+             SHA1_Update(&mCtx, bRandomSource1, 20);
+             SHA1_Update(&mCtx, bRandomData, 20);
+             SHA1_Update(&mCtx, bRandomSource2, 20);
+             SHA1_Final(bRandomData, &mCtx);
+             position = 0;
+         }
+         key[i] = bRandomData[position];
+         ++position;
+     }
+     rc4_init(ClientKey, key, 16);
+
+     for (uint8 i=0; i<16; ++i)
+         key[i]=0;
+
+     for (uint8 i=0; i<16; ++i)
+     {
+         if (position >= 20)
+         {
+             SHA1_Init(&mCtx);
+             SHA1_Update(&mCtx, bRandomSource1, 20);
+             SHA1_Update(&mCtx, bRandomData, 20);
+             SHA1_Update(&mCtx, bRandomSource2, 20);
+             SHA1_Final(bRandomData, &mCtx);
+             position = 0;
+         }
+         key[i] = bRandomData[position];
+         ++position;
+     }
+     rc4_init(ServerKey, key, 16);
+}
+
+void WardenMgr::ChangeClientKey(WorldSession* const session)
+{
+    DEBUG_LOG("WardenMgr::ChangeClientKey");
+    memcpy(&session->m_rc4ClientKey[0], &session->m_WardenTmpClientKey[0], 0x102);
+}
+
+// Sending this packet to initialize engine functions warden uses
+void WardenMgr::SendWardenData(WorldSession* const session)
+{
+    DEBUG_LOG("WardenMgr::SendWardenData");
+    WorldPacket data(SMSG_WARDEN_DATA, 1 + 2+4+20 + 1 + 2+4+8 + 1 +2+4+8); // 42 // 57 // 3.3.5a init packet
+    data << uint8(WARDS_DATA);
+    {
+        data << uint16(20);
+        uint8 buff[20] =
+        {
+            0x01, 0x00, 0x02, 0x00,
+            0x80, 0x4F, 0x02, 0x00,     // 0x00400000 + 0x00024F80 SFileOpenFile
+            0xC0, 0x18, 0x02, 0x00,     // 0x00400000 + 0x000218C0 SFileGetFileSize
+            0x30, 0x25, 0x02, 0x00,     // 0x00400000 + 0x00022530 SFileReadFile
+            0x10, 0x29, 0x02, 0x00      // 0x00400000 + 0x00022910 SFileCloseFile
+        };
+        data << uint32(BuildChecksum(buff, 20));
+        data.append(buff, 20);
+    }
+    data << uint8(WARDS_DATA);
+    {
+        data << uint16(8);
+        uint8 buff[8] =
+        {
+           0x04, 0x00, 0x00,
+           0x40, 0x9D, 0x41, 0x00,      // 0x00400000 + 0x00419D40 FrameScript__GetText
+           0x01
+        };
+        data << uint32(BuildChecksum(buff, 8));
+        data.append(buff, 8);
+    }
+    // Computed part for timing checks (did not exist on Offy 3.3.5a)
+    data << uint8(WARDS_DATA);
+    {
+        data << uint16(8);
+        uint8 buff[8] =
+        {
+           0x01, 0x01, 0x00,
+           0x20, 0xAE, 0x46, 0x00,      // 0x00400000 + 0x0046AE20 PerformanceCounter
+           0x01
+        };
+        data << uint32(BuildChecksum(buff, 8));
+        data.append(buff, 8);
+    }
+
+    data.hexlike();
+    data.crypt(&session->m_rc4ServerKey[0], &rc4_crypt);
+    session->SendPacket(&data);
+}
+
+uint32 WardenMgr::BuildChecksum(const uint8* data, uint32 dataLen)
+{
+    uint8 hash[20];
+    SHA1(data, dataLen, hash);
+    uint32 checkSum = 0;
+    for (uint8 i=0; i<5; ++i)
+        checkSum = checkSum ^ *(uint32*)(&hash[0] + i*4);
+    return checkSum;
+}
+
+bool WardenMgr::ValidateTSeed(WorldSession* const session, const uint8 *codedClientTSeed)
+{
+    uint8 codedServerTSeed[20];
+    SHA1(&session->m_wardenSeed[0], 16, &codedServerTSeed[0]);
+    if (memcmp(&codedServerTSeed[0], codedClientTSeed, 20))
+    {
+        ReactToCheatCheckResult(session, false);
+        return false;
+    }
+    return true;
+}
+
+bool WardenMgr::ValidateCheatCheckResult(WorldSession* const session, WorldPacket& clientPacket)
+{
+    uint32 accountId = session->GetAccountId();
+    DEBUG_LOG("Wardend::ValidateCheatCheckResult(%u, *pkt)", accountId);
+    bool valid = true;
+
+    uint16 pktLen;
+    uint32 checksum;
+    clientPacket >> pktLen;
+    clientPacket >> checksum;
+    if (checksum != BuildChecksum(clientPacket.contents() + clientPacket.rpos(), clientPacket.size() - clientPacket.rpos()))
+    {
+        BASIC_LOG("Warden Cheat-check: Kicking account %u for failed check, Packet Checksum 0x%08X is invalid!", session->GetAccountId(), checksum);
+        ReactToCheatCheckResult(session, false);
+        return false;
+    }
+
+    if (pktLen==0)
+        return false;
+
+    // parse the timing check always sent
+    DEBUG_LOG("TimeCheck");
+    uint8 res;
+    uint32 ticks;
+    clientPacket >> res; // should be 1
+    clientPacket >> ticks;
+    // Need to compare ticks based on last one using server ticks diff since
+    DEBUG_LOG("Time unk 0x%08X", ticks);
+    pktLen = pktLen - 5;
+
+    WardenClientCheckList* checkList = (WardenClientCheckList*)session->m_WardenClientChecks;
+    if (!checkList)
+        return false;
+
+    for (uint8 i=0; i<checkList->size(); ++i)
+    {
+        bool localCheck = true;
+        switch ((*checkList)[i].check)
+        {
+            case WARD_CHECK_TIMING:
+            {
+                DEBUG_LOG("TimeCheck");
+                uint8 res;
+                uint32 ticks;
+                clientPacket >> res; // should be 1
+                clientPacket >> ticks;
+                // Need to compare ticks based on last one using server ticks diff since
+                DEBUG_LOG("Time unk 0x%08X", ticks);
+                pktLen = pktLen - 5;
+                break;
+            }
+            case WARD_CHECK_MEMORY:
+            {
+                DEBUG_LOG("MemCheck");
+                uint8 res;
+                clientPacket >> res; // should be 0
+                if (res)
+                {
+                    localCheck = false;
+                    BASIC_LOG("Kicking account %u for failed check, MEM at Offset 0x%04X, lentgh %u could not be read by client", accountId, (*checkList)[i].mem->Offset, (*checkList)[i].mem->Length);
+                }
+                else
+                {
+                    uint8 memContent[20];
+                    for (uint8 pos=0; pos<(*checkList)[i].mem->Length; ++pos)
+                        clientPacket >> memContent[pos];
+                    if (memcmp(&memContent[0], &(*checkList)[i].mem->Result[0], (*checkList)[i].mem->Length))
+                    {
+                        localCheck = false;
+                        std::string strContent, strContent2;
+                        hexEncodeByteArray(memContent, (*checkList)[i].mem->Length, strContent);
+                        hexEncodeByteArray((*checkList)[i].mem->Result, (*checkList)[i].mem->Length, strContent2);
+                        BASIC_LOG("Kicking account %u for failed check, MEM Offset 0x%04X length %u has content '%s' instead of '%s'",
+                            accountId, (*checkList)[i].mem->Offset, (*checkList)[i].mem->Length, strContent.c_str(), strContent2.c_str());
+                    }
+                    pktLen = pktLen - (1 + (*checkList)[i].mem->Length);
+                }
+                DEBUG_LOG("Mem %s",localCheck?"Ok":"Failed");
+                break;
+            }
+            case WARD_CHECK_FILE:
+            {
+                DEBUG_LOG("MPQCheck");
+                uint8 res;
+                uint8 resSHA1[20];
+                clientPacket >> res; // should be 0
+                if (res)
+                {
+                    localCheck = false;
+                    BASIC_LOG("Kicking account %u for failed check, MPQ '%s' not found by client", accountId, (*checkList)[i].file->String.c_str());
+                    pktLen = pktLen - 1;
+                }
+                else
+                {
+                    for (uint8 pos=0; pos<20; ++pos)
+                        clientPacket >> resSHA1[pos];
+                    if (res || memcmp(resSHA1, (*checkList)[i].file->SHA, 20))
+                    {
+                        localCheck = false;
+                        std::string strResSHA1, strReqSHA1;
+                        hexEncodeByteArray(resSHA1, 20, strResSHA1);
+                        hexEncodeByteArray((*checkList)[i].file->SHA, 20, strReqSHA1);
+                        BASIC_LOG("Kicking account %u for failed check, MPQ '%s' SHA1 is '%s' instead of '%s'", accountId, (*checkList)[i].file->String.c_str(), strResSHA1.c_str(), strReqSHA1.c_str());
+                    }
+                    pktLen = pktLen - 21;
+                }
+                DEBUG_LOG("MPQ %s",localCheck?"Ok":"Failed");
+                break;
+            }
+            case WARD_CHECK_LUA:
+            {
+                DEBUG_LOG("LUACheck");
+                uint8 res;
+                uint8 foundLuaLen;
+                clientPacket >> res; // should be 0
+                clientPacket >> foundLuaLen; // should be 0
+                uint8 *luaStr;
+                if (foundLuaLen > 0)
+                {
+                    luaStr = (uint8*)malloc(foundLuaLen+1);
+                    for (uint8 pos=0; pos<foundLuaLen; ++pos)
+                    {
+                        clientPacket >> luaStr[pos];
+                    }
+                    luaStr[foundLuaLen] = 0;
+                    BASIC_LOG("Kicking account %u for failed check, Lua '%s' found as '%s'", accountId, (*checkList)[i].lua->String.c_str(), (char*)luaStr);
+                    localCheck = false;
+                    free(luaStr);
+                }
+                DEBUG_LOG("Lua %s",localCheck?"Ok":"Failed");
+                pktLen = pktLen - 2;
+                break;
+            }
+            case WARD_CHECK_PAGE1:
+            case WARD_CHECK_PAGE2:
+            case WARD_CHECK_DRIVER:
+            {
+                DEBUG_LOG("PageCheck or DriverCheck");
+                uint8 res;
+                clientPacket >> res; // should be 0xE9
+                if (res != 0xE9)
+                {
+                    if ((*checkList)[i].check == WARD_CHECK_DRIVER)
+                        BASIC_LOG("Kicking account %u for failed driver check '%s'", accountId ,(*checkList)[i].driver->String.c_str());
+                    else
+                        BASIC_LOG("Kicking account %u for failed page check Offset 0x%08X, length %u", accountId, (*checkList)[i].page->Offset, (*checkList)[i].page->Length);
+                    localCheck = false;
+                }
+                DEBUG_LOG("Page or Driver %s",localCheck?"Ok":"Failed");
+                pktLen = pktLen - 1;
+                break;
+            }
+            default:
+                DEBUG_LOG("Other!!");
+                // Finish skiping the rest of the packet and return failed checks
+                BASIC_LOG("Wrong packet for account %u or problem to parse it, I had to clean %u bytes", accountId, clientPacket.size() - clientPacket.rpos());
+                clientPacket.read_skip(clientPacket.size() - clientPacket.rpos());
+                return false;
+        }
+        valid = valid && localCheck;
+    }
+    return valid;
+}
+
+void WardenMgr::ReactToCheatCheckResult(WorldSession* const session, bool result)
+{
+    DEBUG_LOG("ReactToCheatCheckResult %s",result?"true":"false");
+    if (result)
+    {
+        session->m_wardenStatus = WARD_STATE_CHEAT_CHECK_IN;
+        const uint32 shortTime = urand(15, 25);                 // from 15 to 25 seconds
+        session->m_WardenTimer.SetInterval(shortTime * IN_MILLISECONDS);
+        DEBUG_LOG("Timer set to %u seconds", shortTime);
+        session->m_WardenTimer.SetCurrent(0);                   // Full time choosen
+    }
+    else
+    {
+        if (m_Banning)
+            sWorld.BanAccount(session, sWorld.getConfig(CONFIG_UINT32_WARDEN_BAN_TIME) * 24 * HOUR, "Cheating software usage", "Warden System");
+        else
+            session->KickPlayer();
+    }
+}
+
+/////////////////////////////
+// Session
+/////////////////////////////
+void WorldSession::HandleWardenRegister()
+{
+    if (sWardenMgr.IsEnabled() && m_wardenStatus == WARD_STATE_UNREGISTERED)
+        sWardenMgr.Register(this);
+}
+
+void WorldSession::HandleWardenUnregister()
+{
+    if (sWardenMgr.IsEnabled())
+        sWardenMgr.Unregister(this);
+}
+
+void WorldSession::HandleWardenDataOpcode(WorldPacket& recv_data)
+{
+    if (sWardenMgr.IsEnabled())
+    {
+        recv_data.crypt(m_rc4ClientKey, &rc4_crypt);
+        uint8 warden_opcode;
+        recv_data >> warden_opcode;
+        recv_data.hexlike();
+        switch(warden_opcode)
+        {
+            case WARDC_MODULE_LOAD_FAILED:
+                DEBUG_LOG("Received the reply load failed");
+                // We have to send the module
+                if (m_wardenStatus == WARD_STATE_LOAD_FAILED)
+                {
+                    KickPlayer();
+                }
+                else
+                {
+                    sWardenMgr.SendModule(this);
+                    m_wardenStatus = WARD_STATE_LOAD_FAILED;
+                    m_WardenTimer.SetInterval(30 * IN_MILLISECONDS);
+                    m_WardenTimer.Reset();
+                }
+                break;
+            case WARDC_MODULE_LOADED:
+                DEBUG_LOG("Received the reply module loaded");
+                // We go next step: Send a seed
+                sWardenMgr.SendSeedAndComputeKeys(this);
+                m_WardenTimer.SetInterval(5 * IN_MILLISECONDS);
+                m_WardenTimer.Reset();
+                break;
+            case WARDC_CHEAT_CHECK_RESULT:
+            {
+                DEBUG_LOG("Received the cheat-check result");
+                bool result = sWardenMgr.ValidateCheatCheckResult(this, recv_data);
+                sWardenMgr.ReactToCheatCheckResult(this, result);   // This sets the timer if needed
+                break;
+            }
+            case WARDC_TRANSFORMED_SEED:
+                DEBUG_LOG("Received the transformed seed");
+                // Let's validate this data
+                if (sWardenMgr.ValidateTSeed(this, recv_data.contents()+recv_data.rpos()))
+                {
+                    sWardenMgr.ChangeClientKey(this);
+                    sWardenMgr.SendWardenData(this);
+                    m_wardenStatus = WARD_STATE_CHEAT_CHECK_IN;
+                    m_WardenTimer.SetInterval(3 * IN_MILLISECONDS); // 3 secs before the 1st cheat check
+                    m_WardenTimer.Reset();
+                }
+                recv_data.read_skip(20);
+                break;
+            default:
+                DEBUG_LOG("Problem with packet");
+        }
+    }
+    else
+    {
+        recv_data.read_skip<uint8>();
+        DEBUG_LOG("Received opcode CMSG_WARDEN_DATA, but this session has no module linked");
+    }
+}
+
+//****************************************************
+// Warden Demon replies handlers
+
+const WardenSvcHandler::WardenMgrCmd table[] =
+{
+    { WMSG_WARDEN_KEYS,                 &WardenSvcHandler::_HandleNewKeys                   },
+    { WMSG_PONG,                        &WardenSvcHandler::_HandlePong                      },
+    { WMSG_CONNECTION_END,              &WardenSvcHandler::_HandleDisconnect                }
+};
+
+#define WARDEN_REPLY_TOTAL_COMMANDS sizeof(table)/sizeof(WardenMgrCmd)
+
+int WardenSvcHandler::open(void*)
+{
+    BASIC_LOG("Connection to Warden Daemon established");
+    ACE_Reactor::instance()->register_handler(this, ACE_Event_Handler::READ_MASK);
+    Peer=&peer();
+    return 0;
+}
+
+int WardenSvcHandler::handle_input(ACE_HANDLE /*handle*/)
+{
+    uint8 _cmd;
+    Peer->recv_n(&_cmd, 1);
+    bool _valid = false;
+
+    for (int i = 0; i < WARDEN_REPLY_TOTAL_COMMANDS; ++i)
+    {
+        if ((uint8)table[i].cmd == _cmd)
+        {
+            _valid = true;
+            if (!(*this.*table[i].handler)())
+                return 0;
+            break;
+        }
+    }
+    if (!_valid) // Empty the queue
+    {
+        uint8 _trash[1024];
+        sLog.outError("Unexpected packet [%u] from Wardend, trashing it", _cmd);
+        Peer->recv_n(_trash, 1024);
+    }
+    return 0;
+}
+
+bool WardenSvcHandler::_HandleNewKeys()
+{
+    DEBUG_LOG("WardenSvcHandler::_HandleNewKeys()");
+    uint32 accountId;
+    Peer->recv_n(&accountId, 4);
+    WorldSession* session = sWorld.FindSession(accountId);
+    if (session) // in case client disconnected in between
+    {
+        // 1st, send the transformed seed request to client
+        sWardenMgr.SendSeedTransformRequest(session);
+        // now we can change the server key
+        Peer->recv_n(session->GetWardenServerKey(), 0x102);
+        // But we need a Transformed seed reply from client before changing the client key
+        // So saving it
+        Peer->recv_n(session->GetWardenTempClientKey(), 0x102);
+        // The seed can be overwritten since we did use the original one to build the client request
+        Peer->recv_n(session->GetWardenSeed(), 16);
+    }
+    else
+    {
+        // Trash the packet
+        uint8 trash;
+        for (uint32 i=0; i<(0x102+0x102+16); ++i)
+        {
+            Peer->recv_n(&trash, 1);
+        }
+    }
+    return true;
+}
+
+bool WardenSvcHandler::_HandlePong()
+{
+    sWardenMgr.Pong();
+    return true;
+}
+
+bool WardenSvcHandler::_HandleDisconnect()
+{
+    sWardenMgr.SetDisconnected();
+    return true;
+}
+
+INSTANTIATE_SINGLETON_1(WardenMgr);
diff --git a/src/game/WardenMgr.h b/src/game/WardenMgr.h
new file mode 100644
--- /dev/null
+++ b/src/game/WardenMgr.h
@@ -0,0 +1,230 @@
+/*
+ * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef MANGOS_WARDEN_MGR_H
+#define MANGOS_WARDEN_MGR_H
+
+#include "Common.h"
+#include "SharedDefines.h"
+#include "Platform/Define.h"
+#include "Policies/Singleton.h"
+#include "../wardend/WardendProtocol.h"
+#include "WorldSession.h"
+#include "Util.h"
+#include "Auth/BigNumber.h"
+#include "WorldPacket.h"
+#include "Opcodes.h"
+#include <ace/Connector.h>
+#include <ace/SOCK_Connector.h>
+#include <ace/SOCK_Stream.h>
+#include <ace/Svc_Handler.h>
+#include <ace/Dev_Poll_Reactor.h>
+#include <ace/Reactor.h>
+
+#include <openssl/sha.h>
+
+// Definition of ratio of check types (based on a long session of 1162 checks)
+// They are cumulative, meaning that I add the %age to the previous one
+#define WCHECK_PAGE1_RATIO  25.0f   // 36.5
+#define WCHECK_PAGE2_RATIO  50.0f   // 36.5
+#define WCHECK_MEMORY_RATIO 94.0f   // 21.0
+#define WCHECK_DRIVER_RATIO 97.4f   // 03.4
+#define WCHECK_FILE_RATIO   98.7f   // 01.3
+#define WCHECK_LUA_RATIO   100.0f   // 01.3
+
+// State machine for warden activity on one session
+enum eWardenClientState
+{
+    WARD_STATE_UNREGISTERED,
+    WARD_STATE_LOAD_MODULE,
+    WARD_STATE_LOAD_FAILED,
+    WARD_STATE_TRANSFORM_SEED,
+    WARD_STATE_CHEAT_CHECK_IN,
+    WARD_STATE_CHEAT_CHECK_OUT,
+    WARD_STATE_USER_DISABLED,
+    WARD_STATE_PENDING_WARDEND,
+    WARD_STATE_NEED_WARDEND,
+};
+
+class WardenSvcHandler: public ACE_Svc_Handler <ACE_SOCK_STREAM, ACE_NULL_SYNCH>
+{
+    public:
+        typedef struct WardenMgrCmd
+        {
+            eWardendOpcode cmd;
+            bool (WardenSvcHandler::*handler)(void);
+        }WardenHandler;
+
+        // Deamon replies related
+        bool _HandleDisconnect();
+        bool _HandlePong();
+        bool _HandleNewKeys();
+
+        ACE_SOCK_Stream* Peer;
+        int open(void*);
+        int handle_input(ACE_HANDLE);
+
+    private:
+
+};
+
+typedef ACE_Connector<WardenSvcHandler, ACE_SOCK_CONNECTOR> WardendConnector;
+
+class WardenMgr
+{
+    public:
+        WardenMgr();
+        ~WardenMgr();
+        void Initialize(const char* addr, u_short port, bool IsBanning);
+        void SetDisabled() { m_Enabled = false; }
+        bool IsEnabled() { return m_Enabled; }
+
+        // Update
+        void Update(uint32 diff);                               // Global Warden System update for packets send/receive
+        void Update(WorldSession* const session);               // Session specific update
+
+        // Connection Management
+    private:
+        void SendPing();
+    public:
+        void Pong();
+        void SetDisconnected();
+    private:
+        // Structure to store checks
+        struct MemoryCheckEntry
+        {
+            std::string String;
+            uint32 Offset;
+            uint8 Length;
+            uint8 Result[20];
+        };
+        struct PageCheckEntry
+        {
+            uint32 Seed;
+            uint8 SHA[20];
+            uint32 Offset;
+            uint8 Length;
+        };
+        struct FileCheckEntry
+        {
+            std::string String;
+            uint8 SHA[20];
+        };
+        struct LuaCheckEntry
+        {
+            std::string String;
+        };
+        struct DriverCheckEntry
+        {
+            uint32 Seed;
+            uint8 SHA[20];
+            std::string String;
+        };
+        struct ModuleCheckEntry
+        {
+            uint32 Seed;
+            uint8 SHA[20];
+        };
+        struct GenericCheck
+        {
+            uint8 check;
+            union
+            {
+                MemoryCheckEntry* mem;
+                PageCheckEntry* page;
+                FileCheckEntry* file;
+                LuaCheckEntry* lua;
+                DriverCheckEntry* driver;
+                ModuleCheckEntry* module;
+            };
+        };
+
+        typedef std::vector<uint8> WardenCheckMap; // store the check ids
+        typedef std::map<std::string, WardenCheckMap> WardenModuleMap; // module md5/check ids
+
+        typedef std::vector<MemoryCheckEntry> WardenMemoryChecks;
+        typedef std::vector<PageCheckEntry> WardenPageChecks;
+        typedef std::vector<FileCheckEntry> WardenFileChecks;
+        typedef std::vector<LuaCheckEntry> WardenLuaChecks;
+        typedef std::vector<DriverCheckEntry> WardenDriverChecks;
+        //typedef std::vector<ModuleCheckEntry> WardenModulehecks;
+
+        typedef std::vector<GenericCheck> WardenClientCheckList;
+
+    private:
+        bool InitializeCommunication();
+        bool LoadFromDB();
+        bool CheckModuleExistOnDisk(const std::string &md5);
+        void RandAModuleMd5(std::string *result);
+    public:
+        void Register(WorldSession* const session);
+    private:
+        void StartForSession(WorldSession* const session);
+        void SetInitialKeys(const uint8 *bSessionKey1, const uint8 *bSessionKey2, uint8* ClientKey, uint8 *ServerKey);
+    public:
+        void SendLoadModuleRequest(WorldSession* const session);
+        void SendModule(WorldSession* const session);
+        void SendSeedAndComputeKeys(WorldSession* const session);
+        void SendSeedTransformRequest(WorldSession* const session);
+    private:
+        void LoadModuleAndGetKeys(WorldSession* const session);
+    public:
+        bool ValidateTSeed(WorldSession* const session, const uint8 *codedClientTSeed);
+        void ChangeClientKey(WorldSession* const session);
+        void SendWardenData(WorldSession* const session);
+    private:
+        void SendCheatCheck(WorldSession* const session);
+    public:
+        bool ValidateCheatCheckResult(WorldSession* const session, WorldPacket& clientPacket);
+        void Unregister(WorldSession* const session);
+        void ReactToCheatCheckResult(WorldSession* const session, bool result);
+    private:
+        MemoryCheckEntry *GetRandMemCheck();
+        PageCheckEntry *GetRandPageCheck();
+        FileCheckEntry *GetRandFileCheck();
+        LuaCheckEntry *GetRandLuaCheck();
+        DriverCheckEntry *GetRandDriverCheck();
+
+        uint32 BuildChecksum(const uint8* data, uint32 dataLen);
+
+    protected:
+        ACE_SOCK_Stream         *m_WardenProcessStream;
+        ACE_SOCK_Connector      *m_WardenProcessConnection;
+
+        bool                    m_HalfCall;
+        bool                    m_Enabled;
+        bool                    m_PingOut;
+        bool                    m_Disconnected;
+        bool                    m_Banning;
+        std::string             m_WardendAddress;
+        u_short                 m_WardendPort;
+        WardendConnector        m_Connector;
+        ShortIntervalTimer      m_PingTimer;
+
+        WardenModuleMap         m_WardenModuleMap;
+
+        WardenMemoryChecks      m_WardenMemoryChecks;
+        WardenPageChecks        m_WardenPageChecks;
+        WardenFileChecks        m_WardenFileChecks;
+        WardenLuaChecks         m_WardenLuaChecks;
+        WardenDriverChecks      m_WardenDriverChecks;
+        //WardenModuleChecks    m_WardenModuleChecks;
+};
+
+#define sWardenMgr MaNGOS::Singleton<WardenMgr>::Instance()
+#endif
diff --git a/src/game/World.cpp b/src/game/World.cpp
index 45eab78..804335b 100644
--- a/src/game/World.cpp
+++ b/src/game/World.cpp
@@ -61,6 +61,7 @@
 #include "GMTicketMgr.h"
 #include "Util.h"
 #include "CharacterDatabaseCleaner.h"
+#include "WardenMgr.h"
 
 INSTANTIATE_SINGLETON_1( World );
 
@@ -883,6 +884,8 @@ void World::LoadConfigSettings(bool reload)
     sLog.outString( "WORLD: VMap support included. LineOfSight:%i, getHeight:%i, indoorCheck:%i",
         enableLOS, enableHeight, getConfig(CONFIG_BOOL_VMAP_INDOOR_CHECK) ? 1 : 0);
     sLog.outString( "WORLD: VMap data directory is: %svmaps",m_dataPath.c_str());
+    // Warden ban time
+    setConfig(CONFIG_UINT32_WARDEN_BAN_TIME, "Wardend.BanLength", 1);
 }
 
 /// Initialize the World
@@ -1353,6 +1356,20 @@ void World::SetInitialWorldSettings()
     uint32 nextGameEvent = sGameEventMgr.Initialize();
     m_timers[WUPDATE_EVENTS].SetInterval(nextGameEvent);    //depend on next event
 
+    if (sConfig.GetBoolDefault("wardend.Enable"))
+    {
+        sLog.outString("Starting Warden system...");
+        sWardenMgr.Initialize(sConfig.GetStringDefault("wardend.Address", "127.0.0.1").c_str(),
+            sConfig.GetIntDefault("wardend.Port", DEFAULT_WARDENSERVER_PORT),
+            sConfig.GetBoolDefault("wardend.Ban"));
+        m_timers[WUPDATE_WARDEN].SetInterval(1 * IN_MILLISECONDS);
+    }
+    else
+    {
+        sLog.outString("Warden system disabled, skipping");
+        sWardenMgr.SetDisabled();
+    }
+
     // Delete all characters which have been deleted X days before
     Player::DeleteOldCharacters();
 
@@ -1491,6 +1508,18 @@ void World::Update(uint32 diff)
     sMapMgr.Update(diff);
     sBattleGroundMgr.Update(diff);
 
+    ///- <li> Handle warden manager update
+    if (m_timers[WUPDATE_WARDEN].Passed())
+    {
+        ///- Update WardenTimer in all sessions
+        for (SessionMap::iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+            itr->second->UpdateWardenTimer(m_timers[WUPDATE_WARDEN].GetCurrent());
+
+        ///- Then call the update method of WardenMgr Singleton
+        sWardenMgr.Update(m_timers[WUPDATE_WARDEN].GetCurrent());
+        m_timers[WUPDATE_WARDEN].SetCurrent(0);
+    }
+
     ///- Delete all characters which have been deleted X days before
     if (m_timers[WUPDATE_DELETECHARS].Passed())
     {
@@ -1688,6 +1717,19 @@ void World::KickAllLess(AccountTypes sec)
             itr->second->KickPlayer();
 }
 
+BanReturn World::BanAccount(WorldSession *session, uint32 duration_secs, std::string reason, std::string author)
+{
+    if (duration_secs)
+        LoginDatabase.PExecute("INSERT INTO account_banned VALUES ('%u', UNIX_TIMESTAMP(), UNIX_TIMESTAMP()+%u, '%s', '%s', '1')",
+            session->GetAccountId(), duration_secs, author.c_str(), reason.c_str());
+    else
+        LoginDatabase.PExecute("INSERT INTO account_banned VALUES ('%u', UNIX_TIMESTAMP(), 0, '%s', '%s', '1')",
+            session->GetAccountId(), author.c_str(), reason.c_str());
+
+    session->KickPlayer();
+    return BAN_SUCCESS;
+}
+
 /// Ban an account or ban an IP address, duration_secs if it is positive used, otherwise permban
 BanReturn World::BanAccount(BanMode mode, std::string nameOrIP, uint32 duration_secs, std::string reason, std::string author)
 {
diff --git a/src/game/World.h b/src/game/World.h
--- a/src/game/World.h
+++ b/src/game/World.h
@@ -77,7 +77,8 @@ enum WorldTimers
     WUPDATE_CORPSES     = 3,
     WUPDATE_EVENTS      = 4,
     WUPDATE_DELETECHARS = 5,
-    WUPDATE_COUNT       = 6
+    WUPDATE_WARDEN      = 6,
+    WUPDATE_COUNT       = 7
 };
 
 /// Configuration elements
@@ -186,6 +187,7 @@ enum eConfigUInt32Values
     CONFIG_UINT32_GUID_RESERVE_SIZE_CREATURE,
     CONFIG_UINT32_GUID_RESERVE_SIZE_GAMEOBJECT,
     CONFIG_UINT32_MIN_LEVEL_FOR_RAID,
+    CONFIG_UINT32_WARDEN_BAN_TIME,
     CONFIG_UINT32_VALUE_COUNT
 };
 
@@ -547,6 +549,7 @@ class World
         void KickAll();
         void KickAllLess(AccountTypes sec);
         BanReturn BanAccount(BanMode mode, std::string nameOrIP, uint32 duration_secs, std::string reason, std::string author);
+        BanReturn BanAccount(WorldSession *session, uint32 duration_secs, std::string reason, std::string author);
         bool RemoveBanAccount(BanMode mode, std::string nameOrIP);
 
         // for max speed access
diff --git a/src/game/WorldSession.cpp b/src/game/WorldSession.cpp
--- a/src/game/WorldSession.cpp
+++ b/src/game/WorldSession.cpp
@@ -29,6 +29,7 @@
 #include "WorldSession.h"
 #include "Player.h"
 #include "ObjectMgr.h"
+#include "WardenMgr.h"
 #include "Group.h"
 #include "Guild.h"
 #include "World.h"
@@ -84,7 +85,7 @@ WorldSession::WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, uint8
 m_muteTime(mute_time), _player(NULL), m_Socket(sock),_security(sec), _accountId(id), m_expansion(expansion), _logoutTime(0),
 m_inQueue(false), m_playerLoading(false), m_playerLogout(false), m_playerRecentlyLogout(false), m_playerSave(false),
 m_sessionDbcLocale(sWorld.GetAvailableDbcLocale(locale)), m_sessionDbLocaleIndex(sObjectMgr.GetIndexForLocale(locale)),
-m_latency(0), m_tutorialState(TUTORIALDATA_UNCHANGED)
+m_latency(0), m_tutorialState(TUTORIALDATA_UNCHANGED), m_wardenStatus(WARD_STATE_UNREGISTERED), m_WardenClientChecks(NULL)
 {
     if (sock)
     {
@@ -112,6 +113,9 @@ WorldSession::~WorldSession()
     WorldPacket* packet;
     while(_recvQueue.next(packet))
         delete packet;
+
+    ///- inform Warden Manager
+    sWardenMgr.Unregister(this);
 }
 
 void WorldSession::SizeError(WorldPacket const& packet, uint32 size) const
@@ -318,6 +322,10 @@ bool WorldSession::Update(PacketFilter& updater)
             return false;                                       //Will remove this session from the world session map
     }
 
+    //Process Warden related update for this session
+    if (sWardenMgr.IsEnabled())
+        sWardenMgr.Update(this);                                //Called 2 times from Map::Update and World::UpdateSessions
+
     return true;
 }
 
diff --git a/src/game/WorldSession.h b/src/game/WorldSession.h
--- a/src/game/WorldSession.h
+++ b/src/game/WorldSession.h
@@ -28,6 +28,7 @@
 #include "ObjectGuid.h"
 #include "AuctionHouseMgr.h"
 #include "Item.h"
+#include "Timer.h"
 
 struct ItemPrototype;
 struct AuctionEntry;
@@ -227,6 +228,7 @@ class WorldSessionFilter : public PacketFilter
 class MANGOS_DLL_SPEC WorldSession
 {
     friend class CharacterHandler;
+    friend class WardenMgr;
     public:
         WorldSession(uint32 id, WorldSocket *sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale);
         ~WorldSession();
@@ -394,6 +396,11 @@ class MANGOS_DLL_SPEC WorldSession
         void SetLatency(uint32 latency) { m_latency = latency; }
         uint32 getDialogStatus(Player *pPlayer, Object* questgiver, uint32 defstatus);
 
+        uint8 *GetWardenServerKey() { return &m_rc4ServerKey[0]; }
+        uint8 *GetWardenSeed() { return &m_wardenSeed[0]; }
+        uint8 *GetWardenTempClientKey() { return &m_WardenTmpClientKey[0]; }
+        void UpdateWardenTimer(uint32 diff) { m_WardenTimer.Update(diff); }
+
     public:                                                 // opcodes handlers
 
         void Handle_NULL(WorldPacket& recvPacket);          // not used
@@ -757,7 +764,11 @@ class MANGOS_DLL_SPEC WorldSession
         void HandleBattlemasterJoinArena( WorldPacket &recv_data );
         void HandleReportPvPAFK( WorldPacket &recv_data );
 
+        //Warden
         void HandleWardenDataOpcode(WorldPacket& recv_data);
+        void HandleWardenRegister();                        // for internal call
+        void HandleWardenUnregister();                      // for internal call
+
         void HandleWorldTeleportOpcode(WorldPacket& recv_data);
         void HandleMinimapPingOpcode(WorldPacket& recv_data);
         void HandleRandomRollOpcode(WorldPacket& recv_data);
@@ -886,6 +897,15 @@ class MANGOS_DLL_SPEC WorldSession
         TutorialDataState m_tutorialState;
         AddonsList m_addonsList;
         ACE_Based::LockedQueue<WorldPacket*, ACE_Thread_Mutex> _recvQueue;
+
+        uint8 m_wardenStatus;
+        uint8 m_rc4ServerKey[0x102];
+        uint8 m_rc4ClientKey[0x102];
+        uint8 m_wardenSeed[16];
+        ShortIntervalTimer m_WardenTimer;
+        std::string m_WardenModule;
+        void *m_WardenClientChecks;
+        uint8 m_WardenTmpClientKey[0x102];
 };
 #endif
 /// @}
diff --git a/src/game/WorldSocket.cpp b/src/game/WorldSocket.cpp
--- a/src/game/WorldSocket.cpp
+++ b/src/game/WorldSocket.cpp
@@ -823,7 +823,6 @@ int WorldSocket::HandleAuthSession (WorldPacket& recvPacket)
 
     v.SetHexStr(fields[5].GetString());
     s.SetHexStr (fields[6].GetString());
-    m_s = s;
 
     const char* sStr = s.AsHexStr ();                       //Must be freed by OPENSSL_free()
     const char* vStr = v.AsHexStr ();                       //Must be freed by OPENSSL_free()
@@ -856,6 +855,7 @@ int WorldSocket::HandleAuthSession (WorldPacket& recvPacket)
         security = SEC_ADMINISTRATOR;
 
     K.SetHexStr (fields[2].GetString ());
+    m_s = K;
 
     time_t mutetime = time_t (fields[8].GetUInt64 ());
 
diff --git a/src/mangosd/mangosd.conf.dist.in b/src/mangosd/mangosd.conf.dist.in
--- a/src/mangosd/mangosd.conf.dist.in
+++ b/src/mangosd/mangosd.conf.dist.in
@@ -3,7 +3,7 @@
 #####################################
 
 [MangosdConf]
-ConfVersion=2010100901
+ConfVersion=2011031601
 
 ###################################################################################################################
 # CONNECTIONS AND DIRECTORIES
@@ -1624,3 +1624,38 @@ SOAP.Port = 7878
 CharDelete.Method = 0
 CharDelete.MinLevel = 0
 CharDelete.KeepDays = 30
+
+###################################################################################################################
+# WARDEN DAEMON - This daemon requires a Windows box to run. If you don't have any, let it disabled
+#
+#    Wardend.Enable
+#        Enable or disable warden functionnalities
+#        Default: 0  - Disabled, mangosd will neither use wardend, not generate any warden related traffic
+#                 1  - Enable, mangosd will connect to wardend and generate cheat ckecks for all sessions
+#
+#    Wardend.Ban
+#        Enable or disable banning accounts
+#                 0  - Disabled, mangosd will kick accounts failing a cheat-check
+#        Default: 1  - Enable, mangosd will ban any account failing a cheat-check for Wardend.BanLength configured
+#                      next line
+#
+#   Wardend.BanLength
+#        Length in days an account failing a cheat-check is banned
+#                 0 - Infinite ban
+#        Default: 1 - 1 day
+#
+#   Wardend.Address
+#        IP Address of the computer running the Win32 Warden Daemon
+#        Default: 127.0.0.1  - Assume you run the Warden Daemon on the same machine as Mangos Daemon and on Windows
+#
+#   Wardend.Port
+#        Port on which the Warden Daemon listens
+#        Default: 6555
+#
+###################################################################################################################
+
+Wardend.Enable = 0
+Wardend.Ban = 1
+Wardend.BanLength = 1
+Wardend.Address = "127.0.0.1"
+Wardend.Port = 6555
diff --git a/src/realmd/AuthSocket.cpp b/src/realmd/AuthSocket.cpp
--- a/src/realmd/AuthSocket.cpp
+++ b/src/realmd/AuthSocket.cpp
@@ -62,7 +62,7 @@ typedef struct AUTH_LOGON_CHALLENGE_C
     uint8   version3;
     uint16  build;
     uint8   platform[4];
-    uint8   os[4];
+    uint32  os;
     uint8   country[4];
     uint32  timezone_bias;
     uint32  ip;
@@ -343,7 +343,7 @@ bool AuthSocket::_HandleLogonChallenge()
     EndianConvert(*((uint32*)(&ch->gamename[0])));
     EndianConvert(ch->build);
     EndianConvert(*((uint32*)(&ch->platform[0])));
-    EndianConvert(*((uint32*)(&ch->os[0])));
+    EndianConvert(ch->os);
     EndianConvert(*((uint32*)(&ch->country[0])));
     EndianConvert(ch->timezone_bias);
     EndianConvert(ch->ip);
@@ -352,6 +352,7 @@ bool AuthSocket::_HandleLogonChallenge()
 
     _login = (const char*)ch->I;
     _build = ch->build;
+    _os = ch->os;
 
     ///- Normalize account name
     //utf8ToUpperOnlyLatin(_login); -- client already send account in expected form
@@ -665,7 +666,7 @@ bool AuthSocket::_HandleLogonProof()
         ///- Update the sessionkey, last_ip, last login time and reset number of failed logins in the account table for this account
         // No SQL injection (escaped user name) and IP address as received by socket
         const char* K_hex = K.AsHexStr();
-        LoginDatabase.PExecute("UPDATE account SET sessionkey = '%s', last_ip = '%s', last_login = NOW(), locale = '%u', failed_logins = 0 WHERE username = '%s'", K_hex, get_remote_address().c_str(), GetLocaleByName(_localizationName), _safelogin.c_str() );
+        LoginDatabase.PExecute("UPDATE account SET sessionkey = '%s', last_ip = '%s', last_login = NOW(), locale = '%u', failed_logins = 0, os = %u WHERE username = '%s'", K_hex, get_remote_address().c_str(), GetLocaleByName(_localizationName), _os, _safelogin.c_str() );
         OPENSSL_free((void*)K_hex);
 
         ///- Finish SRP6 and send the final result to the client
diff --git a/src/realmd/AuthSocket.h b/src/realmd/AuthSocket.h
--- a/src/realmd/AuthSocket.h
+++ b/src/realmd/AuthSocket.h
@@ -73,6 +73,7 @@ class AuthSocket: public BufferedSocket
         // between enUS and enGB, which is important for the patch system
         std::string _localizationName;
         uint16 _build;
+        uint32 _os;
         AccountTypes _accountSecurityLevel;
 
         ACE_HANDLE patch_;
diff --git a/src/shared/ByteBuffer.h b/src/shared/ByteBuffer.h
--- a/src/shared/ByteBuffer.h
+++ b/src/shared/ByteBuffer.h
@@ -320,6 +320,17 @@ class ByteBuffer
             return guid;
         }
 
+        template <class T>
+        void crypt(T& obj, uint8 *key, void(T::*func)(uint8 *useKey, uint8 *data, uint32 dataSize))
+        {
+            (obj.*(func))(key, &_storage[0], size());
+        }
+
+        void crypt(uint8 *key, void(*func)(uint8 *useKey, uint8 *data, uint32 dataSize))
+        {
+            (*func)(key, &_storage[0], size());
+        }
+
         const uint8 *contents() const { return &_storage[0]; }
 
         size_t size() const { return _storage.size(); }
diff --git a/src/shared/SystemConfig.h.in b/src/shared/SystemConfig.h.in
--- a/src/shared/SystemConfig.h.in
+++ b/src/shared/SystemConfig.h.in
@@ -36,11 +36,14 @@
 // Format is YYYYMMDDRR where RR is the change in the conf file
 // for that day.
 #ifndef _MANGOSDCONFVERSION
-# define _MANGOSDCONFVERSION 2010100901
+# define _MANGOSDCONFVERSION 2011031601
 #endif
 #ifndef _REALMDCONFVERSION
 # define _REALMDCONFVERSION 2010062001
 #endif
+#ifndef _WARDENDCONFVERSION
+# define _WARDENDCONFVERSION 2010111901
+#endif
 
 #if MANGOS_ENDIAN == MANGOS_BIGENDIAN
 # define _ENDIAN_STRING "big-endian"
@@ -71,6 +74,7 @@
 # endif
 # define _MANGOSD_CONFIG  SYSCONFDIR"mangosd.conf"
 # define _REALMD_CONFIG   SYSCONFDIR"realmd.conf"
+# define _WARDEND_CONFIG  SYSCONFDIR"wardend.conf"
 #else
 # if defined  (__FreeBSD__)
 #  define _ENDIAN_PLATFORM "FreeBSD_"ARCHITECTURE" (" _ENDIAN_STRING ")"
@@ -96,4 +100,5 @@
 #define DEFAULT_PLAYER_LIMIT 100
 #define DEFAULT_WORLDSERVER_PORT 8085                       //8129
 #define DEFAULT_REALMSERVER_PORT 3724
+#define DEFAULT_WARDENSERVER_PORT 4321
 #endif
diff --git a/src/shared/Util.cpp b/src/shared/Util.cpp
--- a/src/shared/Util.cpp
+++ b/src/shared/Util.cpp
@@ -547,4 +547,78 @@ void hexEncodeByteArray(uint8* bytes, uint32 arrayLen, std::string& result)
         }
     }
     result = ss.str();
-}
\ No newline at end of file
+}
+
+// Function that converts string hex values into binary ones, support spaces in the string
+void hexDecodeString(const char *str, uint32 strlen, uint8* buffer)
+{
+    int8 startedNibble = 0x0F;
+    uint32 bufferId = 0;
+    for (uint32 i = 0; i < strlen; ++i)
+    {
+        char c = tolower(str[i]);
+        uint8 value = 0;
+        if (c >='0' && c <= '9')
+            value = c-'0';
+        else if (c>='a' && c<='f')
+            value = c-'a'+0xa;
+        else
+            continue;
+        if (startedNibble == 0x0F)
+            startedNibble = value<<4;
+        else
+        {
+            buffer[bufferId] = startedNibble | value;
+            startedNibble = 0x0F;
+            bufferId++;
+        }
+    }
+}
+
+// Simple RC4 to work on 256+2 bytes keys
+void byteSwap(uint8 *a, uint8 *b)
+{
+    uint8 t;
+    t = *a;
+    *a = *b;
+    *b = t;
+}
+
+void rc4_init(uint8 *key_buffer, uint8 *base, uint32 base_length)
+{
+    uint8 val = 0;
+    uint32 position = 0;
+    uint32 i;
+
+    for(i = 0; i < 0x100; i++)
+        key_buffer[i] = (uint8)i;
+
+    key_buffer[0x100] = 0;
+    key_buffer[0x101] = 0;
+
+    for(i = 1; i <= 0x40; i++)
+    {
+        val += key_buffer[(i * 4) - 4] + base[position++ % base_length];
+        byteSwap(&key_buffer[(i * 4) - 4], &key_buffer[val & 0x0FF]);
+
+        val += key_buffer[(i * 4) - 3] + base[position++ % base_length];
+        byteSwap(&key_buffer[(i * 4) - 3], &key_buffer[val & 0x0FF]);
+
+        val += key_buffer[(i * 4) - 2] + base[position++ % base_length];
+        byteSwap(&key_buffer[(i * 4) - 2], &key_buffer[val & 0x0FF]);
+
+        val += key_buffer[(i * 4) - 1] + base[position++ % base_length];
+        byteSwap(&key_buffer[(i * 4) - 1], &key_buffer[val & 0x0FF]);
+    }
+}
+
+void rc4_crypt(uint8 *key, uint8 *data, uint32 length)
+{
+    for(uint32 i = 0; i < length; i++)
+    {
+        key[0x100]++;
+        key[0x101] += key[key[0x100]];
+        byteSwap(&key[key[0x101]], &key[key[0x100]]);
+        data[i] ^= key[(key[key[0x101]] + key[key[0x100]]) & 0x0FF];
+    }
+}
diff --git a/src/shared/Util.h b/src/shared/Util.h
--- a/src/shared/Util.h
+++ b/src/shared/Util.h
@@ -341,4 +341,11 @@ bool IsIPAddress(char const* ipaddress);
 uint32 CreatePIDFile(const std::string& filename);
 
 void hexEncodeByteArray(uint8* bytes, uint32 arrayLen, std::string& result);
+void hexDecodeString(const char *str, uint32 strlen, uint8* buffer);
+
+// Simple RC4 to work on 256+2 bytes keys
+void byteSwap(uint8 *a, uint8 *b);
+void rc4_init(uint8 *key_buffer, uint8 *base, uint32 base_length);
+void rc4_crypt(uint8 *key, uint8 *data, uint32 length);
+
 #endif
diff --git a/src/wardend/BufferedSocket.cpp b/src/wardend/BufferedSocket.cpp
new file mode 100644
--- /dev/null
+++ b/src/wardend/BufferedSocket.cpp
@@ -0,0 +1,285 @@
+/*
+ * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/** \file
+  \ingroup wardend
+  */
+
+#include "BufferedSocket.h"
+
+#include <ace/OS_NS_string.h>
+#include <ace/INET_Addr.h>
+#include <ace/SString.h>
+
+#ifndef MSG_NOSIGNAL
+#define MSG_NOSIGNAL 0
+#endif
+
+BufferedSocket::BufferedSocket(void):
+    input_buffer_(32768),
+    remote_address_("<unknown>")
+{
+}
+
+/*virtual*/ BufferedSocket::~BufferedSocket(void)
+{
+}
+
+/*virtual*/ int BufferedSocket::open(void * arg)
+{
+    if(Base::open(arg) == -1)
+        return -1;
+
+    ACE_Time_Value interval(TIMEOUT_SECS);
+    Base::reactor_timer_interface()->schedule_timer(this, NULL, interval);
+
+    ACE_INET_Addr addr;
+
+    if(peer().get_remote_addr(addr) == -1)
+        return -1;
+
+    char address[1024];
+
+    addr.get_host_addr(address, 1024);
+
+    this->remote_address_ = address;
+
+    this->OnAccept();
+
+    return 0;
+}
+
+const std::string& BufferedSocket::get_remote_address(void) const
+{
+    return this->remote_address_;
+}
+
+size_t BufferedSocket::recv_len(void) const
+{
+    return this->input_buffer_.length();
+}
+
+bool BufferedSocket::recv_soft(char *buf, size_t len)
+{
+    if(this->input_buffer_.length() < len)
+        return false;
+
+    ACE_OS::memcpy(buf, this->input_buffer_.rd_ptr(), len);
+
+    return true;
+}
+
+bool BufferedSocket::recv(char *buf, size_t len)
+{
+    bool ret = this->recv_soft(buf, len);
+
+    if(ret)
+        this->recv_skip(len);
+
+    return ret;
+}
+
+void BufferedSocket::recv_skip(size_t len)
+{
+    this->input_buffer_.rd_ptr(len);
+}
+
+ssize_t BufferedSocket::noblk_send(ACE_Message_Block &message_block)
+{
+    const size_t len = message_block.length();
+
+    if(len == 0)
+        return -1;
+
+    // Try to send the message directly.
+    ssize_t n = this->peer().send(message_block.rd_ptr(), len, MSG_NOSIGNAL);
+
+    if(n < 0)
+    {
+        if(errno == EWOULDBLOCK)
+            // Blocking signal
+            return 0;
+        else
+            // Error
+            return -1;
+    }
+    else if(n == 0)
+    {
+        // Can this happen ?
+        return -1;
+    }
+
+    // return bytes transmitted
+    return n;
+}
+
+bool BufferedSocket::send(const char *buf, size_t len)
+{
+    if(buf == NULL || len == 0)
+        return true;
+
+    ACE_Data_Block db(
+            len,
+            ACE_Message_Block::MB_DATA,
+            (const char*)buf,
+            0,
+            0,
+            ACE_Message_Block::DONT_DELETE,
+            0);
+
+    ACE_Message_Block message_block(
+            &db,
+            ACE_Message_Block::DONT_DELETE,
+            0);
+
+    message_block.wr_ptr(len);
+
+    if(this->msg_queue()->is_empty())
+    {
+        // Try to send it directly.
+        ssize_t n = this->noblk_send(message_block);
+
+        if(n < 0)
+            return false;
+        else if(n == len)
+            return true;
+
+        // adjust how much bytes we sent
+        message_block.rd_ptr((size_t)n);
+
+        // fall down
+    }
+
+    // enqueue the message, note: clone is needed cause we cant enqueue stuff on the stack
+    ACE_Message_Block *mb = message_block.clone();
+
+    if(this->msg_queue()->enqueue_tail(mb, (ACE_Time_Value *) &ACE_Time_Value::zero) == -1)
+    {
+        mb->release();
+        return false;
+    }
+
+    // tell reactor to call handle_output() when we can send more data
+    if(this->reactor()->schedule_wakeup(this, ACE_Event_Handler::WRITE_MASK) == -1)
+        return false;
+
+    return true;
+}
+
+/*virtual*/ int BufferedSocket::handle_output(ACE_HANDLE /*= ACE_INVALID_HANDLE*/)
+{
+    ACE_Message_Block *mb = 0;
+
+    if(this->msg_queue()->is_empty())
+    {
+        // if no more data to send, then cancel notification
+        this->reactor()->cancel_wakeup(this, ACE_Event_Handler::WRITE_MASK);
+        return 0;
+    }
+
+    if(this->msg_queue()->dequeue_head(mb, (ACE_Time_Value *) &ACE_Time_Value::zero) == -1)
+        return -1;
+
+    ssize_t n = this->noblk_send(*mb);
+
+    if(n < 0)
+    {
+        mb->release();
+        return -1;
+    }
+    else if(n == mb->length())
+    {
+        mb->release();
+        return 1;
+    }
+    else
+    {
+        mb->rd_ptr(n);
+
+        if(this->msg_queue()->enqueue_head(mb, (ACE_Time_Value *) &ACE_Time_Value::zero) == -1)
+        {
+            mb->release();
+            return -1;
+        }
+
+        return 0;
+    }
+
+    ACE_NOTREACHED(return -1);
+}
+
+/*virtual*/ int BufferedSocket::handle_input(ACE_HANDLE /*= ACE_INVALID_HANDLE*/)
+{
+    const ssize_t space = this->input_buffer_.space();
+
+    ssize_t n = this->peer().recv(this->input_buffer_.wr_ptr(), space);
+
+    if(n < 0)
+    {
+        // blocking signal or error
+        return errno == EWOULDBLOCK ? 0 : -1;
+    }
+    else if(n == 0)
+    {
+        // EOF
+        return -1;
+    }
+
+    this->input_buffer_.wr_ptr((size_t)n);
+
+    this->OnRead();
+
+    // reset the timer
+    Base::reactor_timer_interface()->cancel_timer(this);
+    ACE_Time_Value interval(TIMEOUT_SECS);
+    Base::reactor_timer_interface()->schedule_timer(this, NULL, interval);
+
+    // move data in the buffer to the beginning of the buffer
+    this->input_buffer_.crunch();
+
+    // return 1 in case there might be more data to read from OS
+    return n == space ? 1 : 0;
+}
+
+/*virtual*/ int BufferedSocket::handle_close(ACE_HANDLE h, ACE_Reactor_Mask m)
+{
+    this->OnClose();
+
+    Base::handle_close();
+
+    return 0;
+}
+
+/*virtual*/ int BufferedSocket::handle_timeout(const ACE_Time_Value &current_time, const void *act)
+{
+    this->close_connection();
+
+    this->OnClose();
+
+    Base::handle_close();
+
+    return 0;
+}
+
+void BufferedSocket::close_connection(void)
+{
+    this->peer().close_reader();
+    this->peer().close_writer();
+
+    reactor()->remove_handler(this, ACE_Event_Handler::DONT_CALL | ACE_Event_Handler::ALL_EVENTS_MASK);
+}
diff --git a/src/wardend/BufferedSocket.h b/src/wardend/BufferedSocket.h
new file mode 100644
--- /dev/null
+++ b/src/wardend/BufferedSocket.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/** \file
+  \ingroup wardend
+  */
+
+#ifndef _BUFFEREDSOCKET_H_
+#define _BUFFEREDSOCKET_H_
+
+#include <ace/Basic_Types.h>
+#include <ace/Synch_Traits.h>
+#include <ace/Svc_Handler.h>
+#include <ace/SOCK_Stream.h>
+#include <ace/Message_Block.h>
+#include <ace/Basic_Types.h>
+
+#include <string>
+
+#define TIMEOUT_SECS 15
+
+class BufferedSocket: public ACE_Svc_Handler<ACE_SOCK_STREAM, ACE_NULL_SYNCH>
+{
+    protected:
+        typedef ACE_Svc_Handler<ACE_SOCK_STREAM, ACE_NULL_SYNCH> Base;
+
+        virtual void OnRead(void) { }
+        virtual void OnAccept(void) { }
+        virtual void OnClose(void) { }
+
+    public:
+        BufferedSocket(void);
+        virtual ~BufferedSocket(void);
+
+        size_t recv_len(void) const;
+        bool recv_soft(char *buf, size_t len);
+        bool recv(char *buf, size_t len);
+        void recv_skip(size_t len);
+
+        bool send(const char *buf, size_t len);
+
+        const std::string& get_remote_address(void) const;
+
+        virtual int open(void *);
+
+        void close_connection(void);
+
+        virtual int handle_input(ACE_HANDLE = ACE_INVALID_HANDLE);
+        virtual int handle_output(ACE_HANDLE = ACE_INVALID_HANDLE);
+
+        virtual int handle_close(ACE_HANDLE = ACE_INVALID_HANDLE,
+                ACE_Reactor_Mask = ACE_Event_Handler::ALL_EVENTS_MASK);
+        virtual int handle_timeout(const ACE_Time_Value &current_time,
+                const void *act = 0);
+
+    private:
+        ssize_t noblk_send(ACE_Message_Block &message_block);
+
+    private:
+        ACE_Message_Block input_buffer_;
+
+    protected:
+        std::string remote_address_;
+
+};
+
+#endif /* _BUFFEREDSOCKET_H_ */
diff --git a/src/wardend/Main.cpp b/src/wardend/Main.cpp
new file mode 100644
--- /dev/null
+++ b/src/wardend/Main.cpp
@@ -0,0 +1,287 @@
+/*
+ * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "WardenDaemon.h"
+
+#include "Config/Config.h"
+#include "Log.h"
+#include "WardenSocket.h"
+#include "SystemConfig.h"
+#include "revision.h"
+#include "revision_nr.h"
+#include "Util.h"
+
+#include <ace/Get_Opt.h>
+#include <ace/Dev_Poll_Reactor.h>
+#include <ace/TP_Reactor.h>
+#include <ace/ACE.h>
+#include <ace/Acceptor.h>
+#include <ace/SOCK_Acceptor.h>
+
+#include "ServiceWin32.h"
+char serviceName[] = "wardend";
+char serviceLongName[] = "MaNGOS wardend service";
+char serviceDescription[] = "Massive Network Game Object Server";
+/*
+ * -1 - not in service mode
+ *  0 - stopped
+ *  1 - running
+ *  2 - paused
+ */
+int m_ServiceStatus = -1;
+
+void UnhookSignals();
+void HookSignals();
+
+bool stopEvent = false;                                     ///< Setting it to true stops the daemon
+
+/// Print out the usage string for this program on the console.
+void usage(const char *prog)
+{
+    sLog.outString("Usage: \n %s [<options>]\n"
+        "    -v, --version            print version and exist\n\r"
+        "    -c config_file           use config_file as configuration file\n\r"
+        "    Running as service functions:\n\r"
+        "    -s run                   run as service\n\r"
+        "    -s install               install service\n\r"
+        "    -s uninstall             uninstall service\n\r"
+        ,prog);
+}
+
+/// Launch the warden server
+extern int main(int argc, char **argv)
+{
+    ///- Command line parsing to get the configuration file name
+    char const* cfg_file = _WARDEND_CONFIG;
+
+    char const *options = ":c:s:";
+
+    ACE_Get_Opt cmd_opts(argc, argv, options);
+    cmd_opts.long_option("version", 'v');
+
+    int option;
+    while ((option = cmd_opts()) != EOF)
+    {
+        switch (option)
+        {
+            case 'c':
+                cfg_file = cmd_opts.opt_arg();
+                break;
+            case 'v':
+                printf("%s\n", _FULLVERSION(REVISION_DATE,REVISION_TIME,REVISION_NR,REVISION_ID));
+                return 0;
+            case 's':
+            {
+                const char *mode = cmd_opts.opt_arg();
+
+                if (!strcmp(mode, "install"))
+                {
+                    if (WinServiceInstall())
+                        sLog.outString("Installing service");
+                    return 1;
+                }
+                else if (!strcmp(mode, "uninstall"))
+                {
+                    if (WinServiceUninstall())
+                        sLog.outString("Uninstalling service");
+                    return 1;
+                }
+                else if (!strcmp(mode, "run"))
+                    WinServiceRun();
+                else
+                {
+                    sLog.outError("Runtime-Error: -%c unsupported argument %s", cmd_opts.opt_opt(), mode);
+                    usage(argv[0]);
+                    Log::WaitBeforeContinueIfNeed();
+                    return 1;
+                }
+                break;
+            }
+            case ':':
+                sLog.outError("Runtime-Error: -%c option requires an input argument", cmd_opts.opt_opt());
+                usage(argv[0]);
+                Log::WaitBeforeContinueIfNeed();
+                return 1;
+            default:
+                sLog.outError("Runtime-Error: bad format of commandline arguments");
+                usage(argv[0]);
+                Log::WaitBeforeContinueIfNeed();
+                return 1;
+        }
+    }
+
+    if (!sConfig.SetSource(cfg_file))
+    {
+        sLog.outError("Could not find configuration file %s.", cfg_file);
+        Log::WaitBeforeContinueIfNeed();
+        return 1;
+    }
+    sLog.Initialize();
+
+    sLog.outString( "%s [warden-daemon]", _FULLVERSION(REVISION_DATE,REVISION_TIME,REVISION_NR,REVISION_ID) );
+    sLog.outString( "<Ctrl-C> to stop.\n" );
+    sLog.outString("Using configuration file %s.", cfg_file);
+
+    ///- Check the version of the configuration file
+    uint32 confVersion = sConfig.GetIntDefault("ConfVersion", 0);
+    if (confVersion < _WARDENDCONFVERSION)
+    {
+        sLog.outError("*****************************************************************************");
+        sLog.outError(" WARNING: Your wardend.conf version indicates your conf file is out of date!");
+        sLog.outError("          Please check for updates, as your current default values may cause");
+        sLog.outError("          strange behavior.");
+        sLog.outError("*****************************************************************************");
+        Log::WaitBeforeContinueIfNeed();
+    }
+
+    DETAIL_LOG("Using ACE: %s", ACE_VERSION);
+
+    ACE_Reactor::instance(new ACE_Reactor(new ACE_TP_Reactor(), true), true);
+
+    sLog.outBasic("Max allowed open files is %d", ACE::max_handles());
+
+    /// wardend PID file creation
+    std::string pidfile = sConfig.GetStringDefault("PidFile", "");
+    if (!pidfile.empty())
+    {
+        uint32 pid = CreatePIDFile(pidfile);
+        if( !pid )
+        {
+            sLog.outError( "Cannot create PID file %s.\n", pidfile.c_str() );
+            Log::WaitBeforeContinueIfNeed();
+            return 1;
+        }
+
+        sLog.outString( "Daemon PID: %u\n", pid );
+    }
+
+    ///- Launch the listening network socket
+    ACE_Acceptor<WardenSocket, ACE_SOCK_Acceptor> acceptor;
+
+    uint16 rmport = sConfig.GetIntDefault("WardenServerPort", DEFAULT_WARDENSERVER_PORT);
+    std::string bind_ip = sConfig.GetStringDefault("BindIP", "0.0.0.0");
+
+    ACE_INET_Addr bind_addr(rmport, bind_ip.c_str());
+
+    if (acceptor.open(bind_addr, ACE_Reactor::instance(), ACE_NONBLOCK) == -1)
+    {
+        sLog.outError("MaNGOS wardend can not bind to %s:%d", bind_ip.c_str(), rmport);
+        Log::WaitBeforeContinueIfNeed();
+        return 1;
+    }
+
+    ///- Catch termination signals
+    HookSignals();
+
+    ///- Handle affinity for multiple processors and process priority on Windows
+    HANDLE hProcess = GetCurrentProcess();
+
+    uint32 Aff = sConfig.GetIntDefault("UseProcessors", 0);
+    if (Aff > 0)
+    {
+        DWORD appAff;
+        DWORD sysAff;
+
+        if(GetProcessAffinityMask(hProcess,&appAff,&sysAff))
+        {
+            DWORD curAff = Aff & appAff;                // remove non accessible processors
+
+            if (!curAff)
+            {
+                sLog.outError("Processors marked in UseProcessors bitmask (hex) %x not accessible for wardend. Accessible processors bitmask (hex): %x",Aff,appAff);
+            }
+            else
+            {
+                if (SetProcessAffinityMask(hProcess,curAff))
+                    sLog.outString("Using processors (bitmask, hex): %x", curAff);
+                else
+                    sLog.outError("Can't set used processors (hex): %x", curAff);
+            }
+        }
+        sLog.outString();
+    }
+
+    bool Prio = sConfig.GetBoolDefault("ProcessPriority", false);
+
+    if(Prio)
+    {
+        if(SetPriorityClass(hProcess,HIGH_PRIORITY_CLASS))
+            sLog.outString("wardend process priority class set to HIGH");
+        else
+            sLog.outError("ERROR: Can't set wardend process priority class.");
+        sLog.outString();
+    }
+
+    sWardend.Initialize();
+
+    ///- Wait for termination signal
+    while (!stopEvent)
+    {
+        // dont move this outside the loop, the reactor will modify it
+        ACE_Time_Value interval(0, 100000);
+
+        if (ACE_Reactor::instance()->run_reactor_event_loop(interval) == -1)
+            break;
+
+        if (m_ServiceStatus == 0) stopEvent = true;
+        while (m_ServiceStatus == 2) Sleep(1000);
+    }
+
+    ///- Remove signal handling before leaving
+    UnhookSignals();
+
+    sLog.outString( "Halting process..." );
+
+    // Cleaning up objects in memory
+    ACE_Reactor::instance()->close_singleton();
+    return 0;
+}
+
+/// Handle termination signals
+/** Put the global variable stopEvent to 'true' if a termination signal is caught **/
+void OnSignal(int s)
+{
+    switch (s)
+    {
+        case SIGINT:
+        case SIGTERM:
+            stopEvent = true;
+            break;
+        case SIGBREAK:
+            stopEvent = true;
+            break;
+    }
+    signal(s, OnSignal);
+}
+
+/// Define hook 'OnSignal' for all termination signals
+void HookSignals()
+{
+    signal(SIGINT, OnSignal);
+    signal(SIGTERM, OnSignal);
+    signal(SIGBREAK, OnSignal);
+}
+
+/// Unhook the signals before leaving
+void UnhookSignals()
+{
+    signal(SIGINT, 0);
+    signal(SIGTERM, 0);
+    signal(SIGBREAK, 0);
+}
diff --git a/src/wardend/WardenDaemon.cpp b/src/wardend/WardenDaemon.cpp
new file mode 100644
--- /dev/null
+++ b/src/wardend/WardenDaemon.cpp
@@ -0,0 +1,406 @@
+/*
+ * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "WardenDaemon.h"
+#include "zlib/zlib.h"
+#include "Policies/SingletonImp.h"
+#include "ByteBuffer.h"
+
+// === Warden Daemon internal module management ===
+
+INSTANTIATE_SINGLETON_1(Wardend);
+
+void CWardenLoader::UnloadWarden()
+{
+    if (pdwModule)
+    {
+        CLibraryEntry* pLibraryList = GetAddress<CLibraryEntry*>(GetHeader()->dwLibraryTable);
+        while (dwLibraryCount)
+        {
+            dwLibraryCount--;
+            DEBUG_LOG("Unloading lib %s...", GetAddress<const char*>(pLibraryList[dwLibraryCount].dwFileName));
+            FreeLibrary(GetModuleHandleA(GetAddress<const char*>(pLibraryList[dwLibraryCount].dwFileName)));
+        }
+        VirtualFree(pdwModule, /*dwModuleSize*/ 0, MEM_RELEASE); // No size when VirtualFree with MEM_RELEASE!!
+
+        pdwModule = 0;
+        dwModuleSize = 0;
+    }
+}
+
+bool CWardenLoader::LoadWarden(PDWORD pdwNewModule, DWORD dwSize)
+{
+    bool bUnload = true;
+
+    dwModuleSize = GetHeader(pdwNewModule)->dwModuleSize;
+    if (dwModuleSize < 0x80000000)
+    {
+        pdwModule = reinterpret_cast<PDWORD>(VirtualAlloc(0, dwModuleSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE));
+        if (pdwModule)
+        {
+            // Writing code begin
+            memcpy(pdwModule, pdwNewModule, sizeof(CHeader));
+
+            PDWORD pdwChunk = &pdwNewModule[(sizeof(CHeader) / sizeof(DWORD)) + GetHeader()->dwChunkCount * 3];
+            DWORD dwChunkDest = GetAddress<DWORD>(pdwNewModule[sizeof(CHeader) / sizeof(DWORD)]);
+            DWORD dwModuleEnd = GetAddress<DWORD>(dwModuleSize);
+            bool bCopyChunk = true;
+
+            while (dwChunkDest < dwModuleEnd)
+            {
+                DWORD dwCurrentChunkSize = ((WORD*)pdwChunk)[0];
+                pdwChunk = (PDWORD)((DWORD)pdwChunk + (DWORD)2);
+
+                if (bCopyChunk)
+                {
+                    memcpy((void*)dwChunkDest, pdwChunk, dwCurrentChunkSize);
+                    pdwChunk = (PDWORD)((DWORD)pdwChunk + dwCurrentChunkSize);
+                }
+
+                dwChunkDest  += dwCurrentChunkSize;
+                bCopyChunk = !bCopyChunk;
+            }
+            // Writing code end
+            // Relocations begin
+            PBYTE pbRelocationTable = GetAddress<PBYTE>(GetHeader()->dwSizeOfCode);
+            DWORD dwRelocationIndex = 0, dwLastRelocation = 0;
+
+            while (dwRelocationIndex < GetHeader()->dwRelocationCount)
+            {
+                DWORD dwValue = pbRelocationTable[0];
+                if (dwValue < 0)
+                {
+                    dwValue = (dwValue & 0x7F) << 8;
+                    dwValue = (dwValue + pbRelocationTable[1]) << 8;
+                    dwValue = (dwValue + pbRelocationTable[2]) << 8;
+                    dwValue += pbRelocationTable[3];
+
+                    pbRelocationTable = (PBYTE)((DWORD)pbRelocationTable + 4);
+                    *GetAddress<DWORD*>(dwValue) += reinterpret_cast<DWORD>(pdwModule);
+                }
+                else
+                {
+                    dwValue = (dwValue << 8) + dwLastRelocation + pbRelocationTable[1];
+
+                    pbRelocationTable = (PBYTE)((DWORD)pbRelocationTable + 2);
+                    *GetAddress<DWORD*>(dwValue) += reinterpret_cast<DWORD>(pdwModule);
+                }
+
+                dwRelocationIndex++;
+                dwLastRelocation = dwValue;
+            }
+            // Relocations end
+            // Imports begin
+            CLibraryEntry * pLibraryTable = GetAddress<CLibraryEntry*>(GetHeader()->dwLibraryTable);
+            dwLibraryCount = 0;
+            DWORD dwLibraryIndex = 0;
+            while (dwLibraryIndex < GetHeader()->dwLibraryCount)
+            {
+                DEBUG_LOG("Loading lib %s...", GetAddress<const char*>(pLibraryTable[dwLibraryIndex].dwFileName));
+                HMODULE hModule = LoadLibraryA(GetAddress<const char*>(pLibraryTable[dwLibraryIndex].dwFileName));
+                if (hModule)
+                {
+                    PDWORD pdwImports = GetAddress<PDWORD>(pLibraryTable[dwLibraryIndex].dwImports), dwLastImport = 0;
+                    while (*pdwImports)
+                    {
+                        DWORD & dwCurrent = *pdwImports;
+
+                        if( dwCurrent <= 0 )
+                            dwCurrent = reinterpret_cast<DWORD>(GetProcAddress(hModule, (char*)(dwCurrent & 0x7FFFFFFF)));
+                        else
+                            dwCurrent = reinterpret_cast<DWORD>(GetProcAddress(hModule, GetAddress<const char*>(dwCurrent)));
+
+                        pdwImports++;
+                    }
+                }
+                dwLibraryIndex++;
+                dwLibraryCount++;
+            }
+            // Imports end
+            // Chunk protection flags begin
+            DWORD dwIndex = 0;
+            while (dwIndex < GetHeader()->dwChunkCount)
+            {
+                PDWORD pdwChunk = &pdwModule[10 + dwIndex * 3];
+
+                DWORD dwOldProtect = 0;
+                VirtualProtect(GetAddress<void*>(pdwChunk[0]), pdwChunk[1], pdwChunk[2], &dwOldProtect);
+
+                if( pdwChunk[2] & 0xF0) // execute flag
+                    FlushInstructionCache(GetCurrentProcess(), GetAddress<void*>(pdwChunk[0]), pdwChunk[1]);
+
+                dwIndex++;
+            }
+            // Chunk protection flags end
+            // Code size check begin
+            if (GetHeader()->dwSizeOfCode < dwModuleSize)
+            {
+                DWORD dwOffset = ((GetHeader()->dwSizeOfCode + 0xFFF) & 0xFFFFF000);
+                if (dwOffset >= GetHeader()->dwSizeOfCode && dwOffset > dwModuleSize)
+                    VirtualFree(GetAddress<void*>(dwOffset), dwModuleSize - dwOffset, MEM_DECOMMIT);
+
+                bUnload = false;
+            }
+            // Code size check end
+            if (bUnload)
+                UnloadWarden();
+        }
+        else
+            return false;
+    }
+    else
+        return false;
+
+    return true;
+}
+
+// === Module callback functions ===
+
+void __stdcall cSendPacket(LPVOID pPacket, DWORD dwSize)
+{
+    DEBUG_LOG("Callback cSendPacket called. Packet at 0x%08X size %u.", (PDWORD)pPacket, dwSize);
+}
+
+BOOL __stdcall cCheckModule(BYTE* pModName, DWORD _2)
+{
+    DEBUG_LOG("Callback cCheckModule called.");
+    return 0;
+}
+
+WardenFuncList** __stdcall cLoadModule(BYTE* pRC4Key, BYTE* pModule, DWORD dwModSize)
+{
+    DEBUG_LOG("Callback cLoadModule called.");
+    return 0;
+}
+
+LPVOID __stdcall cAllocateMemory(DWORD dwSize)
+{
+    LPVOID res = (LPVOID)malloc(dwSize);
+    DEBUG_LOG("Callback cAllocateMemory called. Allocated %u bytes at 0x%08X", dwSize, res);
+    return res;
+}
+
+VOID __stdcall cReleaseMemory(LPVOID lpMemory)
+{
+    DEBUG_LOG("Callback cReleaseMemory called. Memory at 0x%08X", lpMemory);
+    free(lpMemory);
+}
+
+VOID __stdcall cSetRC4Data(LPVOID lpKeys, DWORD dwSize)
+{
+    DEBUG_LOG("Callback cSetRC4Data called. Keys at 0x%08X, key size 0x%04X (%u).", lpKeys, dwSize, dwSize);
+}
+
+DWORD __stdcall cGetRC4Data(LPVOID lpBuffer, LPDWORD dwSize)
+{
+    DEBUG_LOG("Callback cGetRC4Data called. Buffer at 0x%08X, key size 0x%04X (%u).", (PDWORD)lpBuffer, *(DWORD*)dwSize, *(DWORD*)dwSize);
+    memset(lpBuffer, 0, *(DWORD*)dwSize);
+    return 1;
+}
+
+WardenFuncList **CWardenLoader::InitializeWarden(InstanceS *instance)
+{
+    DWORD A, B, C, D;
+
+    DEBUG_LOG("Warden module mapped to: 0x%08X", pdwModule);
+
+    C = GetHeader()->dwProcedureAdjust;
+    B = 1 - C;
+
+    if (B > GetHeader()->dwProcedureCount)
+        return FALSE;
+
+    A = GetHeader()->dwProcedureTable; // offsetWardenSetup
+    D = *(DWORD*)&pdwModule[A / 4 + B * 4];
+    A = D + (DWORD)pdwModule;
+
+    fnInitializeModule fpInitializeModule;
+    fpInitializeModule = (fnInitializeModule)A;
+    DEBUG_LOG("Initialize Function mapped to: 0x%08X (0x%04X)", (PDWORD)A ,PDWORD((PDWORD)A - pdwModule));
+
+    // initialize callbacks
+    memset(&instance->dwTable, 0, sizeof(FuncList));
+    instance->dwTable.fpSendPacket        = cSendPacket;
+    instance->dwTable.fpCheckModule       = cCheckModule;
+    instance->dwTable.fpLoadModule        = cLoadModule;
+    instance->dwTable.fpAllocateMemory    = cAllocateMemory;
+    instance->dwTable.fpReleaseMemory     = cReleaseMemory;
+    instance->dwTable.fpSetRC4Data        = cSetRC4Data;
+    instance->dwTable.fpGetRC4Data        = cGetRC4Data;
+    instance->tableptr = &instance->dwTable;
+
+    char * szCallbacksDesc[] = {
+        "SendPacket",
+        "CheckModule",
+        "LoadModule",
+        "AllocateMemory",
+        "ReleaseMemory",
+        "SetRC4Data",
+        "GetRC4Data"
+    };
+
+    DEBUG_LOG("Warden callbacks:");
+    for (int i = 0; i < 7; ++i)
+        DEBUG_LOG("Callback: %s at: 0x%08X" ,szCallbacksDesc[i], ((PDWORD*)&instance->dwTable)[i]);
+
+    // warden functions pointers
+    DEBUG_LOG("Calling Warden::Initialize");
+    WardenFuncList **list = fpInitializeModule((DWORD*)&instance->tableptr);
+
+    char * szInitReturnDesc[] = {
+        "GenerateRC4Keys",
+        "UnloadModule",
+        "PacketHandler",
+        "Tick"
+    };
+
+    DEBUG_LOG("Warden::Initialize returns:");
+    for (int i = 0; i < 4; ++i)
+        DEBUG_LOG("Init: Warden::%s at: 0x%08X",szInitReturnDesc[i] ,((PDWORD*)*list)[i]);
+
+    return list;
+}
+
+void CWardenLoader::PrintHeader( PDWORD pdwHeader )
+{
+    char * szHeaderDescription[] = {
+        "Module size",
+        "Destructor",
+        "SizeOfCode",
+        "RelocationCount",
+        "ProcedureTable",
+        "ProcedureCount",
+        "ProcedureAdjust",
+        "LibraryTable",
+        "LibraryCount",
+        "ChunkCount"
+    };
+
+    for (int i = 0; i < 10; i++)
+    {
+        DEBUG_LOG( "%u .+ 0x%02X %s -> %u", i ,i * 4, szHeaderDescription[i], pdwHeader[i]);
+    }
+}
+
+// === Module maped functions ===
+
+void GenerateRC4Keys(LPVOID lpData, DWORD dwSize, InstanceS *instance)
+{
+    DEBUG_LOG("Warden::GenerateRC4Keys called");
+    ((fnGenerateRC4Keys)instance->pointers.f1)(instance->list, lpData, dwSize);
+}
+
+void UnloadModule(InstanceS *instance)
+{
+    DEBUG_LOG("Warden::UnloadModule called");
+    ((fnUnloadModule)instance->pointers.f2)(instance->list);
+}
+
+void PacketHandler(BYTE *pPacket, DWORD dwSize, DWORD *dwBuffer, InstanceS *instance)
+{
+    DEBUG_LOG("Warden::PacketHandler called");
+    ((fnPacketHandler)instance->pointers.f3)(instance->list, pPacket, dwSize, dwBuffer);
+    DEBUG_LOG("Warden::PacketHandler handeled %u bytes of the packet", *dwBuffer);
+}
+
+void Tick(DWORD _2, InstanceS *instance)
+{
+    DEBUG_LOG("Warden::Tick called");
+    ((fnTick)instance->pointers.f4)(instance->list, _2);
+}
+
+void Wardend::Initialize()
+{
+    sLog.outString("Warden system initialized." );
+}
+
+Wardend::Wardend()
+{
+}
+
+bool Wardend::LoadModuleAndExecute(uint32 accountId, uint32 modLen, uint8 *module, uint8 *sessionKey, uint8 *packet, ByteBuffer *returnPacket)
+{
+    DEBUG_LOG("Wardend::LoadModuleAndExecute()");
+
+    uint32 m_signature = *(uint32*)(module + modLen - 4); // - sizeof(uint32)
+    if (m_signature != 0x5349474E) // NGIS->SIGN string
+    {
+        sLog.outError("Warden module seams damaged, cannot find signature data.");
+        return false;
+    }
+    // Now inflate the module after removing uint32 size at the beginning and last 4 "SIGN"
+    uint32 m_InflateSize = *(uint32*)module;
+    uint8* moduleCode = (uint8*)malloc(m_InflateSize);
+    uint32 currentSize = modLen - 4 - 4; // - sizeof(uint32) for inflateSize and - sizeof(uint32) for signature
+    uLongf finalSize = m_InflateSize;
+    if (uncompress(moduleCode, &finalSize, module+4, currentSize) != Z_OK)
+    {
+        sLog.outError("Warden module could not be inflated.");
+        free(moduleCode);
+        return false;
+    }
+
+    InstanceS instance;
+    instance.loader = new CWardenLoader();
+
+    instance.loader->PrintHeader((PDWORD)moduleCode);
+    instance.loader->LoadWarden((PDWORD)moduleCode, finalSize);
+    instance.list = instance.loader->InitializeWarden(&instance);
+
+    instance.pointers.f1 = &*(*instance.list)->fpGenerateRC4Keys;
+    instance.pointers.f2 = &*(*instance.list)->fpUnload;
+    instance.pointers.f3 = &*(*instance.list)->fpPacketHandler;
+    instance.pointers.f4 = &*(*instance.list)->fpTick;
+
+    uint8 *keyAddr = GenerateNewKeys(&instance, sessionKey, packet);
+
+    *returnPacket << uint8(WMSG_WARDEN_KEYS);
+    *returnPacket << uint32(accountId);
+    returnPacket->append(((KeyPair*)keyAddr)->server, 0x102);
+    returnPacket->append(((KeyPair*)keyAddr)->client, 0x102);
+    returnPacket->append(&((WardenInitData*)(instance.list))->seed[0], 16);
+
+    // Unload the module
+    UnloadModule(&instance);
+    instance.loader->UnloadWarden();
+    delete instance.loader;
+    free(moduleCode);
+    return true;
+}
+
+uint8 *Wardend::GenerateNewKeys(InstanceS *instance, uint8 *sessionKey/*[40]*/, uint8 *packet/*[17]*/)
+{
+    DEBUG_LOG("Wardend::GenerateNewKeys()");
+    // Call the module function to generate the key
+    GenerateRC4Keys(sessionKey, 40, instance);
+    // Then ask it to handle the packet we also sent to the client
+    DWORD handled;
+    PacketHandler(packet, 17, &handled, instance);
+    return &((WardenInitData*)(instance->list))->keys[0];
+}
+
+/////////////////////////////
+// Singleton access function
+/////////////////////////////
+
+Wardend& sWardend
+{
+    static Wardend wardendaemon;
+    return wardendaemon;
+}
diff --git a/src/wardend/WardenDaemon.h b/src/wardend/WardenDaemon.h
new file mode 100644
--- /dev/null
+++ b/src/wardend/WardenDaemon.h
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __WARDEND_H
+#define __WARDEND_H
+
+#include "Common.h"
+#include "WardendProtocol.h"
+
+#define WARDEN_MAX_MODULES  20
+
+class ByteBuffer;
+
+typedef struct _WardenFuncList WardenFuncList;
+struct InstanceS;
+
+//Input
+typedef VOID (__stdcall *fnSendPacket)(BYTE* pPacket, DWORD dwSize);
+typedef BOOL (__stdcall *fnCheckModule)(BYTE* pModName, DWORD _2);
+typedef WardenFuncList** (__stdcall *fnLoadModule)(BYTE* pRC4Key, BYTE* pModule, DWORD dwModSize);
+typedef LPVOID (__stdcall *fnAllocateMemory)(DWORD dwSize);
+typedef VOID (__stdcall *fnReleaseMemory)(LPVOID lpMemory);
+typedef VOID (__stdcall *fnSetRC4Data)(LPVOID lpKeys, DWORD dwSize);
+typedef DWORD (__stdcall *fnGetRC4Data)(LPVOID lpBuffer, LPDWORD dwSize);
+typedef struct _FuncList
+{
+    void *fpSendPacket;     //0x00
+    void *fpCheckModule;    //0x04
+    void *fpLoadModule;     //0x08
+    void *fpAllocateMemory; //0x0C
+    void *fpReleaseMemory;  //0x10
+    void *fpSetRC4Data;     //0x14
+    void *fpGetRC4Data;     //0x18
+} FuncList;
+
+//output
+typedef VOID (__thiscall *fnGenerateRC4Keys)(WardenFuncList** ppFncList, LPVOID lpData, DWORD dwSize);
+typedef VOID (__thiscall *fnUnloadModule)(WardenFuncList** ppFncList);
+typedef VOID (__thiscall *fnPacketHandler)(WardenFuncList** ppFncList, BYTE* pPacket, DWORD dwSize, DWORD* dwBuffer);
+typedef VOID (__thiscall *fnTick)(WardenFuncList** ppFncList, DWORD _2); // _2 is sum dwOldTick - GetTickCount(); shit ..
+typedef struct _WardenFuncList
+{
+    fnGenerateRC4Keys * fpGenerateRC4Keys;  //0x00
+    fnUnloadModule * fpUnload;              //0x04 - Before it frees everything it will call FuncList:fpSetRC4Data and store the RC4 key
+    fnPacketHandler * fpPacketHandler;      //0x08
+    fnTick * fpTick;                        //0x0C
+} WardenFuncList;
+
+typedef struct _WardenChkFuncList
+{
+    uint32 FctAddr[15]; // we may need to init one of them to use the Tick function
+} WardenChkFuncList;
+
+typedef struct _WardenInitData
+{
+    _WardenFuncList* pFct;
+    uint8 seed[16];
+    uint32 unknown1;
+    uint32 callbacks_ptr;
+    uint32 unknown2;
+    uint8 keys[0x204];
+    uint32 packetSkipBytes;
+    _WardenChkFuncList *pCheckFct;
+    // and so on, but I need only the seed 1st byte
+} WardenInitData;
+
+typedef struct _KeyPair
+{
+    uint8 client[0x102];
+    uint8 server[0x102];
+} KeyPair;
+
+typedef WardenFuncList** (__fastcall *fnInitializeModule)(DWORD* lpPtr2Table);
+
+class CWardenLoader
+{
+    class CLibraryEntry
+    {
+    public:
+        DWORD dwFileName;
+        DWORD dwImports;
+    };
+    class CHeader
+    {
+    public:
+        DWORD dwModuleSize;
+        DWORD dwDestructor;
+        DWORD dwSizeOfCode;
+        DWORD dwRelocationCount;
+        DWORD dwProcedureTable;
+        DWORD dwProcedureCount;
+        DWORD dwProcedureAdjust;
+        DWORD dwLibraryTable;
+        DWORD dwLibraryCount;
+        DWORD dwChunkCount;
+    };
+
+    PDWORD pdwModule;
+    DWORD dwModuleSize, dwLibraryCount;
+public:
+    template< class T >
+    T GetAddress( DWORD dwOffset )
+    {
+        return reinterpret_cast< T >( reinterpret_cast<DWORD>( pdwModule ) + dwOffset );
+    }
+
+    template<>
+    unsigned long GetAddress<DWORD>( DWORD dwOffset )
+    {
+        return reinterpret_cast<DWORD>( pdwModule ) + dwOffset;
+    }
+
+    inline CHeader * GetHeader( PDWORD pdwNewModule = 0 )
+    {
+        return reinterpret_cast<CHeader*>( pdwNewModule ? pdwNewModule : pdwModule );
+    }
+
+    void UnloadWarden();
+    bool LoadWarden( PDWORD pdwNewModule, DWORD dwSize );
+    PDWORD GetModule() { return pdwModule; }
+
+    template<class T>
+    T GetEntryPoint( DWORD dwIndex )
+    {
+        if( pdwModule )
+        {
+            dwIndex -= GetHeader()->dwProcedureAdjust;
+            if( dwIndex < GetHeader()->dwProcedureCount )
+                return GetAddress<T>( GetAddress<PDWORD>( GetHeader()->dwProcedureTable )[ dwIndex ] );
+        }
+        return 0;
+    }
+    WardenFuncList **InitializeWarden(InstanceS *instance);
+    void PrintHeader( PDWORD pdwHeader );
+};
+
+struct fPointers
+{
+    void *f1;
+    void *f2;
+    void *f3;
+    void *f4;
+};
+
+struct InstanceS
+{
+    FuncList dwTable;
+    FuncList *tableptr;
+    fPointers pointers;
+    WardenFuncList **list;
+    CWardenLoader *loader;
+};
+
+struct Wardend
+{
+    public:
+        static Wardend& Instance();
+        Wardend();
+        ~Wardend() {}
+        void Initialize();
+        bool LoadModuleAndExecute(uint32 accountId, uint32 modLen, uint8 *module, uint8 *sessionKey, uint8 *packet, ByteBuffer *returnPacket);
+    private:
+        uint8 *GenerateNewKeys(InstanceS *instance, uint8 *sessionKey/*[40]*/, uint8 *packet/*[17]*/);
+};
+
+#define sWardend Wardend::Instance()
+
+#endif
diff --git a/src/wardend/WardenSocket.cpp b/src/wardend/WardenSocket.cpp
new file mode 100644
--- /dev/null
+++ b/src/wardend/WardenSocket.cpp
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "Common.h"
+#include "Config/Config.h"
+#include "ByteBuffer.h"
+#include "Log.h"
+#include "WardenSocket.h"
+#include "WardendProtocol.h"
+
+#include <ace/OS_NS_unistd.h>
+#include <ace/OS_NS_fcntl.h>
+#include <ace/OS_NS_sys_stat.h>
+
+enum eStatus
+{
+    STATUS_NONE         = 0,
+    STATUS_CONNECTED    = 1
+};
+
+#pragma pack(push,1)
+
+typedef struct WardenHandler
+{
+    eWardendOpcode cmd;
+    uint32 status;
+    bool (WardenSocket::*handler)(void);
+}WardenHandler;
+
+#pragma pack(pop)
+
+const WardenHandler table[] =
+{
+    { MMSG_PING,                    STATUS_CONNECTED,   &WardenSocket::_HandlePing                      },
+    { MMSG_LOAD_MODULE,             STATUS_CONNECTED,   &WardenSocket::_HandleLoadModule                }
+};
+
+#define WARDEN_TOTAL_COMMANDS sizeof(table)/sizeof(WardenHandler)
+
+/// Constructor
+WardenSocket::WardenSocket() : _connected(false)
+{
+}
+
+/// Destructor
+WardenSocket::~WardenSocket()
+{
+}
+
+/// Accept the connection
+void WardenSocket::OnAccept()
+{
+    BASIC_LOG("Accepting connection from '%s'", get_remote_address().c_str());
+}
+
+/// Connection closed
+void WardenSocket::OnClose()
+{
+    BASIC_LOG("Terminating connection from '%s'", get_remote_address().c_str());
+    _connected = false;
+}
+
+/// Read the packet from world server
+void WardenSocket::OnRead()
+{
+    uint8 _cmd;
+    while (1)
+    {
+        if (!_connected)
+        {
+            char sign[7];
+            if(!recv_soft(sign, 7) || strcmp(sign, WARDEND_SIGN))
+            {
+                DEBUG_LOG("Received a connection not from Mangos '%s'.", sign);
+                recv_skip(recv_len());
+                return;
+            }
+            _connected = true;
+            recv_skip(7);
+            DEBUG_LOG("World process connected.");
+        }
+
+        if(!recv_soft((char *)&_cmd, 1))
+            return;
+
+        size_t i;
+
+        ///- Circle through known commands and call the correct command handler
+        for (i = 0; i < WARDEN_TOTAL_COMMANDS; ++i)
+        {
+            if ((uint8)table[i].cmd == _cmd && table[i].status == STATUS_CONNECTED && _connected)
+            {
+                if (!(*this.*table[i].handler)())
+                    return;
+                break;
+            }
+        }
+
+        ///- Report unknown commands in the debug log
+        if (i == WARDEN_TOTAL_COMMANDS)
+        {
+            DEBUG_LOG("[Warden] got unknown packet %u, len of received data %u", (uint32)_cmd, (uint32)recv_len());
+            return;
+        }
+    }
+}
+
+bool WardenSocket::_HandleLoadModule()
+{
+    DEBUG_LOG("WardenSocket::_HandleLoadModule, received %u", (uint32)recv_len());
+    uint8 testArray[5];
+    uint32 accountId;
+    uint32 moduleLen;
+    uint8 *module;
+    uint8 sessionKey[40];
+    uint8 packet[17];
+
+    if (!recv_soft((char *)&testArray, 5)) // opcode + moduleLen
+        return false;
+    moduleLen = *(uint32*)(testArray + 1);
+    uint32 pktSize = 1 + 4 + 4 + moduleLen + 40 + 17;
+    if (recv_len() < pktSize)
+    {
+        DEBUG_LOG("Got %u bytes of data, %u bytes needed, waiting for next tick", recv_len() ,pktSize);
+        return false;
+    }
+
+    recv_skip(5); // opcode + moduleLen already read
+
+    recv((char *)&accountId, 4);
+    module = (uint8*)malloc(moduleLen * sizeof(uint8));
+    recv((char *)module, moduleLen);
+    recv((char *)sessionKey, 40);
+    recv((char *)packet, 17);
+
+    ByteBuffer pkt;
+    if (sWardend.LoadModuleAndExecute(accountId, moduleLen, module, sessionKey, packet, &pkt))
+        send((char const*)pkt.contents(), pkt.size());
+    else
+        BASIC_LOG("There was a problem in running the sent module");
+    free(module);
+    return true;
+}
+
+bool WardenSocket::_HandlePing()
+{
+    recv_skip(1);
+    ByteBuffer pkt;
+    pkt << uint8(WMSG_PONG);
+    //BASIC_LOG("Ping -> Pong to %s", get_remote_address().c_str());
+    send((char const*)pkt.contents(), pkt.size());
+    return true;
+}
diff --git a/src/wardend/WardenSocket.h b/src/wardend/WardenSocket.h
new file mode 100644
--- /dev/null
+++ b/src/wardend/WardenSocket.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _WARDENSOCKET_H
+#define _WARDENSOCKET_H
+
+#include "Common.h"
+#include "WardenDaemon.h"
+#include "BufferedSocket.h"
+
+/// Handle login commands
+class WardenSocket: public BufferedSocket
+{
+    public:
+        const static int s_BYTE_SIZE = 32;
+
+        WardenSocket();
+        ~WardenSocket();
+
+        void OnAccept();
+        void OnRead();
+        void OnClose();
+
+        bool _HandleLoadModule();
+        bool _HandlePing();
+
+    private:
+        bool _connected;
+};
+#endif
diff --git a/src/wardend/WardendProtocol.h b/src/wardend/WardendProtocol.h
new file mode 100644
--- /dev/null
+++ b/src/wardend/WardendProtocol.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2005-2011 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _PROTOCOL_H
+#define _PROTOCOL_H
+
+enum eWardendOpcode
+{
+    MMSG_PING                       = 0x01,
+    WMSG_PONG                       = 0x02,
+    MMSG_LOAD_MODULE                = 0x03,
+    //  uint32  moduleLen;
+    //  uint32  accountId;
+    //  uint8   module[moduleLen];
+    //  uint8   sessionKey[40];
+    //  uint8   clientPacket[17];
+    WMSG_WARDEN_KEYS                = 0x04,
+    //  uint32  accountId;
+    //  uint8   serverKey[258];
+    //  uint8   clientKey[258];
+    //  uint8   seed[16];
+    WMSG_CONNECTION_END             = 0x71,
+};
+
+enum eWardenServerCmd
+{
+    WARDS_MODULE_INFO               = 0x00,
+    WARDS_MODULE_CHUNK              = 0x01,
+    WARDS_CHEAT_CHECK               = 0x02,
+    WARDS_DATA                      = 0x03,
+
+    WARDS_SEED                      = 0x05
+};
+
+enum eWardenClientCmd
+{
+    WARDC_MODULE_LOAD_FAILED        = 0x00,
+    WARDC_MODULE_LOADED             = 0x01,
+    WARDC_CHEAT_CHECK_RESULT        = 0x02,
+
+    WARDC_TRANSFORMED_SEED          = 0x04
+};
+
+enum eWardenCheckType
+{
+    WARD_CHECK_MEMORY               = 0,
+    WARD_CHECK_PAGE1                = 1,
+    WARD_CHECK_PAGE2                = 2,
+    WARD_CHECK_FILE                 = 3,
+    WARD_CHECK_LUA                  = 4,
+    WARD_CHECK_DRIVER               = 5,
+    WARD_CHECK_TIMING               = 6,
+    WARD_CHECK_PROCESS              = 7,
+    WARD_CHECK_MODULE               = 8,
+    WARD_CHECK_END                  = 9
+};
+
+#define WARDEND_SIGN "MaNGOS"
+#endif
diff --git a/src/wardend/wardend.conf.dist.in b/src/wardend/wardend.conf.dist.in
new file mode 100644
--- /dev/null
+++ b/src/wardend/wardend.conf.dist.in
@@ -0,0 +1,92 @@
+############################################
+# MaNGOS wardend configuration file        #
+############################################
+
+[WardendConf]
+ConfVersion=2010111901
+
+###################################################################################################################
+# WARDEND SETTINGS
+#
+#    LogsDir
+#         Logs directory setting.
+#         Important: Logs dir must exists, or all logs be disable
+#         Default: "" - no log directory prefix, if used log names isn't absolute path then logs will be
+#                       stored in current directory for run program.
+#
+#    WardenServerPort
+#         Default WardenServerPort
+#         Default: 6555
+#
+#    BindIP
+#         Bind Warden Deamon to IP/hostname
+#         This option is useful to protect wardend from outside
+#
+#    PidFile
+#        Wardend daemon PID file
+#        Default: ""             - do not create PID file
+#                 "./wardend.pid" - create PID file (recommended name)
+#
+#    LogLevel
+#        Server console level of logging
+#        0 = Minimum; 1 = Error; 2 = Detail; 3 = Full/Debug
+#        Default: 0
+#
+#    LogTime
+#        Include time in server console output [hh:mm:ss]
+#        Default: 0 (no time)
+#                 1 (print time)
+#
+#    LogFile
+#        Logfile name
+#        Default: "Wardend.log"
+#                 "" - empty name disable creating log file
+#
+#    LogTimestamp
+#        Logfile with timestamp of server start in name
+#        Default: 0 - no timestamp in name
+#                 1 - add timestamp in name in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
+#
+#    LogFileLevel
+#        Server file level of logging
+#        0 = Minimum; 1 = Error; 2 = Detail; 3 = Full/Debug
+#        Default: 0
+#
+#    LogColors
+#        Color for messages (format "normal_color details_color debug_color error_color)
+#        Colors: 0 - BLACK, 1 - RED, 2 - GREEN,  3 - BROWN, 4 - BLUE, 5 - MAGENTA, 6 -  CYAN, 7 - GREY,
+#                8 - YELLOW, 9 - LRED, 10 - LGREEN, 11 - LBLUE, 12 - LMAGENTA, 13 - LCYAN, 14 - WHITE
+#        Default: "" - none colors
+#                 "13 7 11 9" - for example :)
+#
+#    UseProcessors
+#        Used processors mask for multi-processors system (Used only at Windows)
+#        Default: 0 (selected by OS)
+#                 number (bitmask value of selected processors)
+#
+#    ProcessPriority
+#        Process proirity setting (Used only at Windows)
+#        Default: 1 (HIGH)
+#                 0 (Normal)
+#
+#    WaitAtStartupError
+#        After startup error report wait <Enter> or some time before continue (and possible close console window)
+#                 -1 (wait until <Enter> press)
+#        Default:  0 (not wait)
+#                  N (>0, wait N secs)
+#
+###################################################################################################################
+
+LogsDir = ""
+WardenServerPort = 6555
+BindIP = "0.0.0.0"
+PidFile = ""
+LogLevel = 0
+LogTime = 0
+LogFile = "Wardend.log"
+LogTimestamp = 0
+LogFileLevel = 0
+LogColors = ""
+UseProcessors = 0
+ProcessPriority = 1
+WaitAtStartupError = 0
diff --git a/src/wardend/wardend.ico b/src/wardend/wardend.ico
new file mode 100644
GIT binary patch
literal 34494
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
E2lH-1kpKVy

literal 0
HcmV?d00001

diff --git a/src/wardend/wardend.rc b/src/wardend/wardend.rc
new file mode 100644
--- /dev/null
+++ b/src/wardend/wardend.rc
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2005-2010 MaNGOS <http://getmangos.com/>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+IDI_APPICON ICON DISCARDABLE "wardend.ico"
diff --git a/win/VC100/game.vcxproj b/win/VC100/game.vcxproj
--- a/win/VC100/game.vcxproj
+++ b/win/VC100/game.vcxproj
@@ -499,6 +499,7 @@
     <ClCompile Include="..\..\src\game\UpdateData.cpp" />
     <ClCompile Include="..\..\src\game\Vehicle.cpp" />
     <ClCompile Include="..\..\src\game\VoiceChatHandler.cpp" />
+    <ClCompile Include="..\..\src\game\WardenMgr.cpp" />
     <ClCompile Include="..\..\src\game\WaypointManager.cpp" />
     <ClCompile Include="..\..\src\game\WaypointMovementGenerator.cpp" />
     <ClCompile Include="..\..\src\game\Weather.cpp" />
@@ -640,6 +641,7 @@
     <ClInclude Include="..\..\src\game\UpdateFields.h" />
     <ClInclude Include="..\..\src\game\UpdateMask.h" />
     <ClInclude Include="..\..\src\game\Vehicle.h" />
+    <ClInclude Include="..\..\src\game\WardenMgr.h" />
     <ClInclude Include="..\..\src\game\WaypointManager.h" />
     <ClInclude Include="..\..\src\game\WaypointMovementGenerator.h" />
     <ClInclude Include="..\..\src\game\Weather.h" />
diff --git a/win/VC100/game.vcxproj.filters b/win/VC100/game.vcxproj.filters
--- a/win/VC100/game.vcxproj.filters
+++ b/win/VC100/game.vcxproj.filters
@@ -237,6 +237,9 @@
     <ClCompile Include="..\..\src\game\VoiceChatHandler.cpp">
       <Filter>World/Handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\src\game\WardenMgr.cpp">
+      <Filter>World/Handlers</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\src\game\WaypointManager.cpp">
       <Filter>World/Handlers</Filter>
     </ClCompile>
@@ -624,6 +627,9 @@
     <ClInclude Include="..\..\src\game\UpdateData.h">
       <Filter>World/Handlers</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\src\game\WardenMgr.h">
+      <Filter>World/Handlers</Filter>
+    </ClInclude>
     <ClInclude Include="..\..\src\game\WaypointManager.h">
       <Filter>World/Handlers</Filter>
     </ClInclude>
diff --git a/win/VC100/wardend.vcxproj b/win/VC100/wardend.vcxproj
new file mode 100644
--- /dev/null
+++ b/win/VC100/wardend.vcxproj
@@ -0,0 +1,165 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}</ProjectGuid>
+    <RootNamespace>wardend</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets">
+    <Import Project="$(LocalAppData)\Microsoft\VisualStudio\10.0\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(LocalAppData)\Microsoft\VisualStudio\10.0\Microsoft.Cpp.$(Platform).user.props')" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\bin\$(Platform)_$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">.\wardend__$(Platform)_$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\bin\$(Platform)_$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">.\wardend__$(Platform)_$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Midl>
+      <TypeLibraryName>.\..\..\bin\$(Platform)_$(Configuration)\wardend.tlb</TypeLibraryName>
+    </Midl>
+    <ClCompile>
+      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <AdditionalIncludeDirectories>..\..\dep\include;..\..\src\framework;..\..\src\shared;..\..\dep\ACE_wrappers;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>VERSION=0.17.0-DEV;WIN32;NDEBUG;_CONSOLE;_SECURE_SCL=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <PrecompiledHeaderOutputFile>.\wardend__$(Platform)_$(Configuration)\wardend.pch</PrecompiledHeaderOutputFile>
+      <AssemblerListingLocation>.\wardend__$(Platform)_$(Configuration)\</AssemblerListingLocation>
+      <ObjectFileName>.\wardend__$(Platform)_$(Configuration)\</ObjectFileName>
+      <ProgramDataBaseFileName>.\wardend__$(Platform)_$(Configuration)\</ProgramDataBaseFileName>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <CompileAs>Default</CompileAs>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0409</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalOptions>/MACHINE:I386 %(AdditionalOptions)</AdditionalOptions>
+      <AdditionalDependencies>libmySQL.lib;libeay32.lib;ws2_32.lib;winmm.lib;odbc32.lib;odbccp32.lib;advapi32.lib;dbghelp.lib;shared.lib;ACE.lib;framework.lib;zlib.lib;msvcrt.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>..\..\bin\$(Platform)_$(Configuration)\wardend.exe</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <AdditionalLibraryDirectories>..\..\dep\lib\$(Platform)_$(Configuration);.\framework__$(Platform)_$(Configuration);.\shared__$(Platform)_$(Configuration);.\zlib__$(Platform)_$(Configuration);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <ProgramDatabaseFile>..\..\bin\$(Platform)_$(Configuration)\wardend.pdb</ProgramDatabaseFile>
+      <GenerateMapFile>true</GenerateMapFile>
+      <MapFileName>..\..\bin\$(Platform)_$(Configuration)\wardend.map</MapFileName>
+      <SubSystem>Console</SubSystem>
+      <LargeAddressAware>true</LargeAddressAware>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+    </Link>
+    <PostBuildEvent>
+      <Command>copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\ACE*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)
+copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\tbb*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)
+copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\dbghelp*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Midl>
+      <TypeLibraryName>.\..\..\bin\$(Platform)_$(Configuration)\wardend.tlb</TypeLibraryName>
+    </Midl>
+    <ClCompile>
+      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>..\..\dep\include;..\..\src\framework;..\..\src\shared;..\..\dep\ACE_wrappers;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>VERSION=0.17.0-DEV;WIN32;_DEBUG;MANGOS_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <IgnoreStandardIncludePath>false</IgnoreStandardIncludePath>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <PrecompiledHeaderOutputFile>.\wardend__$(Platform)_$(Configuration)\wardend.pch</PrecompiledHeaderOutputFile>
+      <AssemblerListingLocation>.\wardend__$(Platform)_$(Configuration)\</AssemblerListingLocation>
+      <ObjectFileName>.\wardend__$(Platform)_$(Configuration)\</ObjectFileName>
+      <ProgramDataBaseFileName>.\wardend__$(Platform)_$(Configuration)\</ProgramDataBaseFileName>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <CompileAs>Default</CompileAs>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0409</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalOptions>/MACHINE:I386 %(AdditionalOptions)</AdditionalOptions>
+      <AdditionalDependencies>libmySQL.lib;libeay32.lib;ws2_32.lib;winmm.lib;odbc32.lib;odbccp32.lib;advapi32.lib;dbghelp.lib;shared.lib;ACEd.lib;framework.lib;zlib.lib;msvcrtd.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>..\..\bin\$(Platform)_$(Configuration)\wardend.exe</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <AdditionalLibraryDirectories>..\..\dep\lib\$(Platform)_$(Configuration);.\framework__$(Platform)_$(Configuration);.\shared__$(Platform)_$(Configuration);.\zlib__$(Platform)_$(Configuration);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <ProgramDatabaseFile>..\..\bin\$(Platform)_$(Configuration)\wardend.pdb</ProgramDatabaseFile>
+      <GenerateMapFile>true</GenerateMapFile>
+      <MapFileName>..\..\bin\$(Platform)_$(Configuration)\wardend.map</MapFileName>
+      <SubSystem>Console</SubSystem>
+      <LargeAddressAware>true</LargeAddressAware>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>false</FixedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+    </Link>
+    <PostBuildEvent>
+      <Command>copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\ACE*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)
+copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\tbb*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)
+copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\dbghelp*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\src\wardend\BufferedSocket.cpp" />
+    <ClCompile Include="..\..\src\wardend\Main.cpp" />
+    <ClCompile Include="..\..\src\wardend\WardenDaemon.cpp" />
+    <ClCompile Include="..\..\src\wardend\WardenSocket.cpp" />
+    <ClCompile Include="..\..\src\shared\WheatyExceptionReport.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\src\wardend\BufferedSocket.h" />
+    <ClInclude Include="..\..\src\wardend\WardenDaemon.h" />
+    <ClInclude Include="..\..\src\wardend\WardendProtocol.h" />
+    <ClInclude Include="..\..\src\wardend\WardenSocket.h" />
+    <ClInclude Include="..\..\src\shared\WheatyExceptionReport.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="..\..\src\wardend\wardend.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/win/VC80/game.vcproj b/win/VC80/game.vcproj
--- a/win/VC80/game.vcproj
+++ b/win/VC80/game.vcproj
@@ -1014,6 +1014,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\WardenMgr.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\WardenMgr.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\Weather.cpp"
 				>
 			</File>
diff --git a/win/VC80/wardend.vcproj b/win/VC80/wardend.vcproj
new file mode 100644
--- /dev/null
+++ b/win/VC80/wardend.vcproj
@@ -0,0 +1,270 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="wardend"
+	ProjectGUID="{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}"
+	RootNamespace="wardend"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\wardend__$(PlatformName)_$(ConfigurationName)"
+			IntermediateDirectory=".\wardend__$(PlatformName)_$(ConfigurationName)"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\wardend__$(PlatformName)_$(ConfigurationName)\wardend.tlb"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalOptions="/MP"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="..\..\dep\include;..\..\src\framework;..\..\src\shared;..\..\src\wardend;..\..\dep\ACE_wrappers"
+				PreprocessorDefinitions="VERSION=&quot;0.17.0-DEV&quot;,WIN32,NDEBUG,_CONSOLE;_SECURE_SCL=0"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				EnableEnhancedInstructionSet="1"
+				RuntimeTypeInfo="true"
+				PrecompiledHeaderFile=".\wardend__$(PlatformName)_$(ConfigurationName)\wardend.pch"
+				AssemblerListingLocation=".\wardend__$(PlatformName)_$(ConfigurationName)\"
+				ObjectFile=".\wardend__$(PlatformName)_$(ConfigurationName)\"
+				ProgramDataBaseFileName=".\wardend__$(PlatformName)_$(ConfigurationName)\"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="libmySQL.lib libeay32.lib ws2_32.lib winmm.lib odbc32.lib odbccp32.lib advapi32.lib dbghelp.lib"
+				OutputFile="..\..\bin\$(PlatformName)_$(ConfigurationName)\wardend.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				AdditionalLibraryDirectories="..\..\dep\lib\$(PlatformName)_$(ConfigurationName)"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="..\..\bin\$(PlatformName)_$(ConfigurationName)\wardend.pdb"
+				GenerateMapFile="true"
+				MapFileName="..\..\bin\$(PlatformName)_$(ConfigurationName)\wardend.map"
+				SubSystem="1"
+				LargeAddressAware="2"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\ACE*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)&#x0D;&#x0A;copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\tbb*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)&#x0D;&#x0A;copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\dbghelp*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\wardend__$(PlatformName)_$(ConfigurationName)"
+			IntermediateDirectory=".\wardend__$(PlatformName)_$(ConfigurationName)"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\wardend__$(PlatformName)_$(ConfigurationName)\wardend.tlb"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalOptions="/MP"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\dep\include;..\..\src\framework;..\..\src\shared;..\..\src\wardend;..\..\dep\ACE_wrappers"
+				PreprocessorDefinitions="VERSION=&quot;0.17.0-DEV&quot;;WIN32;_DEBUG;MANGOS_DEBUG;_CONSOLE"
+				IgnoreStandardIncludePath="false"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				EnableFunctionLevelLinking="true"
+				EnableEnhancedInstructionSet="1"
+				RuntimeTypeInfo="true"
+				PrecompiledHeaderFile=".\wardend__$(PlatformName)_$(ConfigurationName)\wardend.pch"
+				AssemblerListingLocation=".\wardend__$(PlatformName)_$(ConfigurationName)\"
+				ObjectFile=".\wardend__$(PlatformName)_$(ConfigurationName)\"
+				ProgramDataBaseFileName=".\wardend__$(PlatformName)_$(ConfigurationName)\"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="libmySQL.lib libeay32.lib ws2_32.lib winmm.lib odbc32.lib odbccp32.lib advapi32.lib dbghelp.lib"
+				OutputFile="..\..\bin\$(PlatformName)_$(ConfigurationName)\wardend.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				AdditionalLibraryDirectories="..\..\dep\lib\$(PlatformName)_$(ConfigurationName)"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="..\..\bin\$(PlatformName)_$(ConfigurationName)\wardend.pdb"
+				GenerateMapFile="true"
+				MapFileName="..\..\bin\$(PlatformName)_$(ConfigurationName)\wardend.map"
+				SubSystem="1"
+				LargeAddressAware="2"
+				FixedBaseAddress="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\ACE*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)&#x0D;&#x0A;copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\tbb*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)&#x0D;&#x0A;copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\dbghelp*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)&#x0D;&#x0A;"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="..\..\src\wardend\BufferedSocket.cpp"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\BufferedSocket.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\Main.cpp"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\wardend.rc"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\WardenDaemon.cpp"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\WardenDaemon.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\WardendProtocol.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\WardenSocket.cpp"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\WardenSocket.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\shared\WheatyExceptionReport.cpp"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\shared\WheatyExceptionReport.h"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/win/VC90/game.vcproj b/win/VC90/game.vcproj
--- a/win/VC90/game.vcproj
+++ b/win/VC90/game.vcproj
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="9,00"
+	Version="9.00"
 	Name="game"
 	ProjectGUID="{1DC6C4DA-A028-41F3-877D-D5400C594F88}"
 	RootNamespace="game"
@@ -999,6 +999,14 @@
 				>
 			</File>
 			<File
+				RelativePath="..\..\src\game\WardenMgr.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\WardenMgr.h"
+				>
+			</File>
+			<File
 				RelativePath="..\..\src\game\WaypointManager.cpp"
 				>
 			</File>
diff --git a/win/VC90/wardend.vcproj b/win/VC90/wardend.vcproj
new file mode 100644
--- /dev/null
+++ b/win/VC90/wardend.vcproj
@@ -0,0 +1,269 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="wardend"
+	ProjectGUID="{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}"
+	RootNamespace="wardend"
+	TargetFrameworkVersion="0"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\wardend__$(PlatformName)_$(ConfigurationName)"
+			IntermediateDirectory=".\wardend__$(PlatformName)_$(ConfigurationName)"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\wardend__$(PlatformName)_$(ConfigurationName)\wardend.tlb"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalOptions="/MP"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="..\..\dep\include;..\..\src\framework;..\..\src\shared;..\..\src\wardend;..\..\dep\ACE_wrappers"
+				PreprocessorDefinitions="VERSION=&quot;0.17.0-DEV&quot;,WIN32,NDEBUG,_CONSOLE;_SECURE_SCL=0"
+				StringPooling="true"
+				RuntimeLibrary="2"
+				EnableFunctionLevelLinking="true"
+				EnableEnhancedInstructionSet="1"
+				RuntimeTypeInfo="true"
+				PrecompiledHeaderFile=".\wardend__$(PlatformName)_$(ConfigurationName)\wardend.pch"
+				AssemblerListingLocation=".\wardend__$(PlatformName)_$(ConfigurationName)\"
+				ObjectFile=".\wardend__$(PlatformName)_$(ConfigurationName)\"
+				ProgramDataBaseFileName=".\wardend__$(PlatformName)_$(ConfigurationName)\"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="libmySQL.lib libeay32.lib ws2_32.lib winmm.lib odbc32.lib odbccp32.lib advapi32.lib dbghelp.lib"
+				OutputFile="..\..\bin\$(PlatformName)_$(ConfigurationName)\wardend.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				AdditionalLibraryDirectories="..\..\dep\lib\$(PlatformName)_$(ConfigurationName)"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="..\..\bin\$(PlatformName)_$(ConfigurationName)\wardend.pdb"
+				GenerateMapFile="true"
+				MapFileName="..\..\bin\$(PlatformName)_$(ConfigurationName)\wardend.map"
+				SubSystem="1"
+				LargeAddressAware="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\ACE*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)&#x0D;&#x0A;copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\tbb*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)&#x0D;&#x0A;copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\dbghelp*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\wardend__$(PlatformName)_$(ConfigurationName)"
+			IntermediateDirectory=".\wardend__$(PlatformName)_$(ConfigurationName)"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\wardend__$(PlatformName)_$(ConfigurationName)\wardend.tlb"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalOptions="/MP"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\..\dep\include;..\..\src\framework;..\..\src\shared;..\..\src\wardend;..\..\dep\ACE_wrappers"
+				PreprocessorDefinitions="VERSION=&quot;0.17.0-DEV&quot;;WIN32;_DEBUG;MANGOS_DEBUG;_CONSOLE"
+				IgnoreStandardIncludePath="false"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				EnableFunctionLevelLinking="true"
+				EnableEnhancedInstructionSet="1"
+				RuntimeTypeInfo="true"
+				PrecompiledHeaderFile=".\wardend__$(PlatformName)_$(ConfigurationName)\wardend.pch"
+				AssemblerListingLocation=".\wardend__$(PlatformName)_$(ConfigurationName)\"
+				ObjectFile=".\wardend__$(PlatformName)_$(ConfigurationName)\"
+				ProgramDataBaseFileName=".\wardend__$(PlatformName)_$(ConfigurationName)\"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+				CallingConvention="0"
+				CompileAs="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalOptions="/MACHINE:I386"
+				AdditionalDependencies="libmySQL.lib libeay32.lib ws2_32.lib winmm.lib odbc32.lib odbccp32.lib advapi32.lib dbghelp.lib"
+				OutputFile="..\..\bin\$(PlatformName)_$(ConfigurationName)\wardend.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				AdditionalLibraryDirectories="..\..\dep\lib\$(PlatformName)_$(ConfigurationName)"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile="..\..\bin\$(PlatformName)_$(ConfigurationName)\wardend.pdb"
+				GenerateMapFile="true"
+				MapFileName="..\..\bin\$(PlatformName)_$(ConfigurationName)\wardend.map"
+				SubSystem="1"
+				LargeAddressAware="2"
+				RandomizedBaseAddress="1"
+				FixedBaseAddress="1"
+				DataExecutionPrevention="0"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\ACE*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)&#x0D;&#x0A;copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\tbb*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)&#x0D;&#x0A;copy ..\..\dep\lib\$(PlatformName)_$(ConfigurationName)\dbghelp*.dll ..\..\bin\$(PlatformName)_$(ConfigurationName)&#x0D;&#x0A;"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="..\..\src\wardend\BufferedSocket.cpp"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\BufferedSocket.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\Main.cpp"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\wardend.rc"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\WardenDaemon.cpp"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\WardenDaemon.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\WardendProtocol.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\WardenSocket.cpp"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\wardend\WardenSocket.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\shared\WheatyExceptionReport.cpp"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\shared\WheatyExceptionReport.h"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/win/wardendVC100.sln b/win/wardendVC100.sln
new file mode 100644
--- /dev/null
+++ b/win/wardendVC100.sln
@@ -0,0 +1,80 @@
+Microsoft Visual Studio Solution File, Format Version 11.00
+# Visual Studio 2010
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shared", "VC100\shared.vcxproj", "{90297C34-F231-4DF4-848E-A74BCC0E40ED}"
+	ProjectSection(ProjectDependencies) = postProject
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E} = {BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2} = {8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2} = {803F488E-4C5A-4866-8D5C-1E6C03C007C2}
+		{BD537C9A-FECA-1BAD-6757-8A6348EA12C8} = {BD537C9A-FECA-1BAD-6757-8A6348EA12C8}
+		{F62787DD-1327-448B-9818-030062BCFAA5} = {F62787DD-1327-448B-9818-030062BCFAA5}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlib", "VC100\zlib.vcxproj", "{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "framework", "VC100\framework.vcxproj", "{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}"
+	ProjectSection(ProjectDependencies) = postProject
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8} = {B15F131E-328A-4D42-ADC2-9FF4CA6306D8}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "genrevision", "VC100\genrevision.vcxproj", "{803F488E-4C5A-4866-8D5C-1E6C03C007C2}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ACE_Wrappers", "VC100\ACE_vc10.vcxproj", "{BD537C9A-FECA-1BAD-6757-8A6348EA12C8}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tbbmalloc", "VC100\tbbmalloc.vcxproj", "{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}"
+	ProjectSection(ProjectDependencies) = postProject
+		{F62787DD-1327-448B-9818-030062BCFAA5} = {F62787DD-1327-448B-9818-030062BCFAA5}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tbb", "VC100\tbb.vcxproj", "{F62787DD-1327-448B-9818-030062BCFAA5}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wardend", "VC100\wardend.vcxproj", "{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}"
+	ProjectSection(ProjectDependencies) = postProject
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED} = {90297C34-F231-4DF4-848E-A74BCC0E40ED}
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Debug|Win32.ActiveCfg = Debug|Win32
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Debug|Win32.Build.0 = Debug|Win32
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Release|Win32.ActiveCfg = Release|Win32
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Release|Win32.Build.0 = Release|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Debug|Win32.ActiveCfg = Debug|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Debug|Win32.Build.0 = Debug|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Release|Win32.ActiveCfg = Release|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Release|Win32.Build.0 = Release|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Debug|Win32.ActiveCfg = Debug|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Debug|Win32.Build.0 = Debug|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Release|Win32.ActiveCfg = Release|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Release|Win32.Build.0 = Release|Win32
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2}.Debug|Win32.ActiveCfg = Debug|Win32
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2}.Debug|Win32.Build.0 = Debug|Win32
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2}.Release|Win32.ActiveCfg = Release|Win32
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2}.Release|Win32.Build.0 = Release|Win32
+		{BD537C9A-FECA-1BAD-6757-8A6348EA12C8}.Debug|Win32.ActiveCfg = Debug|Win32
+		{BD537C9A-FECA-1BAD-6757-8A6348EA12C8}.Debug|Win32.Build.0 = Debug|Win32
+		{BD537C9A-FECA-1BAD-6757-8A6348EA12C8}.Release|Win32.ActiveCfg = Release|Win32
+		{BD537C9A-FECA-1BAD-6757-8A6348EA12C8}.Release|Win32.Build.0 = Release|Win32
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}.Debug|Win32.ActiveCfg = Debug|Win32
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}.Debug|Win32.Build.0 = Debug|Win32
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}.Release|Win32.ActiveCfg = Release|Win32
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}.Release|Win32.Build.0 = Release|Win32
+		{F62787DD-1327-448B-9818-030062BCFAA5}.Debug|Win32.ActiveCfg = Debug|Win32
+		{F62787DD-1327-448B-9818-030062BCFAA5}.Debug|Win32.Build.0 = Debug|Win32
+		{F62787DD-1327-448B-9818-030062BCFAA5}.Release|Win32.ActiveCfg = Release|Win32
+		{F62787DD-1327-448B-9818-030062BCFAA5}.Release|Win32.Build.0 = Release|Win32
+		{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}.Debug|Win32.ActiveCfg = Debug|Win32
+		{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}.Debug|Win32.Build.0 = Debug|Win32
+		{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}.Release|Win32.ActiveCfg = Release|Win32
+		{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(DPCodeReviewSolutionGUID) = preSolution
+		DPCodeReviewSolutionGUID = {00000000-0000-0000-0000-000000000000}
+	EndGlobalSection
+EndGlobal
diff --git a/win/wardendVC80.sln b/win/wardendVC80.sln
new file mode 100644
--- /dev/null
+++ b/win/wardendVC80.sln
@@ -0,0 +1,77 @@
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shared", "VC80\shared.vcproj", "{90297C34-F231-4DF4-848E-A74BCC0E40ED}"
+	ProjectSection(ProjectDependencies) = postProject
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2} = {8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E} = {BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}
+		{AD537C9A-FECA-1BAD-6757-8A6300006755} = {AD537C9A-FECA-1BAD-6757-8A6300006755}
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2} = {803F488E-4C5A-4866-8D5C-1E6C03C007C2}
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8} = {B15F131E-328A-4D42-ADC2-9FF4CA6306D8}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlib", "VC80\zlib.vcproj", "{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "framework", "VC80\framework.vcproj", "{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "genrevision", "VC80\genrevision.vcproj", "{803F488E-4C5A-4866-8D5C-1E6C03C007C2}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ACE_Wrappers", "VC80\ACE_vc8.vcproj", "{AD537C9A-FECA-1BAD-6757-8A6300006755}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tbb", "VC80\tbb.vcproj", "{F62787DD-1327-448B-9818-030062BCFAA5}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tbbmalloc", "VC80\tbbmalloc.vcproj", "{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}"
+	ProjectSection(ProjectDependencies) = postProject
+		{F62787DD-1327-448B-9818-030062BCFAA5} = {F62787DD-1327-448B-9818-030062BCFAA5}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wardend", "VC80\wardend.vcproj", "{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}"
+	ProjectSection(ProjectDependencies) = postProject
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED} = {90297C34-F231-4DF4-848E-A74BCC0E40ED}
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Debug|Win32.ActiveCfg = Debug|Win32
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Debug|Win32.Build.0 = Debug|Win32
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Release|Win32.ActiveCfg = Release|Win32
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Release|Win32.Build.0 = Release|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Debug|Win32.ActiveCfg = Debug|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Debug|Win32.Build.0 = Debug|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Release|Win32.ActiveCfg = Release|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Release|Win32.Build.0 = Release|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Debug|Win32.ActiveCfg = Debug|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Debug|Win32.Build.0 = Debug|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Release|Win32.ActiveCfg = Release|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Release|Win32.Build.0 = Release|Win32
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2}.Debug|Win32.ActiveCfg = Debug|Win32
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2}.Debug|Win32.Build.0 = Debug|Win32
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2}.Release|Win32.ActiveCfg = Release|Win32
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2}.Release|Win32.Build.0 = Release|Win32
+		{AD537C9A-FECA-1BAD-6757-8A6300006755}.Debug|Win32.ActiveCfg = Debug|Win32
+		{AD537C9A-FECA-1BAD-6757-8A6300006755}.Debug|Win32.Build.0 = Debug|Win32
+		{AD537C9A-FECA-1BAD-6757-8A6300006755}.Release|Win32.ActiveCfg = Release|Win32
+		{AD537C9A-FECA-1BAD-6757-8A6300006755}.Release|Win32.Build.0 = Release|Win32
+		{F62787DD-1327-448B-9818-030062BCFAA5}.Debug|Win32.ActiveCfg = Debug|Win32
+		{F62787DD-1327-448B-9818-030062BCFAA5}.Debug|Win32.Build.0 = Debug|Win32
+		{F62787DD-1327-448B-9818-030062BCFAA5}.Release|Win32.ActiveCfg = Release|Win32
+		{F62787DD-1327-448B-9818-030062BCFAA5}.Release|Win32.Build.0 = Release|Win32
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}.Debug|Win32.ActiveCfg = Debug|Win32
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}.Debug|Win32.Build.0 = Debug|Win32
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}.Release|Win32.ActiveCfg = Release|Win32
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}.Release|Win32.Build.0 = Release|Win32
+		{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}.Debug|Win32.ActiveCfg = Debug|Win32
+		{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}.Debug|Win32.Build.0 = Debug|Win32
+		{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}.Release|Win32.ActiveCfg = Release|Win32
+		{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(DPCodeReviewSolutionGUID) = preSolution
+		DPCodeReviewSolutionGUID = {00000000-0000-0000-0000-000000000000}
+	EndGlobalSection
+EndGlobal
diff --git a/win/wardendVC90.sln b/win/wardendVC90.sln
new file mode 100644
--- /dev/null
+++ b/win/wardendVC90.sln
@@ -0,0 +1,79 @@
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shared", "VC90\shared.vcproj", "{90297C34-F231-4DF4-848E-A74BCC0E40ED}"
+	ProjectSection(ProjectDependencies) = postProject
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E} = {BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2} = {8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2} = {803F488E-4C5A-4866-8D5C-1E6C03C007C2}
+		{BD537C9A-FECA-1BAD-6757-8A6300006755} = {BD537C9A-FECA-1BAD-6757-8A6300006755}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlib", "VC90\zlib.vcproj", "{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "framework", "VC90\framework.vcproj", "{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}"
+	ProjectSection(ProjectDependencies) = postProject
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8} = {B15F131E-328A-4D42-ADC2-9FF4CA6306D8}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "genrevision", "VC90\genrevision.vcproj", "{803F488E-4C5A-4866-8D5C-1E6C03C007C2}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ACE_Wrappers", "VC90\ACE_vc9.vcproj", "{BD537C9A-FECA-1BAD-6757-8A6300006755}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tbb", "VC90\tbb.vcproj", "{F62787DD-1327-448B-9818-030062BCFAA5}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tbbmalloc", "VC90\tbbmalloc.vcproj", "{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}"
+	ProjectSection(ProjectDependencies) = postProject
+		{F62787DD-1327-448B-9818-030062BCFAA5} = {F62787DD-1327-448B-9818-030062BCFAA5}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wardend", "VC90\wardend.vcproj", "{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}"
+	ProjectSection(ProjectDependencies) = postProject
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED} = {90297C34-F231-4DF4-848E-A74BCC0E40ED}
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Debug|Win32.ActiveCfg = Debug|Win32
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Debug|Win32.Build.0 = Debug|Win32
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Release|Win32.ActiveCfg = Release|Win32
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Release|Win32.Build.0 = Release|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Debug|Win32.ActiveCfg = Debug|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Debug|Win32.Build.0 = Debug|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Release|Win32.ActiveCfg = Release|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Release|Win32.Build.0 = Release|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Debug|Win32.ActiveCfg = Debug|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Debug|Win32.Build.0 = Debug|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Release|Win32.ActiveCfg = Release|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Release|Win32.Build.0 = Release|Win32
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2}.Debug|Win32.ActiveCfg = Debug|Win32
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2}.Debug|Win32.Build.0 = Debug|Win32
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2}.Release|Win32.ActiveCfg = Release|Win32
+		{803F488E-4C5A-4866-8D5C-1E6C03C007C2}.Release|Win32.Build.0 = Release|Win32
+		{BD537C9A-FECA-1BAD-6757-8A6300006755}.Debug|Win32.ActiveCfg = Debug|Win32
+		{BD537C9A-FECA-1BAD-6757-8A6300006755}.Debug|Win32.Build.0 = Debug|Win32
+		{BD537C9A-FECA-1BAD-6757-8A6300006755}.Release|Win32.ActiveCfg = Release|Win32
+		{BD537C9A-FECA-1BAD-6757-8A6300006755}.Release|Win32.Build.0 = Release|Win32
+		{F62787DD-1327-448B-9818-030062BCFAA5}.Debug|Win32.ActiveCfg = Debug|Win32
+		{F62787DD-1327-448B-9818-030062BCFAA5}.Debug|Win32.Build.0 = Debug|Win32
+		{F62787DD-1327-448B-9818-030062BCFAA5}.Release|Win32.ActiveCfg = Release|Win32
+		{F62787DD-1327-448B-9818-030062BCFAA5}.Release|Win32.Build.0 = Release|Win32
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}.Debug|Win32.ActiveCfg = Debug|Win32
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}.Debug|Win32.Build.0 = Debug|Win32
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}.Release|Win32.ActiveCfg = Release|Win32
+		{B15F131E-328A-4D42-ADC2-9FF4CA6306D8}.Release|Win32.Build.0 = Release|Win32
+		{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}.Debug|Win32.ActiveCfg = Debug|Win32
+		{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}.Debug|Win32.Build.0 = Debug|Win32
+		{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}.Release|Win32.ActiveCfg = Release|Win32
+		{F9CB40C2-08E4-4B7B-8726-D4E15A02819F}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(DPCodeReviewSolutionGUID) = preSolution
+		DPCodeReviewSolutionGUID = {00000000-0000-0000-0000-000000000000}
+	EndGlobalSection
+EndGlobal
