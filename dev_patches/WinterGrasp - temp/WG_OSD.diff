# HG changeset patch
# User Aptiva@Aptiva-PC
# Date 1307825756 18000
# Node ID cdfe675ad96b7ea087a89ac5dee066172e734563
# Parent  1014d6336f88d3ba2311ab7cf545a87ec6bce76b
Core/WinterGrasp: Implemented outdoorpvp_wg system into core

diff -r 1014d6336f88 -r cdfe675ad96b .hgtags
--- a/.hgtags	Fri Jun 10 22:03:11 2011 -0500
+++ b/.hgtags	Sat Jun 11 15:55:56 2011 -0500
@@ -1,1 +1,2 @@
 3425c17e79c63a6d59b748ccb472a85ae96db058 tip to rev.11762
+1014d6336f88d3ba2311ab7cf545a87ec6bce76b Implementation of Armory
diff -r 1014d6336f88 -r cdfe675ad96b sql/updates/OSDSQL/Characters_auth/Characters_OutdoorPvPWG.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/TaintedSQL/Characters_auth/Characters_OutdoorPvPWG.sql	Sat Jun 11 15:55:56 2011 -0500
@@ -0,0 +1,6 @@
+/*WorldStates Characters DB*/
+DELETE FROM worldstates WHERE entry IN (31001,31002,31003,31004);
+INSERT INTO `worldstates` VALUES ('31001', '0', 'WG war status');
+INSERT INTO `worldstates` VALUES ('31002', '0', 'WG clock');
+INSERT INTO `worldstates` VALUES ('31003', '0', 'WG Fortress Defender');
+INSERT INTO `worldstates` VALUES ('31004', '0', 'WG TEMP Battle Control Faction');
\ No newline at end of file
diff -r 1014d6336f88 -r cdfe675ad96b sql/updates/OSDSQL/World/World_OutdoorPvP_WG.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/TaintedSQL/World/World_OutdoorPvP_WG.sql	Sat Jun 11 15:55:56 2011 -0500
@@ -0,0 +1,334 @@
+/*NOTE! Included Cyrillic Fonts - open it in UTF8 coding*/
+
+SET NAMES 'utf8';
+
+DELETE FROM `trinity_string` WHERE entry IN (756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,780,781,782,783);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES
+('756', 'Battle begins!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'Битва началась'),
+('757', '%s has successfully defended the fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s успешно защитил(а) крепость!'),
+('758', '%s has taken over the fortress!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s захватил(а) крепость'),
+('759', 'The %s siege workshop has been damaged by the %s!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('760', 'The %s siege workshop has been destroyed by the %s!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('761', 'The %s tower has been damaged!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s башня повреждена'),
+('762', 'The %s tower has been destroyed!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, '%s башня уничтожена!'),
+('763', 'Wintergrasp fortress is under attack!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('764', 'Wintergrasp is now under the control of the %s.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('765', 'Wintergrasp timer set to %s.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('766', 'Wintergrasp battle started.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('767', 'Wintergrasp battle finished.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('768', 'Wintergrasp info: %s controlled. Timer: %s. Wartime: %s. Number of Players: (Horde: %u, Alliance: %u)', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('769', 'Wintergrasp outdoorPvP is disabled.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('770', 'Wintergrasp outdoorPvP is enabled.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('771', 'You have reached Rank 1: Corporal', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'Вы достигли Ранга 1: Капрал'),
+('772', 'You have reached Rank 2: First Lieutenant', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'Вы достигли Ранга 2: Лейтенант'),
+('780', 'Before the Battle of  Wintergrasp left 30 minutes!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'До битвы на  Озере Ледяных Оков осталось 30 минут!'),
+('781', 'Before the Battle of  Wintergrasp left 10 minutes! Portal from Dalaran will work at begin of the battle.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'До битвы на  Озере Ледяных Оков осталось 10 минут! Портал с Даларана начнет работу во время боя.'),
+('782', 'The battle for Wintergrasp  has stopped! Not enough defenders. Wintergrasp Fortress remains  Attackers.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'Битва за Озеро Ледяных Оков Остановлена. Не хватает защитников. Крепость переходит атакующей  стороне.'),
+('783', 'The battle for Wintergrasp  has stopped! Not enough attackers. Wintergrasp Fortress remains  Defenders.', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'Битва за Озеро Ледяных Оков Остановлена. Не хватает нападающих. Крепость остается защитникам.');
+
+DELETE FROM `command` WHERE name IN ('wg','wg enable','wg start','wg status','wg stop','wg switch','wg timer');
+INSERT INTO `command` (`name`, `security`, `help`) VALUES
+('wg', '3', 'Syntax: .wg $subcommand.'),
+('wg enable', '3', 'Syntax: .wg enable [on/off] Enable/Disable Wintergrasp outdoorPvP.'),
+('wg start', '3', 'Syntax: .wg start\r\nForce Wintergrasp battle start.'),
+('wg status', '3', 'Syntax: .wg status\r\nWintergrasp info, defender, timer, wartime.'),
+('wg stop', '3', 'Syntax: .wg stop\r\nForce Wintergrasp battle stop (No rewards).'),
+('wg switch', '3', 'Syntax: .wg switch\r\nSwitchs Wintergrasp defender team.'),
+('wg timer', '3', 'Syntax: .wg timer $minutes\r\nChange the current timer. Min value = 1, Max value 60 (Wartime), 1440 (Not Wartime)');
+
+/* WG scriptname */
+DELETE FROM `outdoorpvp_template` WHERE TypeId=7;
+INSERT INTO `outdoorpvp_template` (`TypeId`, `ScriptName`, `comment`) VALUES 
+('7', 'outdoorpvp_wg', 'Wintergrasp');
+
+UPDATE `creature_template` SET `ScriptName` = 'npc_demolisher_engineerer' WHERE `entry` IN (30400,30499);
+
+/* Teleport WG SPELLs*/
+DELETE FROM `spell_target_position` WHERE id IN ('59096', '58632', '58633');
+INSERT INTO `spell_target_position` (`id`, `target_map`, `target_position_x`, `target_position_y`, `target_position_z`, `target_orientation`) VALUES
+('59096', '571', '5325.06', '2843.36', '409.285', '3.20278'),
+('58632', '571', '5097.79', '2180.29', '365.61', '2.41'),
+('58633', '571', '5026.80', '3676.69', '362.58', '3.94');
+
+/* Defender's Portal Activate Proper Spell */
+DELETE FROM `spell_linked_spell` WHERE spell_trigger=54640;
+INSERT INTO `spell_linked_spell` (`spell_trigger`, `spell_effect`, `type`, `comment`) VALUES 
+('54640','54643','0','Defender\'s Portal Activate Proper Spell');
+
+/* Protect players from catching by Druid Cyclone at graveyard which removes immunity after disappear */
+DELETE FROM `spell_linked_spell` WHERE spell_trigger=58729;
+INSERT INTO `spell_linked_spell` VALUES (58729, -33786, 2, 'Spiritual Immunity: Protect From Cyclone (now Immune always)');
+
+/* Temp removed gameobject stopping you getting to the relic
+* 194323 - [Wintergrasp Keep Collision Wall X:5396.209961 Y:2840.010010 Z:432.268005 MapId:571
+* 194162 - [Doodad_WG_Keep_Door01_collision01 X:5397.109863 Y:2841.540039 Z:425.901001 MapId:571]*/
+DELETE FROM gameobject WHERE id IN ('194323', '194162');
+
+/* Titan Relic remove */
+DELETE FROM `gameobject` WHERE `id`=192829;
+
+/* Towers */
+UPDATE `gameobject_template` SET `faction` = 0, `flags` = 6553632 WHERE `entry` IN (190356,190357,190358);
+
+/*Spirit healer FIX */
+UPDATE creature_template SET npcflag=npcflag|32768 WHERE entry IN (31841,31842);
+
+/* Creature template */
+UPDATE creature_template SET faction_A = '1802', faction_H = '1802' WHERE entry IN (30499,28312,28319);
+UPDATE creature_template SET faction_A = '1801', faction_H = '1801' WHERE entry IN (30400,32629,32627);
+UPDATE creature_template SET npcflag=npcflag|32768 WHERE entry   IN (31841,31842);
+
+/* spell target for build vehicles */
+DELETE FROM `conditions` WHERE ConditionValue2=27852;
+INSERT INTO `conditions` (`SourceTypeOrReferenceId`, `SourceGroup`, `SourceEntry`, `ElseGroup`, `ConditionTypeOrReference`, `ConditionValue1`, `ConditionValue2`, `ConditionValue3`, `ErrorTextId`, `ScriptName`, `Comment`) VALUES
+(13, 0, 49899, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56575, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56661, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56663, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56665, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56667, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 56669, 0, 18, 1, 27852, 0, 0, '', NULL),
+(13, 0, 61408, 0, 18, 1, 27852, 0, 0, '', NULL);
+
+/* Workshop */
+UPDATE `gameobject_template` SET `faction` = 35 WHERE `entry` IN (192028,192029,192030,192031,192032,192033);
+
+/*WG Spell area Data */
+/*For wg antifly */
+DELETE FROM `spell_area` WHERE spell IN (58730, 57940, 58045);
+INSERT INTO `spell_area` (`spell`, `area`, `quest_start`, `quest_start_active`, `quest_end`, `aura_spell`, `racemask`, `gender`, `autocast`) VALUES
+(58730, 4197, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4584, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4581, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4585, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4612, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4582, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4611, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4578, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4576, 0, 0, 0, 0, 0, 2, 1),
+(58730, 4538, 0, 0, 0, 0, 0, 2, 1),
+(57940, 65, 0, 0, 0, 0, 0, 2, 1),
+(57940, 66, 0, 0, 0, 0, 0, 2, 1),
+(57940, 67, 0, 0, 0, 0, 0, 2, 1),
+(57940, 206, 0, 0, 0, 0, 0, 2, 1),
+(57940, 210, 0, 0, 0, 0, 0, 2, 1),
+(57940, 394, 0, 0, 0, 0, 0, 2, 1),
+(57940, 395, 0, 0, 0, 0, 0, 2, 1),
+(57940, 1196, 0, 0, 0, 0, 0, 2, 1),
+(57940, 2817, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3456, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3477, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3537, 0, 0, 0, 0, 0, 2, 1),
+(57940, 3711, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4100, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4196, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4228, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4264, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4265, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4272, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4273, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4395, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4415, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4416, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4493, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4494, 0, 0, 0, 0, 0, 2, 1),
+(57940, 4603, 0, 0, 0, 0, 0, 2, 1),
+(58045, 4197, 0, 0, 0, 0, 0, 2, 1);
+
+/* Portal Dalaran->WG */
+DELETE FROM `gameobject` WHERE `id`=193772;
+INSERT INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+('', 193772, 571, 1, 64, 5924.11, 573.387, 661.087, 4.43208, 0, 0, 0.798953, -0.601393, 300, 0, 1),
+('', 193772, 571, 1, 65535, 5686.57, 772.921, 647.754, 5.62225, 0, 0, 0.324484, -0.945891, 600, 0, 1),
+('', 193772, 571, 1, 65535, 5930.82, 548.961, 640.632, 1.88506, 0, 0, 0.809047, 0.587744, 300, 0, 1);
+
+
+/* Wintergrasp Battle-Mage */
+DELETE FROM `creature` WHERE `id`=32170;
+INSERT INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`DeathState`,`MovementType`,`npcflag`,`unit_flags`,`dynamicflags`) VALUES
+('', 32170, 571, 1, 65535, 27801, 0, 5925.34, 573.71, 661.087, 4.06662, 300, 0, 0, 504000, 440700, 0, 0, 0, 0, 0),
+('', 32170, 571, 1, 64, 0, 918, 5932.96, 549.906, 641.595, 2.09189, 300, 0, 0, 504000, 440700, 0, 0, 0, 0, 0);
+UPDATE `creature_template` SET `ScriptName`='npc_wg_ally_battle_mage' WHERE `entry`=32169;
+UPDATE `creature_template` SET `ScriptName`='npc_wg_horde_battle_mage' WHERE `entry`=32170;
+
+UPDATE `gameobject_template` SET `type` = 6, `faction` = 0, `data2` = 10, `data3` = 54643, `ScriptName` = 'go_wg_veh_teleporter' WHERE `entry` = 192951;
+
+DELETE FROM gameobject WHERE 
+       id IN (192317,192335,192313,192316,192332,192331,192330,192329,192487,192310,192314,192308,192309,192324,192326,192312,192325,192304,187433,193984,193983,192377,192321,192318,192322,192320,192269,192273,192274,192277,192278,192280,192283,192284,192285,192289,192290,192336,192338,192339,192349,192350,192351,192352,192353,192354,192355,192356,192357,192358,192359,192360,192361,192362,192363,192364,192366,192367,192368,192369,192370,192371,192372,192373,192374,192375,192378,192379,192406,192407,192414,192416,192417,192418,192429,192433,192434,192435,192458,192459,192460,192461,192488,192501,192254,192255,192688,192686,180398,193764,193762,192319,192287,192323,192305,192286,192334,192307,192306,192328,192252,192253,192292,192299,192327,192267,192449,192450) 
+          AND map=571;
+INSERT INTO `gameobject` VALUES ('', 192317, 571, 1, 385, 5363.39, 2781.28, 435.634, 1.58825, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192335, 571, 1, 385, 5363.72, 2763.25, 445.023, -1.54462, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192313, 571, 1, 1, 5392.65, 3037.11, 433.713, -1.52716, 0, 0, -0.691512, 0.722365, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192316, 571, 1, 385, 5322.01, 2781.13, 435.673, 1.57952, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192332, 571, 1, 1, 5289.46, 2704.68, 435.875, -0.017451, 0, 0, -0.00872539, 0.999962, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192331, 571, 1, 1, 5350.95, 2640.36, 435.408, 1.5708, 0, 0, 0.707108, 0.707106, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192330, 571, 1, 1, 5392.27, 2639.74, 435.331, 1.50971, 0, 0, 0.685183, 0.728371, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192329, 571, 1, 1, 5350.88, 2622.72, 444.686, -1.5708, 0, 0, -0.707108, 0.707106, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192487, 571, 1, 1, 5278.38, 2613.83, 432.721, -1.58825, 0, 0, -0.713251, 0.700909, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192487, 571, 1, 1, 5260.82, 2631.8, 433.324, 3.05433, 0, 0, 0.999048, 0.0436174, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192310, 571, 1, 1, 5271.8, 2704.87, 445.183, -3.13286, 0, 0, -0.99999, 0.00436634, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192314, 571, 1, 1, 5236.27, 2739.46, 444.992, -1.59698, 0, 0, -0.716303, 0.697789, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192487, 571, 1, 1, 5163.78, 2729.68, 432.009, -1.58825, 0, 0, -0.713251, 0.700909, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192308, 571, 1, 1, 5237.07, 2757.03, 435.796, 1.51844, 0, 0, 0.688356, 0.725373, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192309, 571, 1, 1, 5235.34, 2924.34, 435.04, -1.5708, 0, 0, -0.707108, 0.707106, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192487, 571, 1, 1, 5262.54, 3047.95, 430.979, 3.10665, 0, 0, 0.999847, 0.0174704, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192487, 571, 1, 1, 5163.13, 2952.59, 433.503, 1.53589, 0, 0, 0.694658, 0.71934, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192324, 571, 1, 1, 5235.19, 2942, 443.948, 1.58825, 0, 0, 0.713251, 0.700909, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192326, 571, 1, 1, 5272.73, 2976.55, 443.81, 3.12412, 0, 0, 0.999962, 0.00873622, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192312, 571, 1, 1, 5352.37, 3037.09, 435.252, -1.5708, 0, 0, -0.707108, 0.707106, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192325, 571, 1, 1, 5290.35, 2976.56, 435.221, 0.017452, 0, 0, 0.00872589, 0.999962, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192304, 571, 1, 385, 5397.76, 2873.08, 455.321, 3.10665, 0, 0, 0.999847, 0.0174704, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 187433, 571, 1, 1, 2832.84, 6184.45, 84.6827, -2.58308, 0, 0, 0, 0, 300, 100, 1);
+INSERT INTO `gameobject` VALUES ('', 187433, 571, 1, 1, 2835.96, 6180.37, 84.6827, 1.50098, 0, 0, 0, 0, 180, 100, 1);
+INSERT INTO `gameobject` VALUES ('', 187433, 571, 1, 1, 2830.12, 6188.96, 84.6827, -0.855211, 0, 0, 0, 0, 300, 100, 1);
+INSERT INTO `gameobject` VALUES ('', 187433, 571, 1, 1, 2831.88, 6188.72, 84.6827, -1.65806, 0, 0, 0, 0, 300, 100, 1);
+INSERT INTO `gameobject` VALUES ('', 193984, 571, 1, 1, 7647.47, 2055.55, 599.399, -0.279252, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 193984, 571, 1, 1, 7647.42, 2065.23, 599.308, 0.279252, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 193984, 571, 1, 1, 7609.86, 2055.53, 599.494, -2.86234, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 193984, 571, 1, 1, 7610.18, 2065.31, 599.426, 2.87979, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 193983, 571, 1, 1, 7906.95, 2053.04, 599.626, -0.296705, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 193983, 571, 1, 1, 7907.01, 2063.02, 599.587, 0.261798, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 193983, 571, 1, 1, 7870.43, 2053.35, 599.669, -2.87979, 0, 0, 0, 0, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 193983, 571, 1, 1, 7870.36, 2063.25, 599.628, 2.86234, 0, 0, 0, 0, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192377, 571, 1, 1, 5414.19, 3069.8, 415.187, 1.64061, 0, 0, 0, 0, 5, 100, 1);
+INSERT INTO `gameobject` VALUES ('', 192321, 571, 1, 385, 5288.85, 2861.82, 435.591, 0.026179, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192318, 571, 1, 385, 5322.25, 2898.95, 435.643, -1.57952, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192322, 571, 1, 385, 5322.89, 2917.14, 445.154, 1.56207, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192320, 571, 1, 385, 5289.05, 2820.23, 435.674, 0, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192269, 571, 1, 1, 4526.46, 2810.18, 391.2, -2.99322, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192273, 571, 1, 1, 4417.94, 2324.81, 371.577, 3.08051, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192274, 571, 1, 1, 4424.15, 3286.54, 371.546, 3.12412, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192277, 571, 1, 1, 4572.93, 3475.52, 363.009, 1.42244, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192278, 571, 1, 1, 4433.9, 3534.14, 360.275, -1.85005, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192280, 571, 1, 1, 4857.97, 3335.44, 368.881, -2.94959, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192283, 571, 1, 1, 5006.34, 3280.4, 371.163, 2.22529, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192284, 571, 1, 65, 5372.48, 2862.5, 409.049, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192285, 571, 1, 65, 5371.49, 2820.8, 409.177, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192289, 571, 1, 1, 4778.19, 2438.06, 345.644, -2.94088, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192290, 571, 1, 1, 5024.57, 2532.75, 344.023, -1.93732, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192336, 571, 1, 1, 5154.49, 2862.15, 445.012, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192338, 571, 1, 65, 5397.76, 2873.08, 455.461, 3.10665, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192339, 571, 1, 65, 5397.39, 2809.33, 455.344, 3.10665, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192349, 571, 1, 1, 5155.31, 2820.74, 444.979, -3.13286, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192350, 571, 1, 1, 5270.69, 2861.78, 445.058, -3.11539, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192351, 571, 1, 1, 5271.28, 2820.16, 445.201, -3.13286, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192352, 571, 1, 1, 5173.02, 2820.93, 435.72, 0.017452, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192353, 571, 1, 1, 5172.11, 2862.57, 435.721, 0.017452, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192354, 571, 1, 1, 5288.41, 2861.79, 435.721, 0.017452, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192355, 571, 1, 1, 5288.92, 2820.22, 435.721, 0.017452, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192356, 571, 1, 1, 5237.07, 2757.03, 435.796, 1.51844, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192357, 571, 1, 1, 5235.34, 2924.34, 435.04, -1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192358, 571, 1, 65, 5322.23, 2899.43, 435.808, -1.58825, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192359, 571, 1, 65, 5364.35, 2899.4, 435.839, -1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192360, 571, 1, 65, 5352.37, 3037.09, 435.252, -1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192361, 571, 1, 65, 5392.65, 3037.11, 433.713, -1.52716, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192362, 571, 1, 65, 5322.12, 2763.61, 444.974, -1.55334, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192363, 571, 1, 65, 5363.61, 2763.39, 445.024, -1.54462, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192364, 571, 1, 1, 5350.88, 2622.72, 444.686, -1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192366, 571, 1, 1, 5236.27, 2739.46, 444.992, -1.59698, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192367, 571, 1, 1, 5271.8, 2704.87, 445.183, -3.13286, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192368, 571, 1, 65, 5289.46, 2704.68, 435.875, -0.017451, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192369, 571, 1, 1, 5350.95, 2640.36, 435.408, 1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192370, 571, 1, 1, 5392.27, 2639.74, 435.331, 1.50971, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192371, 571, 1, 65, 5364.29, 2916.94, 445.331, 1.57952, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192372, 571, 1, 65, 5322.86, 2916.95, 445.154, 1.56207, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192373, 571, 1, 1, 5290.35, 2976.56, 435.221, 0.017452, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192374, 571, 1, 1, 5272.94, 2976.55, 444.492, 3.12412, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192375, 571, 1, 1, 5235.19, 2941.9, 444.278, 1.58825, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192378, 571, 1, 65, 5322.02, 2781.13, 435.811, 1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192379, 571, 1, 65, 5363.42, 2781.03, 435.763, 1.5708, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192406, 571, 1, 1, 4438.3, 3361.08, 371.568, -0.017451, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192407, 571, 1, 1, 4448.17, 3235.63, 370.412, -1.56207, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192414, 571, 1, 1, 4387.62, 2719.57, 389.935, -1.54462, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192416, 571, 1, 1, 4408.57, 2422.61, 377.179, 1.58825, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192417, 571, 1, 1, 4416.59, 2414.08, 377.196, 0, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192418, 571, 1, 1, 4417.25, 2301.14, 377.214, 0.026179, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192429, 571, 1, 1, 4464.12, 2855.45, 406.111, 0.829032, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192433, 571, 1, 1, 4401.63, 3377.46, 363.365, 1.55334, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192434, 571, 1, 1, 5041.61, 3294.4, 382.15, -1.63188, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192435, 571, 1, 1, 4855.63, 3297.62, 376.739, -3.13286, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192458, 571, 1, 1, 4811.4, 2441.9, 358.207, -2.0333, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192459, 571, 1, 1, 4805.67, 2407.48, 358.191, 1.78023, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192460, 571, 1, 1, 5004.35, 2486.36, 358.449, 2.17294, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192461, 571, 1, 1, 4983.28, 2503.09, 358.177, -0.427603, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 1, 5160.34, 2798.61, 430.769, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 1, 5158.81, 2883.13, 431.618, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 1, 5278.38, 2613.83, 433.409, -1.58825, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 1, 5260.82, 2631.8, 433.324, 3.05433, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 1, 5163.13, 2952.59, 433.503, 1.53589, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 1, 5145.11, 2935, 433.386, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 1, 5262.54, 3047.95, 432.055, 3.10665, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 1, 5146.04, 2747.21, 433.584, 3.07177, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 1, 5163.78, 2729.68, 433.394, -1.58825, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192501, 571, 1, 1, 4398.82, 2804.7, 429.792, -1.58825, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192501, 571, 1, 1, 4416, 2822.67, 429.851, -0.017452, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192501, 571, 1, 1, 4559.11, 3606.22, 419.999, -1.48353, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192501, 571, 1, 1, 4539.42, 3622.49, 420.034, -3.07177, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192501, 571, 1, 1, 4555.26, 3641.65, 419.974, 1.67551, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192501, 571, 1, 1, 4574.87, 3625.91, 420.079, 0.087266, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192501, 571, 1, 1, 4466.79, 1960.42, 459.144, 1.15192, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192501, 571, 1, 1, 4475.35, 1937.03, 459.07, -0.436332, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192501, 571, 1, 1, 4451.76, 1928.1, 459.076, -2.00713, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192501, 571, 1, 1, 4442.99, 1951.9, 459.093, 2.74016, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192254, 571, 1, 1, 5154.46, 2828.94, 409.189, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192255, 571, 1, 1, 5154.52, 2853.31, 409.183, 3.14159, 0, 0, 0, 1, 180, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192688, 571, 1, 1, 5916.1, 566.209, 639.625, -2.72271, 0, 0, 0, 1, 180, 100, 1);
+INSERT INTO `gameobject` VALUES ('', 192686, 571, 1, 1, 5664.81, 791.002, 653.698, -0.663223, 0, 0, 0, 1, 180, 100, 1);
+INSERT INTO `gameobject` VALUES ('', 180398, 571, 1, 1, 5665.02, 790.2, 653.698, -0.610864, 0, 0, 0, 1, 180, 100, 1);
+INSERT INTO `gameobject` VALUES ('', 192487, 571, 1, 256, 4855.63, 3297.62, 376.281, -3.13286, 0, 0, -0.99999, 0.00436634, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192290, 571, 1, 256, 4526.46, 2810.18, 391.2, -2.99322, 0, 0, -0.997249, 0.0741182, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192487, 571, 1, 256, 4517.75, 2717.23, 387.812, -1.53589, 0, 0, -0.694658, 0.71934, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 256, 4475.35, 1937.03, 459.07, -0.436332, 0, 0, -0.216439, 0.976296, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 256, 4451.76, 1928.1, 459.076, -2.00713, 0, 0, -0.843392, 0.537299, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 256, 4442.99, 1951.9, 459.093, 2.74016, 0, 0, 0.979924, 0.199371, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 256, 4466.8, 1960.44, 459.841, 1.15192, 0, 0, 0.54464, 0.83867, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192487, 571, 1, 256, 5041.61, 3294.4, 382.15, -1.63188, 0, 0, -0.72837, 0.685184, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192278, 571, 1, 256, 5006.34, 3280.4, 371.163, 2.22529, 0, 0, 0.896872, 0.442291, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192278, 571, 1, 256, 4857.97, 3335.44, 368.881, -2.94959, 0, 0, -0.995395, 0.0958539, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192290, 571, 1, 256, 4433.9, 3534.14, 360.275, -1.85005, 0, 0, -0.798636, 0.601815, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192290, 571, 1, 256, 4572.93, 3475.52, 363.009, 1.42244, 0, 0, 0.652758, 0.757566, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 256, 4555.26, 3641.65, 419.974, 1.67551, 0, 0, 0.743143, 0.669133, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 256, 4574.87, 3625.91, 420.079, 0.087266, 0, 0, 0.0436192, 0.999048, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 256, 4559.11, 3606.22, 419.999, -1.48353, 0, 0, -0.67559, 0.737277, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 256, 4539.42, 3622.49, 420.034, -3.07177, 0, 0, -0.999391, 0.0349043, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192290, 571, 1, 256, 4401.63, 3377.46, 363.365, 1.55334, 0, 0, 0.700908, 0.713252, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 256, 4448.17, 3235.63, 370.412, -1.56207, 0, 0, -0.704015, 0.710185, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192488, 571, 1, 256, 4438.3, 3361.08, 371.299, -0.017451, 0, 0, -0.00872539, 0.999962, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192290, 571, 1, 256, 4424.15, 3286.54, 371.546, 3.12412, 0, 0, 0.999962, 0.00873622, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192461, 571, 1, 1, 4416.03, 2822.68, 430.475, -0.017452, 0, 0, -0.00872589, 0.999962, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192461, 571, 1, 1, 4464.12, 2855.45, 406.111, 0.829032, 0, 0, 0.402747, 0.915311, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192461, 571, 1, 1, 4398.82, 2804.7, 429.792, -1.58825, 0, 0, -0.713251, 0.700909, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192461, 571, 1, 1, 4408.57, 2422.61, 377.179, 1.58825, 0, 0, 0.713251, 0.700909, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192461, 571, 1, 1, 4416.59, 2414.08, 377.13, 0, 0, 0, 0, 1, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192461, 571, 1, 1, 4417.25, 2301.14, 377.214, 0.026179, 0, 0, 0.0130891, 0.999914, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192418, 571, 1, 1, 4805.67, 2407.48, 358.191, 1.78023, 0, 0, 0.777144, 0.629323, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192418, 571, 1, 1, 4811.4, 2441.9, 358.207, -2.0333, 0, 0, -0.85035, 0.526218, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192273, 571, 1, 1, 4778.19, 2438.06, 345.644, -2.94088, 0, 0, -0.994969, 0.100188, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192273, 571, 1, 1, 5024.57, 2532.75, 344.023, -1.93732, 0, 0, -0.824127, 0.566404, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192418, 571, 1, 1, 5004.35, 2486.36, 358.449, 2.17294, 0, 0, 0.884989, 0.465612, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192418, 571, 1, 1, 4983.28, 2503.09, 358.177, -0.427603, 0, 0, -0.212176, 0.977231, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 192290, 571, 1, 1, 4417.94, 2324.81, 371.577, 3.08051, 0, 0, 0.999534, 0.0305366, 300, 0, 1);
+INSERT INTO `gameobject` VALUES ('', 193764, 571, 1, 1, 7625.87, 2060.05, 604.27, 0.07854, 0, 0, 0.99999, 0.004363, 180, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 193762, 571, 1, 1, 7625.66, 2060.04, 604.195, -3.05428, 0, 0, 0.99999, 0.004363, 180, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192319, 571, 1, 385, 5364.3, 2899.22, 435.691, -1.55334, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192287, 571, 1, 385, 5372.42, 2862.48, 409.366, 3.14159, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192323, 571, 1, 385, 5364.28, 2917.26, 445.332, 1.58825, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192305, 571, 1, 385, 5397.31, 2809.26, 455.102, 3.13286, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192286, 571, 1, 385, 5371.45, 2820.79, 409.427, 3.12412, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192334, 571, 1, 385, 5322.17, 2763.2, 444.974, -1.56207, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192307, 571, 1, 385, 5271.16, 2820.11, 445.109, -3.13286, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192306, 571, 1, 385, 5270.56, 2861.68, 444.917, -3.12412, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192487, 571, 1, 385, 5160.28, 2798.6, 430.604, -3.12412, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192487, 571, 1, 385, 5146.04, 2747.3, 433.527, 3.12412, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192328, 571, 1, 385, 5173.13, 2820.96, 435.658, 0.026179, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192252, 571, 1, 385, 5154.37, 2853.23, 409.183, 3.14159, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192253, 571, 1, 385, 5154.42, 2828.93, 409.189, 3.14159, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192292, 571, 1, 385, 5154.35, 2862.08, 445.01, 3.14159, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192299, 571, 1, 385, 5155.22, 2820.63, 444.979, -3.11539, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192327, 571, 1, 385, 5172.34, 2862.57, 435.658, 0, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192487, 571, 1, 385, 5158.71, 2882.9, 431.274, 3.14159, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192487, 571, 1, 385, 5145.11, 2934.95, 433.255, -3.10665, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192267, 571, 1, 385, 4452.76, 2639.14, 358.444, 1.67552, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192449, 571, 1, 385, 4517.75, 2717.23, 387.812, -1.53589, 0, 0, 0, 1, 300, 255, 1);
+INSERT INTO `gameobject` VALUES ('', 192450, 571, 1, 385, 4387.59, 2719.9, 390.201, -1.51843, 0, 0, 0, 1, 300, 255, 1);
+
diff -r 1014d6336f88 -r cdfe675ad96b sql/updates/TaintedSQL/World/World_QuestFix_Eye_of_Achrus.sql
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sql/updates/OSDSQL/World/World_QuestFix_Eye_of_Achrus.sql	Sat Jun 11 15:55:56 2011 -0500
@@ -0,0 +1,34 @@
+-- correct movements for eye of achrus (quest = id 12641) -death comes from high
+-- commenting out any template changes,,, Templates are set by blizzard. no touching.
+
+-- UPDATE creature_template SET modelid1 = 16925, modelid2 = 16925, scale = 2, flags_extra = 0 WHERE entry IN (28525,28542,28543,28544);
+-- UPDATE quest_template SET ReqSpellCast1 = 51859, ReqSpellCast2 = 51859, ReqSpellCast3 = 51859, ReqSpellCast4 = 51859 WHERE entry = 12641;
+-- UPDATE creature_template SET minlevel = 55, maxlevel = 55, Armor_mod = 9730, Speed_walk = 3, Speed_run = 6.48571 WHERE entry = 28511;
+
+UPDATE creature SET phaseMask = 2 WHERE guid IN 
+(128627,128628,128629,128630,128631,128632,128633,128634,128635,128636,128637,128643,128644,128645,128646,
+128647,128648,128649,128650,128651,128652,128653,128654,128655,128656,128657,128658,128659,128660,128661,
+128662,128663,128664,128665,128666,128667,128668,128669,128670,128671,128672,128673,128674,128675,128676,
+128677,128678,128679,128680,128681,128682,128683,128684,128685,128687,128688,128689,128690,128691,128692,
+128693,128694,128695,128696,128698,128699,128700,128701,128702,128705,128706,128707,128708,128709,128710,
+128711,128712,128713,128714,128715,128716,128717,128718,128719,128720,128721,128722,128723,128724,128725,
+128726,128727,128728,128729,128730,128731,128732,128733,128734,128735,128736,128737,128752,128796,128797,
+128798,128799,128800,128801,128802,128958,129165,129168,129169,129170,129171,129474,129475,129476,129477,
+129478,129479,129483,129484,129485,129486,129487,129488,129489,129490,129491);
+
+UPDATE gameobject SET phaseMask = 3 WHERE guid IN (65961,65962,65963,65964,65965,65966);
+UPDATE creature SET phaseMask = 3 WHERE guid = 128738;
+
+-- script_text
+DELETE FROM `script_texts` WHERE `npc_entry` = 28511;
+INSERT  INTO `script_texts`(`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+('28511','-1666451',"The eye of Acherus moves toward it'\s target.",'0','0','0','0','0','0','0','0','0','0','0',"The eye of Acherus moves toward it'\s target.",'TEXT_EYE_LAUNCHED');
+
+INSERT  INTO `script_texts`(`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
+('28511','-1666452',"The eye of Acherus subject of your control.",'0','0','0','0','0','0','0','0','0','0','0',"The eye of Acherus subject of your control.",'TEXT_EYE_UNDER_CONTROL');
+
+-- waypoint
+insert  into `waypoints`(`entry`,`pointid`,`position_x`,`position_y`,`position_z`,`point_comment`) values (28511,1,1750.83,-5873.79,147.227,'Eye_of_the_Archus');
+
+-- ScriptName
+UPDATE `creature_template` SET `ScriptName` = 'npc_eye_of_acherus' WHERE `entry` = '28511';
diff -r 1014d6336f88 -r cdfe675ad96b sql/updates/TaintedSQL/eye_of_archus_movement_fix.sql
--- a/sql/updates/OSDSQL/eye_of_archus_movement_fix.sql	Fri Jun 10 22:03:11 2011 -0500
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,31 +0,0 @@
-UPDATE creature_template SET modelid1 = 16925, modelid2 = 16925, scale = 2, flags_extra = 0 WHERE entry IN (28525,28542,28543,28544);
-UPDATE quest_template SET ReqSpellCast1 = 51859, ReqSpellCast2 = 51859, ReqSpellCast3 = 51859, ReqSpellCast4 = 51859 WHERE entry = 12641;
-
-UPDATE creature SET phaseMask = 2 WHERE guid IN 
-(128627,128628,128629,128630,128631,128632,128633,128634,128635,128636,128637,128643,128644,128645,128646,
-128647,128648,128649,128650,128651,128652,128653,128654,128655,128656,128657,128658,128659,128660,128661,
-128662,128663,128664,128665,128666,128667,128668,128669,128670,128671,128672,128673,128674,128675,128676,
-128677,128678,128679,128680,128681,128682,128683,128684,128685,128687,128688,128689,128690,128691,128692,
-128693,128694,128695,128696,128698,128699,128700,128701,128702,128705,128706,128707,128708,128709,128710,
-128711,128712,128713,128714,128715,128716,128717,128718,128719,128720,128721,128722,128723,128724,128725,
-128726,128727,128728,128729,128730,128731,128732,128733,128734,128735,128736,128737,128752,128796,128797,
-128798,128799,128800,128801,128802,128958,129165,129168,129169,129170,129171,129474,129475,129476,129477,
-129478,129479,129483,129484,129485,129486,129487,129488,129489,129490,129491);
-
-UPDATE gameobject SET phaseMask = 3 WHERE guid IN (65961,65962,65963,65964,65965,65966);
-UPDATE creature_template SET minlevel = 55, maxlevel = 55, Armor_mod = 9730, Speed_walk = 3, Speed_run = 6.48571 WHERE entry = 28511;
-UPDATE creature SET phaseMask = 3 WHERE guid = 128738;
-
--- script_text
-DELETE FROM `script_texts` WHERE `npc_entry` = 28511;
-INSERT  INTO `script_texts`(`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
-('28511','-1666451',"The eye of Acherus moves toward it'\s target.",'0','0','0','0','0','0','0','0','0','0','0',"The eye of Acherus moves toward it'\s target.",'TEXT_EYE_LAUNCHED');
-
-INSERT  INTO `script_texts`(`npc_entry`,`entry`,`content_default`,`content_loc1`,`content_loc2`,`content_loc3`,`content_loc4`,`content_loc5`,`content_loc6`,`content_loc7`,`content_loc8`,`sound`,`type`,`language`,`emote`,`comment`) VALUES
-('28511','-1666452',"The eye of Acherus subject of your control.",'0','0','0','0','0','0','0','0','0','0','0',"The eye of Acherus subject of your control.",'TEXT_EYE_UNDER_CONTROL');
-
--- waypoint
-insert  into `waypoints`(`entry`,`pointid`,`position_x`,`position_y`,`position_z`,`point_comment`) values (28511,1,1750.83,-5873.79,147.227,'Eye_of_the_Archus');
-
--- ScriptName
-UPDATE `creature_template` SET `ScriptName` = 'npc_eye_of_acherus' WHERE `entry` = '28511';
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/CMakeLists.txt
--- a/src/server/game/CMakeLists.txt	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/CMakeLists.txt	Sat Jun 11 15:55:56 2011 -0500
@@ -190,6 +190,7 @@
   ${CMAKE_CURRENT_SOURCE_DIR}/Weather
   ${CMAKE_CURRENT_SOURCE_DIR}/World
   ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP  
   ${ACE_INCLUDE_DIR}
   ${MYSQL_INCLUDE_DIR}
   ${OPENSSL_INCLUDE_DIR}
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/Chat/Chat.cpp
--- a/src/server/game/Chat/Chat.cpp	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/Chat/Chat.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -328,6 +328,17 @@
         { NULL,             0,                  false, NULL,                                                "", NULL }
     };
 
+    static ChatCommand wintergraspCommandTable[] =
+    {
+        { "status",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspStatusCommand>,       "", NULL },
+        { "enable",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspEnableCommand>,       "", NULL },
+        { "start",          SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspStartCommand>,        "", NULL },
+        { "stop",           SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspStopCommand>,         "", NULL },
+        { "switch",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspSwitchTeamCommand>,   "", NULL },
+        { "timer",          SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleWintergraspTimerCommand>,        "", NULL },
+        { NULL,             0,                  false, NULL,                                               "", NULL }
+    };
+	
     static ChatCommand commandTable[] =
     {
         { "character",      SEC_GAMEMASTER,     true,  NULL,                                           "", characterCommandTable},
@@ -414,7 +425,8 @@
         { "bindsight",      SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleBindSightCommand>,           "", NULL },
         { "unbindsight",    SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleUnbindSightCommand>,         "", NULL },
         { "playall",        SEC_GAMEMASTER,  false, OldHandler<&ChatHandler::HandlePlayAllCommand>,             "", NULL },
-        { NULL,             0,                  false, NULL,                                           "", NULL }
+        { "wg",             SEC_ADMINISTRATOR,  false, NULL,                                 "", wintergraspCommandTable },        
+		{ NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
     // cache for commands, needed because some commands are loaded dynamically through ScriptMgr
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/Chat/Chat.h
--- a/src/server/game/Chat/Chat.h	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/Chat/Chat.h	Sat Jun 11 15:55:56 2011 -0500
@@ -357,6 +357,14 @@
         bool HandleUnBanHelper(BanMode mode, char const* args);
         void HandleCharacterLevel(Player* player, uint64 player_guid, uint32 oldlevel, uint32 newlevel);
         void HandleLearnSkillRecipesHelper(Player* player, uint32 skill_id);
+ 
+        //Wintergrasp
+        bool HandleWintergraspStatusCommand(const char *args);
+        bool HandleWintergraspStartCommand(const char *args);
+        bool HandleWintergraspStopCommand(const char *args);
+        bool HandleWintergraspEnableCommand(const char *args);
+        bool HandleWintergraspSwitchTeamCommand(const char *args);
+        bool HandleWintergraspTimerCommand(const char *args);
 
         // Stores informations about a deleted character
         struct DeletedInfo
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/Chat/Commands/Level2.cpp
--- a/src/server/game/Chat/Commands/Level2.cpp	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/Chat/Commands/Level2.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -42,6 +42,7 @@
 #include "Transport.h"
 #include "TargetedMovementGenerator.h"                      // for HandleNpcUnFollowCommand
 #include "CreatureGroups.h"
+#include "OutdoorPvPWG.h"
 
 //mute player for some times
 bool ChatHandler::HandleMuteCommand(const char* args)
@@ -936,6 +937,151 @@
     return true;
 }
 
+bool ChatHandler::HandleWintergraspStatusCommand(const char* /*args*/)
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+   if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    PSendSysMessage(LANG_BG_WG_STATUS, sObjectMgr->GetTrinityStringForDBCLocale(
+        pvpWG->getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE),
+        secsToTimeString(pvpWG->GetTimer(), true).c_str(),
+        pvpWG->isWarTime() ? "Yes" : "No",
+        pvpWG->GetNumPlayersH(),
+        pvpWG->GetNumPlayersA());
+    return true;
+}
+
+bool ChatHandler::HandleWintergraspStartCommand(const char* /*args*/)
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+    pvpWG->forceStartBattle();
+    PSendSysMessage(LANG_BG_WG_BATTLE_FORCE_START);
+    return true;
+}
+
+bool ChatHandler::HandleWintergraspStopCommand(const char* /*args*/)
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+    pvpWG->forceStopBattle();
+    PSendSysMessage(LANG_BG_WG_BATTLE_FORCE_STOP);
+    return true;
+}
+
+bool ChatHandler::HandleWintergraspEnableCommand(const char* args)
+{
+    if(!*args)
+        return false;
+
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG || !sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if (!strncmp(args, "on", 3))
+    {
+        if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        {
+            pvpWG->forceStopBattle();
+            sWorld->setBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED, true);
+        }
+        PSendSysMessage(LANG_BG_WG_ENABLE);
+        return true;
+    }
+    else if (!strncmp(args, "off", 4))
+    {
+        if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        {
+            pvpWG->forceStopBattle();
+            sWorld->setBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED, false);
+        }
+        PSendSysMessage(LANG_BG_WG_DISABLE);
+        return true;
+    }
+    else
+    {
+        SendSysMessage(LANG_USE_BOL);
+        SetSentErrorMessage(true);
+        return false;
+    }
+}
+
+bool ChatHandler::HandleWintergraspTimerCommand(const char* args)
+{
+    if(!*args)
+        return false;
+
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG)
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    int32 time = atoi (args);
+
+    // Min value 1 min
+    if (1 > time)
+        time = 1;
+    // Max value during wartime = 60. No wartime = 1440 (day)
+    if (pvpWG->isWarTime())
+    {
+        if (60 < time)
+            return false;
+    }
+    else
+        if (1440 < time)
+            return false;
+    time *= MINUTE * IN_MILLISECONDS;
+
+    pvpWG->setTimer((uint32)time);
+    sWorld->SendWintergraspState(); //Update WG time at bg tab
+    PSendSysMessage(LANG_BG_WG_CHANGE_TIMER, secsToTimeString(pvpWG->GetTimer(), true).c_str());
+    return true;
+}
+
+bool ChatHandler::HandleWintergraspSwitchTeamCommand(const char* /*args*/)
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+
+    if (!pvpWG)
+    {
+        SendSysMessage(LANG_BG_WG_DISABLE);
+        SetSentErrorMessage(true);
+        return false;
+    }
+    uint32 timer = pvpWG->GetTimer();
+    pvpWG->forceChangeTeam();
+    pvpWG->setTimer(timer);
+    PSendSysMessage(LANG_BG_WG_SWITCH_FACTION, GetTrinityString(pvpWG->getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+    return true;
+}
+
 bool ChatHandler::HandleLookupTitleCommand(const char* args)
 {
     if (!*args)
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/Entities/GameObject/GameObject.cpp
--- a/src/server/game/Entities/GameObject/GameObject.cpp	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/Entities/GameObject/GameObject.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -452,6 +452,11 @@
                         if (goInfo->trap.spellId)
                             CastSpell(ok, goInfo->trap.spellId);
 
+							// allow to use scripts
+                        if (ok->GetTypeId() == TYPEID_PLAYER)
+                            if (sScriptMgr->OnGossipHello(ok->ToPlayer(), this))
+                                return;
+
                         m_cooldownTime = time(NULL) + (goInfo->trap.cooldown ? goInfo->trap.cooldown :  uint32(4));   // template or 4 seconds
 
                         if (goInfo->trap.type == 1)
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/Entities/Vehicle/Vehicle.cpp
--- a/src/server/game/Entities/Vehicle/Vehicle.cpp	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/Entities/Vehicle/Vehicle.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -538,3 +538,29 @@
 
     return ret;
 }
+
+void Vehicle::Relocate(Position pos)
+{
+    sLog->outDebug(LOG_FILTER_VEHICLES, "Vehicle::Relocate %u", me->GetEntry());
+
+    std::set<Unit*> vehiclePlayers;
+    for (int8 i = 0; i < 8; i++)
+        vehiclePlayers.insert(GetPassenger(i));
+
+    // passengers should be removed or they will have movement stuck
+    RemoveAllPassengers();
+
+    for (std::set<Unit*>::const_iterator itr = vehiclePlayers.begin(); itr != vehiclePlayers.end(); ++itr)
+    {
+        if (Unit* plr = (*itr))
+        {
+            // relocate/setposition doesn't work for player
+            plr->NearTeleportTo(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation());
+            //plr->TeleportTo(pPlayer->GetMapId(), triggerPos.GetPositionX(), triggerPos.GetPositionY(), triggerPos.GetPositionZ(), triggerPos.GetOrientation(), TELE_TO_NOT_LEAVE_COMBAT);
+        }
+    }
+
+    me->SetPosition(pos, true);
+    // problems, and impossible to do delayed enter
+    //pPlayer->EnterVehicle(veh);
+}
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/Entities/Vehicle/Vehicle.h
--- a/src/server/game/Entities/Vehicle/Vehicle.h	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/Entities/Vehicle/Vehicle.h	Sat Jun 11 15:55:56 2011 -0500
@@ -23,6 +23,7 @@
 
 struct VehicleEntry;
 struct VehicleSeatEntry;
+struct Position;
 class Unit;
 
 enum PowerType
@@ -137,6 +138,7 @@
         void RelocatePassengers(float x, float y, float z, float ang);
         void RemoveAllPassengers();
         void Dismiss();
+        void Relocate(Position pos);        
         bool IsVehicleInUse() { return m_Seats.begin() != m_Seats.end(); }
 
         SeatMap m_Seats;
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/Miscellaneous/Language.h
--- a/src/server/game/Miscellaneous/Language.h	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/Miscellaneous/Language.h	Sat Jun 11 15:55:56 2011 -0500
@@ -700,6 +700,28 @@
 //  LANG_BG_WS_START_TWO_MINUTES        = 753, - defined above
 //  LANG_BG_AB_START_TWO_MINUTES        = 754, - defined above
 //  LANG_BG_EY_START_TWO_MINUTES        = 755, - defined above
+    LANG_BG_WG_BATTLE_STARTS            = 756,
+    LANG_BG_WG_DEFENDED                 = 757,
+    LANG_BG_WG_CAPTURED                 = 758,
+    LANG_BG_WG_WORKSHOP_DAMAGED         = 759,
+    LANG_BG_WG_WORKSHOP_DESTROYED       = 760,
+    LANG_BG_WG_TOWER_DAMAGED            = 761,
+    LANG_BG_WG_TOWER_DESTROYED          = 762,
+    LANG_BG_WG_FORTRESS_UNDER_ATTACK    = 763,
+    LANG_BG_WG_SWITCH_FACTION           = 764,
+    LANG_BG_WG_CHANGE_TIMER             = 765,
+    LANG_BG_WG_BATTLE_FORCE_START       = 766,
+    LANG_BG_WG_BATTLE_FORCE_STOP        = 767,
+    LANG_BG_WG_STATUS                   = 768,
+    LANG_BG_WG_DISABLE                  = 769,
+    LANG_BG_WG_ENABLE                   = 770,
+    LANG_BG_WG_RANK1                    = 771,
+    LANG_BG_WG_RANK2                    = 772,
+
+    LANG_BG_WG_WORLD_ANNOUNCE_30        = 780,
+    LANG_BG_WG_WORLD_ANNOUNCE_10        = 781,
+    LANG_BG_WG_WORLD_NO_DEF             = 782,
+    LANG_BG_WG_WORLD_NO_ATK             = 783,
 
     // Room for BG/ARENA                = 773-784, 788-799 not used
     LANG_ARENA_TESTING                  = 785,
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/OutdoorPvP/OutdoorPvP.h
--- a/src/server/game/OutdoorPvP/OutdoorPvP.h	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/OutdoorPvP/OutdoorPvP.h	Sat Jun 11 15:55:56 2011 -0500
@@ -32,9 +32,10 @@
     OUTDOOR_PVP_ZM = 4,
     OUTDOOR_PVP_SI = 5,
     OUTDOOR_PVP_EP = 6,
+    OUTDOOR_PVP_WG = 7
 };
 
-#define MAX_OUTDOORPVP_TYPES 7
+#define MAX_OUTDOORPVP_TYPES 8
 
 enum ObjectiveStates
 {
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/Server/Protocol/Handlers/BattleGroundHandler.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -36,6 +36,9 @@
 #include "DisableMgr.h"
 #include "Group.h"
 
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
+
 void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket & recv_data)
 {
     uint64 guid;
@@ -600,6 +603,15 @@
 
     if (bg)
         sBattlegroundMgr->SendAreaSpiritHealerQueryOpcode(_player, bg, guid);
+	else
+    {  // Wintergrasp Hack till 3.3.5 and it's implemented as BG
+        if (GetPlayer()->GetZoneId() == 4197)
+        {
+            OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+            if (pvpWG && pvpWG->isWarTime())
+                pvpWG->SendAreaSpiritHealerQueryOpcode(_player, guid);
+        }
+    }
 }
 
 void WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket & recv_data)
@@ -620,6 +632,15 @@
 
     if (bg)
         bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
+	else
+    {  // Wintergrasp Hack till 3.3.5 and it's implemented as BG
+        if (GetPlayer()->GetZoneId() == 4197)
+        {
+            OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+            if (pvpWG && pvpWG->isWarTime())
+                pvpWG->AddPlayerToResurrectQueue(guid, _player->GetGUID());
+        }
+    }
 }
 
 void WorldSession::HandleBattlemasterJoinArena(WorldPacket & recv_data)
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
--- a/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -43,6 +43,9 @@
 #include "ScriptMgr.h"
 #include "Battleground.h"
 
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
+
 class LoginQueryHolder : public SQLQueryHolder
 {
     private:
@@ -821,6 +824,24 @@
     sObjectAccessor->AddObject(pCurrChar);
     //sLog->outDebug("Player %s added to Map.", pCurrChar->GetName());
 
+    //Send WG timer to player at login 
+	if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+	{
+	    if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+	    {
+            if (pvpWG->isWarTime())
+            {
+                // "Battle in progress"
+                pCurrChar->SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL)));
+            } else
+                // Time to next battle
+            {
+                pvpWG->SendInitWorldStatesTo(pCurrChar);
+                pCurrChar->SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL) + pvpWG->GetTimer()));
+            }
+	    }
+	}
+	
     pCurrChar->SendInitialPacketsAfterAddToMap();
 
     CharacterDatabase.PExecute("UPDATE characters SET online = 1 WHERE guid = '%u'", pCurrChar->GetGUIDLow());
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/Spells/Auras/SpellAuraEffects.cpp
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -6030,6 +6030,7 @@
                             target->CastSpell((Unit*)NULL, GetAmount(), true, NULL, this);
                             break;
                         case 58600: // Restricted Flight Area
+                        case 58730: // Restricted Flight Area						
                             if (aurApp->GetRemoveMode() == AURA_REMOVE_BY_EXPIRE)
                                 target->CastSpell(target, 58601, true);
                             break;
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/Spells/Spell.cpp
--- a/src/server/game/Spells/Spell.cpp	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/Spells/Spell.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -53,6 +53,9 @@
 #include "SpellScript.h"
 #include "InstanceScript.h"
 
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
+
 #define SPELL_CHANNEL_UPDATE_INTERVAL (1 * IN_MILLISECONDS)
 
 extern pEffect SpellEffects[TOTAL_SPELL_EFFECTS];
@@ -5462,8 +5465,17 @@
                 if (m_originalCaster && m_originalCaster->GetTypeId() == TYPEID_PLAYER && m_originalCaster->isAlive())
                 {
                     if (AreaTableEntry const* pArea = GetAreaEntryByAreaID(m_originalCaster->GetAreaId()))
+                    {
                         if (pArea->flags & AREA_FLAG_NO_FLY_ZONE)
-                            return m_IsTriggeredSpell ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
+                        return m_IsTriggeredSpell ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
+
+                        if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                        {
+                            OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+                            if (m_originalCaster->GetZoneId() == 4197 && pvpWG && pvpWG != 0  && pvpWG->isWarTime())
+                                return m_IsTriggeredSpell ? SPELL_FAILED_DONT_REPORT : SPELL_FAILED_NOT_HERE;
+                        }
+                    }
                 }
                 break;
             }
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/Spells/SpellEffects.cpp
--- a/src/server/game/Spells/SpellEffects.cpp	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/Spells/SpellEffects.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -48,6 +48,7 @@
 #include "BattlegroundEY.h"
 #include "BattlegroundWS.h"
 #include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
 #include "Language.h"
 #include "SocialMgr.h"
 #include "Util.h"
@@ -4335,7 +4336,27 @@
         {
             switch(m_spellInfo->Id)
             {
-                // Glyph of Backstab
+                //Teleport to Lake Wintergrasp
+                case 58622:
+                {
+                    if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+                    {
+                        if (unitTarget->getLevel() > 74)
+                        {
+                            if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == ALLIANCE))
+                                unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_FORTRESS, true);
+                            else if ((pvpWG->getDefenderTeam()==TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == HORDE))
+                                unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_HORDE_CAMP, true);
+
+                            if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == HORDE))
+                                unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_FORTRESS, true);
+                            else if ((pvpWG->getDefenderTeam()!=TEAM_ALLIANCE) && (unitTarget->ToPlayer()->GetTeam() == ALLIANCE))
+                                unitTarget->CastSpell(unitTarget, SPELL_TELEPORT_ALLIENCE_CAMP, true);
+                        }
+                    }
+                    return;
+                }                
+				// Glyph of Backstab
                 case 63975:
                 {
                     if (AuraEffect const * aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x00100000, 0, 0, m_caster->GetGUID()))
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/Spells/SpellMgr.cpp
--- a/src/server/game/Spells/SpellMgr.cpp	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/Spells/SpellMgr.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -28,6 +28,8 @@
 #include "CreatureAI.h"
 #include "MapManager.h"
 #include "BattlegroundIC.h"
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
 
 bool IsAreaEffectTarget[TOTAL_SPELL_TARGETS];
 SpellEffectTargetTypes EffectTargetType[TOTAL_SPELL_EFFECTS];
@@ -3105,7 +3107,27 @@
                     return false;
                 break;
             }
-        case SPELL_OIL_REFINERY: // Oil Refinery - Isle of Conquest.
+        case 58730: // No fly Zone - Wintergrasp
+            {
+                if (!player)
+                    return false;
+
+                if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                {
+                    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+                    if ((pvpWG->isWarTime()==false) || player->isDead() || (!player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) && !player->HasAuraType(SPELL_AURA_FLY)) || player->HasAura(45472) || player->HasAura(44795) || player->GetPositionZ() > 619.2f || player->isInFlight())
+                        return false;
+                }
+                break;
+            }
+        case 58045: // Essence of Wintergrasp - Wintergrasp
+        case 57940: // Essence of Wintergrasp - Northrend
+            {
+                if (!player || player->GetTeamId() != sWorld->getWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION))
+                    return false;
+                break;
+            }        
+		case SPELL_OIL_REFINERY: // Oil Refinery - Isle of Conquest.
         case SPELL_QUARRY: // Quarry - Isle of Conquest.
             {
                 if (player->GetBattlegroundTypeId() != BATTLEGROUND_IC || !player->GetBattleground())
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/World/World.cpp
--- a/src/server/game/World/World.cpp	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/World/World.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -51,6 +51,7 @@
 #include "CreatureAIRegistry.h"
 #include "BattlegroundMgr.h"
 #include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
 #include "TemporarySummon.h"
 #include "WaypointMovementGenerator.h"
 #include "VMapFactory.h"
@@ -1184,6 +1185,23 @@
     // MySQL ping time interval
     m_int_configs[CONFIG_DB_PING_INTERVAL] = sConfig->GetIntDefault("MaxPingTime", 30);
 
+    //Wintergrasp
+    m_bool_configs[CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED]         = sConfig->GetBoolDefault("OutdoorPvP.Wintergrasp.Enabled", true);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD] = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.SaveState.Period", 10000);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME]       = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.StartTime", 30);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME]      = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.BattleTime", 30);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL]         = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.Interval", 150);
+    m_bool_configs[CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR]    = sConfig->GetBoolDefault("OutdoorPvP.Wintergrasp.CustomHonorRewards", false);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE]       = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorBattleWin", 3000);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE]      = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorBattleLose", 1250);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER]    = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorDamageTower", 750);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER]  = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower", 750);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING] = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding", 750);
+    m_int_configs[CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING]  = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding", 1500);
+    m_bool_configs[CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE]  = sConfig->GetBoolDefault("OutdoorPvP.Wintergrasp.Antifarm.Enable", false);
+    m_int_configs[CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK]  = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.Antifarm.Atk", 5);
+    m_int_configs[CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF]  = sConfig->GetIntDefault("OutdoorPvP.Wintergrasp.Antifarm.Def", 5);
+	
     sScriptMgr->OnConfigLoad(reload);
 }
 
@@ -2840,3 +2858,29 @@
         }
     }
 }
+
+void World::SendWintergraspState()
+{
+    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+    if (!pvpWG)
+        return;
+
+    for (SessionMap::const_iterator itr = m_sessions.begin(); itr != m_sessions.end(); ++itr)
+    {
+        if (!itr->second || !itr->second->GetPlayer() || !itr->second->GetPlayer()->IsInWorld())
+            continue;
+
+            if (pvpWG->isWarTime())
+            {
+                // "Battle in progress"
+                itr->second->GetPlayer()->SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL)));
+            } else
+                // Time to next battle
+            {
+                pvpWG->SendInitWorldStatesTo(itr->second->GetPlayer());
+                itr->second->GetPlayer()->SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL) + pvpWG->GetTimer()));
+                // Hide unneeded info which in center of screen
+                itr->second->GetPlayer()->SendInitWorldStates(itr->second->GetPlayer()->GetZoneId(), itr->second->GetPlayer()->GetAreaId());
+            }
+    }
+}
\ No newline at end of file
diff -r 1014d6336f88 -r cdfe675ad96b src/server/game/World/World.h
--- a/src/server/game/World/World.h	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/game/World/World.h	Sat Jun 11 15:55:56 2011 -0500
@@ -158,7 +158,10 @@
     CONFIG_ALLOW_TICKETS,
     CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES,
     CONFIG_PRESERVE_CUSTOM_CHANNELS,
-    BOOL_CONFIG_VALUE_COUNT
+    CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED,
+    CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR,
+    CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE,    
+	BOOL_CONFIG_VALUE_COUNT
 };
 
 enum WorldFloatConfigs
@@ -306,7 +309,19 @@
     CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION,
     CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS,
     CONFIG_MAX_INSTANCES_PER_HOUR,
-    INT_CONFIG_VALUE_COUNT
+    CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME,
+    CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME,
+    CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL,
+    CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE,
+    CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE,
+    CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER,
+    CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER,
+    CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING,
+    CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING,
+    CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD,
+    CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK,
+    CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF,    
+	INT_CONFIG_VALUE_COUNT
 };
 
 /// Server rates
@@ -730,6 +745,18 @@
 
         bool isEventKillStart;
 
+        // Wintergrasp
+        uint32 GetWintergrapsTimer() { return m_WintergrapsTimer; }
+        uint32 GetWintergrapsState() { return m_WintergrapsState; }
+        uint32 m_WintergrapsTimer;
+        uint32 m_WintergrapsState;
+        void SendWintergraspState();
+        void SetWintergrapsTimer(uint32 timer, uint32 state)
+        {
+            m_WintergrapsTimer = timer;
+            m_WintergrapsState = state;
+        }
+		
         uint32 GetCleaningFlags() const { return m_CleaningFlags; }
         void   SetCleaningFlags(uint32 flags) { m_CleaningFlags = flags; }
     protected:
diff -r 1014d6336f88 -r cdfe675ad96b src/server/scripts/CMakeLists.txt
--- a/src/server/scripts/CMakeLists.txt	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/scripts/CMakeLists.txt	Sat Jun 11 15:55:56 2011 -0500
@@ -123,6 +123,7 @@
   ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
   ${CMAKE_SOURCE_DIR}/src/server/game/Opcodes
   ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/OutdoorPvP  
   ${CMAKE_SOURCE_DIR}/src/server/game/Pools
   ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
   ${CMAKE_SOURCE_DIR}/src/server/game/Quests
diff -r 1014d6336f88 -r cdfe675ad96b src/server/scripts/Northrend/CMakeLists.txt
--- a/src/server/scripts/Northrend/CMakeLists.txt	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/scripts/Northrend/CMakeLists.txt	Sat Jun 11 15:55:56 2011 -0500
@@ -191,6 +191,7 @@
   Northrend/DraktharonKeep/drak_tharon_keep.h
   Northrend/DraktharonKeep/boss_tharon_ja.cpp
   Northrend/DraktharonKeep/boss_dred.cpp
+  Northrend/wintergrasp.cpp
 )
 
 message("  -> Prepared: Northrend")
diff -r 1014d6336f88 -r cdfe675ad96b src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp
--- a/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/scripts/Northrend/VaultOfArchavon/instance_vault_of_archavon.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -18,6 +18,9 @@
 #include "ScriptPCH.h"
 #include "vault_of_archavon.h"
 
+#include "OutdoorPvPMgr.h"
+#include "OutdoorPvPWG.h"
+
 /* Vault of Archavon encounters:
 1 - Archavon the Stone Watcher event
 2 - Emalon the Storm Watcher event
@@ -43,6 +46,16 @@
                 ToravonGUID = 0;
             }
 
+            void OnPlayerEnter(Player *m_player)
+            {
+                if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                {
+                    OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197);
+                    if (pvpWG && !m_player->isGameMaster() && m_player->GetTeamId() != pvpWG->getDefenderTeam())
+                        m_player->CastSpell(m_player, SPELL_TELEPORT_FORTRESS, true);
+                }
+            }
+			
             void OnCreatureCreate(Creature* creature)
             {
                 switch (creature->GetEntry())
diff -r 1014d6336f88 -r cdfe675ad96b src/server/scripts/Northrend/wintergrasp.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/scripts/Northrend/wintergrasp.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -0,0 +1,438 @@
+/*
+ * Copyright (C) 2008 - 2011 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2011 Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include "ScriptPCH.h"
+#include "OutdoorPvPWG.h"
+#include "OutdoorPvPMgr.h"
+
+#define GOSSIP_HELLO_DEMO1  "Build catapult."
+#define GOSSIP_HELLO_DEMO2  "Build demolisher."
+#define GOSSIP_HELLO_DEMO3  "Build siege engine."
+#define GOSSIP_HELLO_DEMO4  "I cannot build more!"
+
+class npc_demolisher_engineerer : public CreatureScript
+{
+public:
+    npc_demolisher_engineerer() : CreatureScript("npc_demolisher_engineerer") { }
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if (pCreature->isQuestGiver())
+        pPlayer->PrepareQuestMenu(pCreature->GetGUID());
+
+    if(pPlayer->isGameMaster() || pCreature->GetZoneScript() && pCreature->GetZoneScript()->GetData(pCreature->GetDBTableGUIDLow()))
+    {
+        if (pPlayer->HasAura(SPELL_CORPORAL))
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+        else if (pPlayer->HasAura(SPELL_LIEUTENANT))
+        {
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO2, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+1);
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO3, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+2);
+        }
+    }
+    else
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO4, GOSSIP_SENDER_MAIN,   GOSSIP_ACTION_INFO_DEF+9);
+
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    return true;
+}
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    if(pPlayer->isGameMaster() || pCreature->GetZoneScript() && pCreature->GetZoneScript()->GetData(pCreature->GetDBTableGUIDLow()))
+    {
+        switch(uiAction - GOSSIP_ACTION_INFO_DEF)
+        {
+            case 0: pPlayer->CastSpell(pPlayer, 56663, false, NULL, NULL, pCreature->GetGUID()); break;
+            case 1: pPlayer->CastSpell(pPlayer, 56575, false, NULL, NULL, pCreature->GetGUID()); break;
+            case 2: pPlayer->CastSpell(pPlayer, pPlayer->GetTeamId() ? 61408 : 56661, false, NULL, NULL, pCreature->GetGUID()); break;
+        }
+    }
+
+    return true;
+}
+
+    CreatureAI* GetAI(Creature* pCreature) const
+    {
+        return new npc_demolisher_engineererAI(pCreature);
+    }
+
+    struct npc_demolisher_engineererAI : public ScriptedAI
+    {
+        npc_demolisher_engineererAI(Creature* pCreature) : ScriptedAI(pCreature)
+        {
+            me->SetReactState(REACT_PASSIVE);
+        }
+    };
+
+};
+
+enum eWintergraspBattleMage
+{
+    SPELL_PORTAL_VISUAL        = 60223,
+    GO_WINTERGRASP_PORTAL    = 193772
+};
+
+class npc_wg_ally_battle_mage : public CreatureScript
+{
+public:
+    npc_wg_ally_battle_mage() : CreatureScript("npc_wg_ally_battle_mage") { }
+
+    CreatureAI *GetAI(Creature *creature) const
+    {
+        return new npc_wg_ally_battle_mageAI(creature);
+    }
+
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+            return false;
+
+        if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+        {
+            if (pvpWG->isWarTime())
+            {
+                if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                    pPlayer->SEND_GOSSIP_MENU(14777, pCreature->GetGUID());
+                else
+                    pPlayer->SEND_GOSSIP_MENU(14781, pCreature->GetGUID());
+            }
+            else
+            {
+                if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                    pPlayer->SEND_GOSSIP_MENU(14775, pCreature->GetGUID());
+                else
+                    pPlayer->SEND_GOSSIP_MENU(14782, pCreature->GetGUID());
+            }
+        }
+        return true;
+    }
+
+    struct npc_wg_ally_battle_mageAI : public ScriptedAI
+    {
+        npc_wg_ally_battle_mageAI(Creature* pCreature) : ScriptedAI(pCreature)
+        {
+            uiPortalTimer = 0;
+            uiPortalPhase = 0;
+            Check = true;
+        }
+
+        uint32 uiPortalTimer;
+        uint8 uiPortalPhase;
+        GameObject* WintergraspPortal;
+        bool Player;
+        bool Check;
+        bool Check2;
+
+        void UpdateAI(const uint32 diff)
+        {
+            // If WG is disabled, don't do anything.
+            if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                return;
+
+            if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+            {
+                // Get playerlist if there is.
+                if (pvpWG->isWarTime() && Check == true)
+                {
+                    Map::PlayerList const &PlayerList = me->GetMap()->GetPlayers();
+                    for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                    {
+                        if (!PlayerList.isEmpty())
+                        {
+                            if (i->getSource()->GetDistance2d(me) <= 75)
+                            {
+                                Player = true;
+                                Check = false;
+                            }
+                            else
+                            {
+                                Player = false;
+                                Check = false;
+                                Check2 = true;
+                            }
+                        }
+                        else
+                        {
+                            Player = false;
+                            Check = false;
+                            Check2 = true;
+                        }
+                    }
+                }
+
+                if (pvpWG->m_changeAlly != true) // If wg is switching (.wg switch)
+                {
+                    if (pvpWG->isWarTime())
+                    {
+                        if (Player == true) //(false) If there isn't any player, then, don't cast the portal spell. Just summon gameobject.
+                        {
+                            if (uiPortalTimer <= diff)
+                            {
+                                switch (uiPortalPhase)
+                                {
+                                case 0:
+                                    me->SetOrientation(4.037271f);
+                                    me->SendMovementFlagUpdate();
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 100;
+                                    break;
+                                case 1:
+                                    me->AI()->DoCast(SPELL_PORTAL_VISUAL);
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 900;
+                                    break;
+                                case 2:
+                                    WintergraspPortal = me->SummonGameObject(GO_WINTERGRASP_PORTAL, 5686.974609f, 773.303711f, 647.753235f, 5.572729f, 0, 0, 0.324484f, -0.945891f, 0);
+                                    me->SetOrientation(5.515240f);
+                                    me->SendMovementFlagUpdate();
+                                    me->MonsterYell("Reinforcements are needed on the Wintergrasp battlefield! I have opened a portal for quick travel to the battle at The Silver Enclave.", LANG_UNIVERSAL, 0);
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 1000;
+                                    break;
+                                }
+                            }else uiPortalTimer -= diff;
+                        }
+                        else
+                        {
+                            if (Check2 == true) // If the portal isn't exist
+                            {
+                                WintergraspPortal = me->SummonGameObject(GO_WINTERGRASP_PORTAL, 5686.974609f, 773.303711f, 647.753235f, 5.572729f, 0, 0, 0.324484f, -0.945891f, 0);
+                                Check2 = false;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (pvpWG->getDefenderTeam() == TEAM_ALLIANCE)
+                        {
+                            if (pvpWG->m_timer <= 3600000) // An hour before battle begin, the portal will disappear.
+                            {
+                                uiPortalTimer = 0;
+                                uiPortalPhase = 0;
+                                Check = true;
+                                Check2 = false;
+                                if (GameObject* WintergraspPortal = me->FindNearestGameObject(GO_WINTERGRASP_PORTAL, 5.0f)) // If the portal is exist
+                                    WintergraspPortal->RemoveFromWorld();
+                            }
+                        }
+                        else
+                        {
+                            uiPortalTimer = 0;
+                            uiPortalPhase = 0;
+                            Check = true;
+                            Check2 = false;
+                            if (GameObject* WintergraspPortal = me->FindNearestGameObject(GO_WINTERGRASP_PORTAL, 5.0f)) // If the portal is exist
+                                WintergraspPortal->RemoveFromWorld();
+                        }
+                    }
+                }
+            }
+        }
+    };
+};
+
+class npc_wg_horde_battle_mage : public CreatureScript
+{
+public:
+    npc_wg_horde_battle_mage() : CreatureScript("npc_wg_horde_battle_mage") { }
+
+    CreatureAI *GetAI(Creature *creature) const
+    {
+        return new npc_wg_horde_battle_mageAI(creature);
+    }
+
+    bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+            return false;
+
+        if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+        {
+            if (pvpWG->isWarTime())
+            {
+                if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                    pPlayer->SEND_GOSSIP_MENU(14777, pCreature->GetGUID());
+                else
+                    pPlayer->SEND_GOSSIP_MENU(14781, pCreature->GetGUID());
+            }
+            else
+            {
+                if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                    pPlayer->SEND_GOSSIP_MENU(14775, pCreature->GetGUID());
+                else
+                    pPlayer->SEND_GOSSIP_MENU(14782, pCreature->GetGUID());
+            }
+        }
+        return true;
+    }
+
+    struct npc_wg_horde_battle_mageAI : public ScriptedAI
+    {
+        npc_wg_horde_battle_mageAI(Creature* pCreature) : ScriptedAI(pCreature)
+        {
+            uiPortalTimer = 0;
+            uiPortalPhase = 0;
+            Check = true;
+        }
+
+        uint32 uiPortalTimer;
+        uint8 uiPortalPhase;
+        GameObject* WintergraspPortal;
+        bool Player;
+        bool Check;
+        bool Check2;
+
+        void UpdateAI(const uint32 diff)
+        {
+            // If WG is disabled, don't do anything.
+            if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+                return;
+
+            if (OutdoorPvPWG *pvpWG = (OutdoorPvPWG*)sOutdoorPvPMgr->GetOutdoorPvPToZoneId(4197))
+            {
+                // Get playerlist if there is.
+                if (pvpWG->isWarTime() && Check == true)
+                {
+                    Map::PlayerList const &PlayerList = me->GetMap()->GetPlayers();
+                    for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                    {
+                        if (!PlayerList.isEmpty())
+                        {
+                            if (i->getSource()->GetDistance2d(me) <= 75)
+                            {
+                                Player = true;
+                                Check = false;
+                            }
+                            else
+                            {
+                                Player = false;
+                                Check = false;
+                                Check2 = true;
+                            }
+                        }
+                        else
+                        {
+                            Player = false;
+                            Check = false;
+                            Check2 = true;
+                        }
+                    }
+                }
+
+                if (pvpWG->m_changeHorde != true) // If wg is switching (.wg switch)
+                {
+                    if (pvpWG->isWarTime())
+                    {
+                        if (Player == true) //(false) If there isn't any player, then, don't cast the portal spell. Just summon gameobject.
+                        {
+                            if (uiPortalTimer <= diff)
+                            {
+                                switch (uiPortalPhase)
+                                {
+                                case 0:
+                                    me->SetOrientation(4.356160f);
+                                    me->SendMovementFlagUpdate();
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 100;
+                                    break;
+                                case 1:
+                                    me->AI()->DoCast(SPELL_PORTAL_VISUAL);
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 900;
+                                    break;
+                                case 2:
+                                    WintergraspPortal = me->SummonGameObject(GO_WINTERGRASP_PORTAL, 5924.042969f, 570.354492f, 661.087280f, 5.930885f, 0, 0, 0.324484f, -0.945891f, 0);
+                                    me->SetOrientation(6.003930f);
+                                    me->SendMovementFlagUpdate();
+                                    ++uiPortalPhase;
+                                    uiPortalTimer = 1000;
+                                    break;
+                                }
+                            }else uiPortalTimer -= diff;
+                        }
+                        else
+                        {
+                            if (Check2 == true) // If the portal isn't exist
+                            {
+                                WintergraspPortal = me->SummonGameObject(GO_WINTERGRASP_PORTAL, 5686.974609f, 773.303711f, 647.753235f, 5.572729f, 0, 0, 0.324484f, -0.945891f, 0);
+                                Check2 = false;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (pvpWG->getDefenderTeam() == TEAM_HORDE)
+                        {
+                            if (pvpWG->m_timer <= 3600000) // An hour before battle begin, the portal will disappear.
+                            {
+                                uiPortalTimer = 0;
+                                uiPortalPhase = 0;
+                                Check = true;
+                                Check2 = false;
+                                if (GameObject* WintergraspPortal = me->FindNearestGameObject(GO_WINTERGRASP_PORTAL, 5.0f)) // If the portal is exist
+                                    WintergraspPortal->RemoveFromWorld();
+                            }
+                        }
+                        else
+                        {
+                            uiPortalTimer = 0;
+                            uiPortalPhase = 0;
+                            Check = true;
+                            Check2 = false;
+                            if (GameObject* WintergraspPortal = me->FindNearestGameObject(GO_WINTERGRASP_PORTAL, 5.0f)) // If the portal is exist
+                                WintergraspPortal->RemoveFromWorld();
+                        }
+                    }
+                }
+            }
+        }
+    };
+};
+
+class go_wg_veh_teleporter : public GameObjectScript
+{
+public:
+    go_wg_veh_teleporter() : GameObjectScript("go_wg_veh_teleporter") { }
+
+    bool OnGossipHello(Player *pPlayer, GameObject * pGO)
+    {
+        if (GameObject* trigger = pGO->FindNearestGameObject(190375, 500)) // Wintergrasp Fortress Gate
+            if (Vehicle * veh = pPlayer->GetVehicle())
+            {
+                Position triggerPos;
+                trigger->GetPosition(&triggerPos);
+                triggerPos.m_positionX -= 30;
+                veh->Relocate(triggerPos);
+            }
+        
+        return true;
+    }
+};
+
+void AddSC_wintergrasp()
+{
+    new npc_demolisher_engineerer();
+    new npc_wg_ally_battle_mage();
+    new npc_wg_horde_battle_mage();
+    new go_wg_veh_teleporter();
+}
\ No newline at end of file
diff -r 1014d6336f88 -r cdfe675ad96b src/server/scripts/OutdoorPvP/CMakeLists.txt
--- a/src/server/scripts/OutdoorPvP/CMakeLists.txt	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/scripts/OutdoorPvP/CMakeLists.txt	Sat Jun 11 15:55:56 2011 -0500
@@ -22,6 +22,8 @@
   OutdoorPvP/OutdoorPvPHP.h
   OutdoorPvP/OutdoorPvPZM.h
   OutdoorPvP/OutdoorPvPNA.h
+  OutdoorPvP/OutdoorPvPWG.cpp
+  OutdoorPvP/OutdoorPvPWG.h
 )
 
 message("  -> Prepared: Outdoor PVP Zones")
diff -r 1014d6336f88 -r cdfe675ad96b src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.cpp	Sat Jun 11 15:55:56 2011 -0500
@@ -0,0 +1,2194 @@
+/*
+ * Copyright (C) 2008 - 2011 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2011 Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "OutdoorPvP.h"
+#include "OutdoorPvPWG.h"
+#include "SpellAuras.h"
+#include "Vehicle.h"
+#include "ObjectMgr.h"
+#include "World.h"
+#include "Group.h"
+#include "Chat.h"
+#include "MapManager.h"
+#include "ScriptedCreature.h"
+#include "ScriptPCH.h"
+
+Creature* FortressSpirit;
+uint32 entry;
+uint32 guide_entry;
+uint32 guide_entry_fortress_horde;
+uint32 guide_entry_fortress_alliance;
+
+char const *fmtstring(char const *format, ...)
+{
+    va_list        argptr;
+    #define    MAX_FMT_STRING    32000
+    static char        temp_buffer[MAX_FMT_STRING];
+    static char        string[MAX_FMT_STRING];
+    static int        index = 0;
+    char    *buf;
+    int len;
+
+    va_start(argptr, format);
+    vsnprintf(temp_buffer,MAX_FMT_STRING, format, argptr);
+    va_end(argptr);
+
+    len = strlen(temp_buffer);
+
+    if (len >= MAX_FMT_STRING)
+        return "ERROR";
+
+    if (len + index >= MAX_FMT_STRING-1)
+    {
+        index = 0;
+    }
+
+    buf = &string[index];
+    memcpy(buf, temp_buffer, len+1);
+
+    index += len + 1;
+
+    return buf;
+}
+
+OutdoorPvPWG::OutdoorPvPWG()
+{
+    m_TypeId = OUTDOOR_PVP_WG; 
+    m_LastResurrectTime = 0; // Temporal copy of BG system till 3.2
+}
+
+void _LoadTeamPair(TeamPairMap &pairMap, const TeamPair *pair)
+{
+    while((*pair)[0])
+    {
+        pairMap[(*pair)[0]] = (*pair)[1];
+        pairMap[(*pair)[1]] = (*pair)[0];
+        ++pair;
+    }
+}
+
+void _RespawnCreatureIfNeeded(Creature *cr, uint32 entry)
+{
+    if (cr)
+    {
+        cr->UpdateEntry(entry); // SetOriginalEntry as used before may lead to crash
+        if (cr->GetAreaId() == 4575)
+            cr->AI()->EnterEvadeMode();
+        if (entry != cr->GetEntry() || !cr->isAlive())
+            cr->Respawn(true);
+        cr->SetVisible(true);
+    }
+}
+
+bool OutdoorPvPWG::SetupOutdoorPvP()
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+    {
+        sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+        return false;
+    }
+
+    //load worlstates
+    m_wartime  = sWorld->getWorldState(WORLDSTATE_WINTERGRASP_WARTIME) ? true : false;
+    m_timer    = uint32(sWorld->getWorldState(WORLDSTATE_WINTERGRASP_TIMER));
+    m_defender = TeamId(sWorld->getWorldState(WORLDSTATE_WINTERGRASP_DEFENDERS) ? true : false);
+    m_WSSaveTimer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+
+    if (m_timer == 0)
+       m_timer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_START_TIME) * MINUTE * IN_MILLISECONDS;
+
+    sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    m_changeDefender = false;
+    m_workshopCount[TEAM_ALLIANCE] = 0;
+    m_workshopCount[TEAM_HORDE] = 0;
+    m_tenacityStack = 0;
+    m_gate = NULL;
+
+    std::list<uint32> engGuids;
+    std::list<uint32> spiritGuids;
+
+    // Store Eng, spirit guide guids and questgiver for later use
+    QueryResult result = WorldDatabase.PQuery("SELECT guid, id FROM creature WHERE creature.map=571"
+        " AND creature.id IN (%u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u, %u);",
+        30499, 30400, 31842, 31841, 31101, 31051, 31102, 31052,
+        31107, 31109, 31151, 31153, 31106, 31108, 31053, 31054, 31091, 31036);
+    if (!result)
+        sLog->outError("Cannot find siege workshop master or spirit guides in creature!");
+    else
+    {
+        do
+        {
+            Position posHorde, posAlli;
+            Field *fields = result->Fetch();
+            switch(fields[1].GetUInt32())
+            {
+                case CRE_ENG_A:
+                case CRE_ENG_H:
+                    engGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case CRE_SPI_A:
+                case CRE_SPI_H:
+                    spiritGuids.push_back(fields[0].GetUInt32());
+                    break;
+                case 31051:
+                    posHorde.Relocate(5081.7f, 2173.73f, 365.878f, 0.855211f);
+                    posAlli.Relocate(5298.39f, 2890.56f, 409.191f, 5.602510f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31101:
+                    posHorde.Relocate(5296.56f, 2789.87f, 409.275f, 0.733038f);
+                    posAlli.Relocate(5016.57f, 3677.53f, 362.982f, 5.7525f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31052:
+                    posHorde.Relocate(5100.07f, 2168.89f, 365.779f, 1.97222f);
+                    posAlli.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31102:
+                    posHorde.Relocate(5298.43f, 2738.76f, 409.316f, 3.97174f);
+                    posAlli.Relocate(5030.44f, 3659.82f, 363.194f, 1.83336f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31109:
+                    posHorde.Relocate(5080.4f, 2199.0f, 359.489f, 2.96706f);
+                    posAlli.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31107:
+                    posHorde.Relocate(5234.97f, 2883.4f, 409.275f, 4.29351f);
+                    posAlli.Relocate(5008.64f, 3659.91f, 361.07f, 4.0796f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31153:
+                    posHorde.Relocate(5088.49f, 2188.18f, 365.647f, 5.25344f);
+                    posAlli.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31151:
+                    posHorde.Relocate(5366.13f, 2833.4f, 409.323f, 3.14159f);
+                    posAlli.Relocate(5032.33f, 3680.7f, 363.018f, 3.43167f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31108:
+                    posHorde.Relocate(5095.67f, 2193.28f, 365.924f, 4.93928f);
+                    posAlli.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31106:
+                    posHorde.Relocate(5295.56f, 2926.67f, 409.275f, 0.872665f);
+                    posAlli.Relocate(5032.66f, 3674.28f, 363.053f, 2.9447f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31054:
+                    posHorde.Relocate(5088.61f, 2167.66f, 365.689f, 0.680678f);
+                    posAlli.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31053:
+                    posHorde.Relocate(5371.4f, 3026.51f, 409.206f, 3.25003f);
+                    posAlli.Relocate(5032.44f, 3668.66f, 363.11f, 2.87402f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31036:
+                    posHorde.Relocate(5078.28f, 2183.7f, 365.029f, 1.46608f);
+                    posAlli.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                case 31091:
+                    posHorde.Relocate(5359.13f, 2837.99f, 409.364f, 4.69893f);
+                    posAlli.Relocate(5022.43f, 3659.91f, 361.61f, 1.35426f);
+                    LoadQuestGiverMap(fields[0].GetUInt32(), posHorde, posAlli);
+                    break;
+                default:
+                    break;
+            }
+        } while (result->NextRow());
+    }
+
+    // Select POI
+    AreaPOIList areaPOIs;
+    float minX = 9999, minY = 9999, maxX = -9999, maxY = -9999;
+    for (uint32 i = 0; i < sAreaPOIStore.GetNumRows(); ++i)
+    {
+        const AreaPOIEntry * poiInfo = sAreaPOIStore.LookupEntry(i);
+        if (poiInfo && poiInfo->zoneId == ZONE_WINTERGRASP)
+        {
+            areaPOIs.push_back(poiInfo);
+            if (minX > poiInfo->x) minX = poiInfo->x;
+            if (minY > poiInfo->y) minY = poiInfo->y;
+            if (maxX < poiInfo->x) maxX = poiInfo->x;
+            if (maxY < poiInfo->y) maxY = poiInfo->y;
+        }
+    }
+    minX -= 20; minY -= 20; maxX += 20; maxY += 20;
+
+    // Coords: 4290.330078, 1790.359985 - 5558.379883, 4048.889893
+    result = WorldDatabase.PQuery("SELECT guid FROM gameobject,gameobject_template"
+        " WHERE gameobject.map=571"
+        " AND gameobject.position_x>%f AND gameobject.position_y>%f"
+        " AND gameobject.position_x<%f AND gameobject.position_y<%f"
+        " AND gameobject_template.type=33"
+        " AND gameobject.id=gameobject_template.entry",
+        minX, minY, maxX, maxY);
+    if (!result)
+        return false;
+
+    do
+    {
+        Field *fields = result->Fetch();
+
+        uint32 guid = fields[0].GetUInt32();
+        GameObjectData const * goData = sObjectMgr->GetGOData(guid);
+        if (!goData) // this should not happen
+            continue;
+
+        float x = goData->posX, y = goData->posY;
+        float minDist = 100;
+        AreaPOIList::iterator poi = areaPOIs.end();
+        for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end(); ++itr)
+        {
+            if (!(*itr)->icon[1]) // note: may for other use
+                continue;
+
+            float dist = (abs((*itr)->x - x) + abs((*itr)->y - y));
+            if (minDist > dist)
+            {
+                minDist = dist;
+                poi = itr;
+            }
+        }
+
+        if (poi == areaPOIs.end())
+            continue;
+
+        // add building to the list
+        TeamId teamId = x > POS_X_CENTER-300 ? getDefenderTeam() : getAttackerTeam();
+        m_buildingStates[guid] = new BuildingState((*poi)->worldState, teamId, getDefenderTeam() != TEAM_ALLIANCE);
+        if ((*poi)->id == 2246)
+            m_gate = m_buildingStates[guid];
+        areaPOIs.erase(poi);
+
+        // add capture point
+        uint32 capturePointEntry = 0;
+
+        switch(goData->id)
+        {
+            //West Goblin Workshops
+            case 192028: // NW
+            case 192030: // W
+            case 192032: // SW
+                capturePointEntry = 190475;
+                break;
+            //East Goblin Workshops
+            case 192029: // NE
+            case 192031: // E
+            case 192033: // SE
+                capturePointEntry = 190487;
+                break;
+        }
+
+        if (capturePointEntry)
+        {
+            uint32 engGuid = 0;
+            uint32 spiritGuid = 0;
+            // Find closest Eng to Workshop
+            float minDist = 100;
+            for (std::list<uint32>::iterator itr = engGuids.begin(); itr != engGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr->GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    engGuid = *itr;
+                }
+            }
+
+            if (!engGuid)
+            {
+                sLog->outError("Cannot find nearby siege workshop master!");
+                continue;
+            }
+            else
+                engGuids.remove(engGuid);
+            // Find closest Spirit Guide to Workshop
+            minDist = 255;
+            for (std::list<uint32>::iterator itr = spiritGuids.begin(); itr != spiritGuids.end(); ++itr)
+            {
+                const CreatureData *creData = sObjectMgr->GetCreatureData(*itr);
+                if (!creData)
+                    continue;
+
+                float dist = (abs(creData->posX - x) + abs(creData->posY - y));
+                if (minDist > dist)
+                {
+                    minDist = dist;
+                    spiritGuid = *itr;
+                }
+            }
+
+            // Inside fortress won't be capturable
+            OPvPCapturePointWG *workshop = new OPvPCapturePointWG(this, m_buildingStates[guid]);
+            if (goData->posX < POS_X_CENTER && !workshop->SetCapturePointData(capturePointEntry, goData->mapid, goData->posX + 40 * cos(goData->orientation + M_PI / 2), goData->posY + 40 * sin(goData->orientation + M_PI / 2), goData->posZ))
+            {
+                delete workshop;
+                sLog->outError("Cannot add capture point!");
+                continue;
+            }
+            // West fortress Workshop fix
+            if(goData->id==192028 || goData->id==192029)
+                workshop->m_capturePointGUID = goData->id;
+
+            const CreatureData *creData = sObjectMgr->GetCreatureData(engGuid);
+            if (!creData)
+                continue;
+
+            workshop->m_engEntry = const_cast<uint32*>(&creData->id);
+            const_cast<CreatureData*>(creData)->displayid = 0;
+            workshop->m_engGuid = engGuid;
+
+            // Back spirit is linked to one of the inside workshops, 1 workshop wont have spirit
+            if (spiritGuid)
+            {
+                spiritGuids.remove(spiritGuid);
+
+                const CreatureData *spiritData = sObjectMgr->GetCreatureData(spiritGuid);
+                if (!spiritData)
+                    continue;
+
+                workshop->m_spiEntry = const_cast<uint32*>(&spiritData->id);
+                const_cast<CreatureData*>(spiritData)->displayid = 0;
+                workshop->m_spiGuid = spiritGuid;
+            }
+            else
+                workshop->m_spiGuid = 0;
+            workshop->m_workshopGuid = guid;
+            AddCapturePoint(workshop);
+            m_buildingStates[guid]->type = BUILDING_WORKSHOP;
+            workshop->SetTeamByBuildingState();
+        }
+    } while (result->NextRow());
+
+    engGuids.clear();
+    spiritGuids.clear();
+
+    if (!m_gate)
+    {
+        sLog->outError("Cannot find wintergrasp fortress gate!");
+        return false;
+    }
+
+    // Load Graveyard
+    GraveYardMap::const_iterator graveLow  = sObjectMgr->mGraveYardMap.lower_bound(ZONE_WINTERGRASP);
+    GraveYardMap::const_iterator graveUp   = sObjectMgr->mGraveYardMap.upper_bound(ZONE_WINTERGRASP);
+    for (AreaPOIList::iterator itr = areaPOIs.begin(); itr != areaPOIs.end();)
+    {
+        if ((*itr)->icon[1] == 8)
+        {
+            // find or create grave yard
+            const WorldSafeLocsEntry *loc = sObjectMgr->GetClosestGraveYard((*itr)->x, (*itr)->y, (*itr)->z, (*itr)->mapId, 0);
+            if (!loc)
+            {
+                ++itr;
+                continue;
+            }
+
+            GraveYardMap::const_iterator graveItr;
+            for (graveItr = graveLow; graveItr != graveUp; ++graveItr)
+                if (graveItr->second.safeLocId == loc->ID)
+                    break;
+            if (graveItr == graveUp)
+            {
+                GraveYardData graveData;
+                graveData.safeLocId = loc->ID;
+                graveData.team = 0;
+                graveItr = sObjectMgr->mGraveYardMap.insert(std::make_pair(ZONE_WINTERGRASP, graveData));
+            }
+
+            for (BuildingStateMap::iterator stateItr = m_buildingStates.begin(); stateItr != m_buildingStates.end(); ++stateItr)
+            {
+                if (stateItr->second->worldState == (*itr)->worldState)
+                {
+                    stateItr->second->graveTeam = const_cast<uint32*>(&graveItr->second.team);
+                    break;
+                }
+            }
+            areaPOIs.erase(itr++);
+        }
+        else
+            ++itr;
+    }
+
+    //Titan Relic
+    sObjectMgr->AddGOData(192829, 571, 5440.0f, 2840.8f, 420.43f + 10.0f, 0);
+
+    _LoadTeamPair(m_goDisplayPair, OutdoorPvPWGGODisplayPair);
+    _LoadTeamPair(m_creEntryPair, OutdoorPvPWGCreEntryPair);
+
+    sWorld->SendWintergraspState();
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+
+    RegisterZone(ZONE_WINTERGRASP);
+
+    if (m_wartime)
+    {
+        uint32 m_WSTimer = m_timer;
+        StartBattle();
+        m_timer = m_WSTimer;
+    }
+    else RemoveOfflinePlayerWGAuras();
+
+    return true;
+}
+
+void OutdoorPvPWG::ProcessEvent(GameObject *obj, uint32 eventId)
+{
+    if (obj->GetEntry() == 192829) // Titan Relic
+    {
+        if (obj->GetGOInfo()->goober.eventId == eventId && isWarTime() && /*MaingateDestroyed==true &&*/ m_gate &&  m_gate->damageState == DAMAGE_DESTROYED)
+        {
+            m_changeDefender = true;
+            m_timer = 0;
+        }
+    }
+    else if (obj->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(obj->GetDBTableGUIDLow());
+        if (itr == m_buildingStates.end())
+            return;
+        std::string msgStr;
+        switch(eventId)
+        { // TODO - Localized msgs of GO names
+            case 19672: case 19675: // Flamewatch Tower
+                msgStr = "Flamewatch";
+                break;
+            case 18553: case 19677: // Shadowsight Tower
+                msgStr = "Shadowsight";
+                break;
+            case 19673: case 19676: // Winter's Edge Tower
+                msgStr = "Winter's Edge";
+                break;
+            case 19776: case 19778: // E Workshop damaged
+                msgStr = "Sunken Ring";
+                break;
+            case 19777: case 19779: // W Workshop damaged
+                msgStr = "Broken Temple";
+                break;
+            case 19782: case 19786: // NW Workshop damaged
+                msgStr = "north-western";
+                break;
+            case 19783: case 19787: // NE Workshop damaged
+                msgStr = "north-eastern";
+                break;
+            case 19784: case 19788: // SW Workshop damaged
+                msgStr = "Westpark";
+                break;
+            case 19785: case 19789: // SE Workshop damaged
+                msgStr = "Eastpark";
+                break;
+            case 19657: case 19661: // NW Wintergrasp Keep Tower damaged
+                msgStr = "north-western";
+                break;
+            case 19658: case 19663: // NE Wintergrasp Keep Tower damaged
+                msgStr = "north-eastern";
+                break;
+            case 19659: case 19662: // SW Wintergrasp Keep Tower damaged
+                msgStr = "south-western";
+                break;
+            case 19660: case 19664: // SE Wintergrasp Keep Tower damaged
+                msgStr = "south-eastern";
+                break;
+            default:
+                msgStr = "";
+        }
+
+        BuildingState *state = itr->second;
+        if (eventId == obj->GetGOInfo()->building.damagedEvent)
+        {
+            state->damageState = DAMAGE_DAMAGED;
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                {
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DAMAGED), msgStr.c_str(), sObjectMgr->GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                }
+                    break;
+                case BUILDING_WALL:
+                {
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+                    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                }
+                    break;
+                case BUILDING_TOWER:
+                {
+                    ++m_towerDamagedCount[state->GetTeam()];
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DAMAGED), msgStr.c_str());
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                }
+                    break;
+            }
+        }
+        else if (eventId == obj->GetGOInfo()->building.destroyedEvent)
+        {
+            state->damageState = DAMAGE_DESTROYED;
+
+            switch(state->type)
+            {
+                case BUILDING_WORKSHOP:
+                {
+                    ModifyWorkshopCount(state->GetTeam(), false);
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_WORKSHOP_DESTROYED), msgStr.c_str(), sObjectMgr->GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE));
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                }
+                    break;
+                case BUILDING_WALL:
+                {
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_FORTRESS_UNDER_ATTACK));
+                    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+                    }
+                }
+                    break;
+                case BUILDING_TOWER:
+                {
+                     --m_towerDamagedCount[state->GetTeam()];
+                     ++m_towerDestroyedCount[state->GetTeam()];
+                     if (state->GetTeam() == getAttackerTeam())
+                     {
+                        TeamCastSpell(getAttackerTeam(), -SPELL_TOWER_CONTROL);
+                        TeamCastSpell(getDefenderTeam(), -SPELL_TOWER_CONTROL);
+                        uint32 attStack = 3 - m_towerDestroyedCount[getAttackerTeam()];
+                        if (m_towerDestroyedCount[getAttackerTeam()])
+                            for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                                if ((*itr)->getLevel() > 74)
+                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), m_towerDestroyedCount[getAttackerTeam()]);
+
+                        if (attStack!=0)
+                        {
+                            for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                                if ((*itr)->getLevel() > 74)
+                                    (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), attStack);
+                        }
+                         else
+                        {
+                            if (m_timer < 600000)
+                                m_timer = 0;
+                            else
+                                m_timer = m_timer - 600000; // - 10 mins
+                        }
+                    }
+                    msgStr = fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_TOWER_DESTROYED), msgStr.c_str());
+                    sWorld->SendZoneText(ZONE_WINTERGRASP, msgStr.c_str());
+                    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress under Siege
+
+                     // Add Support of Quests Toppling the Towers & Southern Sabotage
+                        if (obj->GetEntry()==190356 || obj->GetEntry()==190357 || obj->GetEntry()==190358)
+                        (*itr)->RewardPlayerAndGroupAtEvent(TOWER_PVP_DESTROYED, obj);
+                    }
+                    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+                    {
+                        if (getDefenderTeam()==TEAM_ALLIANCE)
+                            TeamIDsound=OutdoorPvP_WG_HORDE_CAPTAIN; //Allience Worn Sound
+                        else
+                            TeamIDsound=OutdoorPvP_WG_ALLIANCE_CAPTAIN;  //Horde Worn Sound
+                        (*itr)->PlayDirectSound(TeamIDsound) ; // Wintergrasp Fortress destroyed Siege
+                    }
+                }
+                    break;
+            }
+            BroadcastStateChange(state);
+        }
+    }
+}
+
+void OutdoorPvPWG::RemoveOfflinePlayerWGAuras()
+{
+    // if server crashed while in battle there could be players with rank or tenacity
+    CharacterDatabase.PExecute("DELETE FROM character_aura WHERE spell IN (%u, %u, %u, %u, %u)",
+         SPELL_RECRUIT, SPELL_CORPORAL, SPELL_LIEUTENANT, SPELL_TENACITY, SPELL_TOWER_CONTROL);
+}
+
+void OutdoorPvPWG::ModifyWorkshopCount(TeamId team, bool add)
+{
+    if (team == TEAM_NEUTRAL)
+        return;
+
+    if (add)
+        ++m_workshopCount[team];
+    else if (m_workshopCount[team])
+        --m_workshopCount[team];
+    else
+        sLog->outError("OutdoorPvPWG::ModifyWorkshopCount: negative workshop count!");
+
+    SendUpdateWorldState(MaxVehNumWorldState[team], m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP);
+}
+
+uint32 OutdoorPvPWG::GetCreatureEntry(uint32 /*guidlow*/, const CreatureData *data)
+{
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+    {
+        TeamPairMap::const_iterator itr = m_creEntryPair.find(data->id);
+        if (itr != m_creEntryPair.end())
+        {
+            const_cast<CreatureData*>(data)->displayid = 0;
+            return itr->second;
+        }
+    }
+    return data->id;
+}
+
+OutdoorPvPWGCreType OutdoorPvPWG::GetCreatureType(uint32 entry) const
+{
+    // VEHICLES, GUARDS and TURRETS gives kill credit
+    // OTHER Not in wartime
+    // TURRET Only during wartime
+    // SPECIAL like "OTHER" but no despawn conditions
+    // Entries like Case A: Case: B have their own despawn function
+    switch(entry)
+    {
+        case 27881: // Catapult
+        case 28094: // Demolisher
+        case 28312: // Alliance Siege Engine
+        case 32627: // Horde Siege Engine
+        case 28319: // Siege turret
+        case 32629: // Siege turret
+            return CREATURE_SIEGE_VEHICLE;
+        case 28366: // Wintergrasp Tower cannon
+            return CREATURE_TURRET;
+        case CRE_ENG_A: // Alliance Engineer
+        case CRE_ENG_H: // Horde Engineer
+            return CREATURE_ENGINEER;
+        case 30739:case 30740: // Champions
+        case 32307:case 32308: // Guards
+            return CREATURE_GUARD;
+        case CRE_SPI_A: // Dwarven Spirit Guide
+        case CRE_SPI_H: // Taunka Spirit Guide
+            return CREATURE_SPIRIT_GUIDE;
+        case 6491: // Spirit Healers
+            return CREATURE_SPIRIT_HEALER;
+        case 31101:case 31051: // Hoodoo Master & Sorceress
+        case 31102:case 31052: // Vieron Blazefeather & Bowyer
+        case 31107:case 31109: // Lieutenant & Senior Demolitionist
+        case 31151:case 31153: // Tactical Officer
+        case 31106:case 31108: // Siegesmith & Siege Master
+        case 31053:case 31054: // Primalist & Anchorite
+        case 31091:case 31036: // Commander
+            return CREATURE_QUESTGIVER;
+        case 32615:case 32626: // Warbringer && Brigadier General
+        case 32296:case 32294: // Quartermaster
+        case 39173:case 39172: // Ros'slai && Marshal Magruder
+        case 30870:case 30869: // Flight Masters
+            return CREATURE_SPECIAL;
+        default:
+            return CREATURE_OTHER; // Revenants, Elementals, etc
+    }
+}
+
+void OutdoorPvPWG::OnCreatureCreate(Creature *creature)
+{
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_SIEGE_VEHICLE:
+        {
+            if (!creature->isSummon())
+                return;
+
+            TeamId team;
+            if (creature->getFaction() == WintergraspFaction[TEAM_ALLIANCE])
+                team = TEAM_ALLIANCE;
+            else if (creature->getFaction() == WintergraspFaction[TEAM_HORDE])
+                team = TEAM_HORDE;
+            else
+                return;
+
+            if (uint32 engLowguid = GUID_LOPART(((TempSummon*)creature)->GetSummonerGUID()))
+            {
+                if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(engLowguid))
+                {
+                    if (CanBuildVehicle(workshop))
+                        m_vehicles[team].insert(creature);
+                    else
+                    {
+                        creature->setDeathState(DEAD);
+                        creature->SetRespawnTime(DAY);
+                        return;
+                    }
+                }
+
+                if (m_tenacityStack > 0 && team == TEAM_ALLIANCE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, m_tenacityStack);
+                else if (m_tenacityStack < 0 && team == TEAM_HORDE)
+                    creature->SetAuraStack(SPELL_TENACITY_VEHICLE, creature, -m_tenacityStack);
+            }
+            SendUpdateWorldState(VehNumWorldState[team], m_vehicles[team].size());
+        }
+            break;
+        case CREATURE_QUESTGIVER:
+        {
+            m_questgivers[creature->GetDBTableGUIDLow()] = creature;
+            creature->SetReactState(REACT_PASSIVE);
+        }
+            break;
+        case CREATURE_ENGINEER:
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_engGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_engineer = creature;
+                        break;
+                    }
+            }
+            break;
+        case CREATURE_SPIRIT_GUIDE:
+        {
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_spiGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_spiritguide = creature;
+                        break;
+                    }
+            }
+            creature->CastSpell(creature, SPELL_SPIRITUAL_IMMUNITY, true);
+        }
+        case CREATURE_SPIRIT_HEALER:
+        case CREATURE_TURRET:
+        case CREATURE_OTHER:
+            UpdateCreatureInfo(creature);
+        default:
+            m_creatures.insert(creature);
+            break;
+    }
+}
+
+void OutdoorPvPWG::OnCreatureRemove(Creature *creature)
+{
+    uint32 entry = creature->GetEntry();
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_SIEGE_VEHICLE:
+        {
+            if (!creature->isSummon())
+                return;
+
+            TeamId team;
+            // the faction may be changed in uncharm
+            // TODO: now you have to wait until the corpse of vehicle disappear to build a new one
+            if (m_vehicles[TEAM_ALLIANCE].erase(creature))
+                team = TEAM_ALLIANCE;
+            else if (m_vehicles[TEAM_HORDE].erase(creature))
+                team = TEAM_HORDE;
+            else
+                return;
+
+            SendUpdateWorldState(VehNumWorldState[team], m_vehicles[team].size());
+            break;
+        }
+        case CREATURE_QUESTGIVER:
+            m_questgivers.erase(creature->GetDBTableGUIDLow());
+            break;
+        case CREATURE_ENGINEER:
+        {
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_engGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_engineer = NULL;
+                        break;
+                    }
+            }
+            m_creatures.erase(creature); // prevents crash, but i think it's wrong
+        }
+            break;
+        case CREATURE_SPIRIT_GUIDE:
+        {
+            for (OutdoorPvP::OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            {
+                if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                    if (workshop->m_spiGuid == creature->GetDBTableGUIDLow())
+                    {
+                        workshop->m_spiritguide = NULL;
+                        break;
+                    }
+            }
+            m_creatures.erase(creature); // prevents crash, but i think it's wrong
+        }
+            break;
+        default:
+            m_creatures.erase(creature);
+            break;
+    }
+}
+
+void OutdoorPvPWG::OnGameObjectCreate(GameObject *go)
+{
+    OutdoorPvP::OnGameObjectCreate(go);
+
+    if (UpdateGameObjectInfo(go))
+        m_gobjects.insert(go);
+
+    else if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(go->GetDBTableGUIDLow());
+        if (itr != m_buildingStates.end())
+        {
+            itr->second->building = go;
+            if (go->GetGOInfo()->displayId == 7878 || go->GetGOInfo()->displayId == 7900)
+                itr->second->type = BUILDING_TOWER;
+            if (itr->second->damageState == DAMAGE_INTACT && !itr->second->health)
+            {
+                itr->second->health = go->GetGOValue()->building.health;
+                go->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            } else {
+                go->GetGOValue()->building.health = itr->second->health;
+                if (itr->second->damageState == DAMAGE_DAMAGED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DAMAGED);
+                else if (itr->second->damageState == DAMAGE_DESTROYED)
+                    go->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_DESTROYED);
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::OnGameObjectRemove(GameObject *go)
+{
+    OutdoorPvP::OnGameObjectRemove(go);
+
+    if (UpdateGameObjectInfo(go))
+        m_gobjects.erase(go);
+
+    else if (go->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+    {
+        BuildingStateMap::const_iterator itr = m_buildingStates.find(go->GetDBTableGUIDLow());
+        if (itr != m_buildingStates.end())
+            itr->second->building = NULL;
+    }
+}
+
+void OutdoorPvPWG::UpdateAllWorldObject()
+{
+    // update cre and go factions
+    for (GameObjectSet::iterator itr = m_gobjects.begin(); itr != m_gobjects.end(); ++itr)
+        UpdateGameObjectInfo(*itr);
+    for (CreatureSet::iterator itr = m_creatures.begin(); itr != m_creatures.end(); ++itr)
+        UpdateCreatureInfo(*itr);
+    for (QuestGiverMap::iterator itr = m_questgivers.begin(); itr != m_questgivers.end(); ++itr)
+        UpdateQuestGiverPosition((*itr).first, (*itr).second);
+
+    // rebuild and update building states
+    RebuildAllBuildings();
+
+    // update capture points
+    for (OPvPCapturePointMap::iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            workshop->SetTeamByBuildingState();
+}
+
+void OutdoorPvPWG::RebuildAllBuildings()
+{
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+    {
+        if (itr->second->building && itr->second->building->GetGoType() == GAMEOBJECT_TYPE_DESTRUCTIBLE_BUILDING)
+        {
+            UpdateGameObjectInfo(itr->second->building);
+            itr->second->building->Rebuild();
+            itr->second->health = itr->second->building->GetGOValue()->building.health;
+            itr->second->damageState = DAMAGE_INTACT;
+        }
+        else
+            itr->second->health = 0;
+        itr->second->SetTeam(getDefenderTeam() == TEAM_ALLIANCE ? OTHER_TEAM(itr->second->defaultTeam) : itr->second->defaultTeam);
+    }
+    m_towerDamagedCount[TEAM_ALLIANCE] = 0;
+    m_towerDestroyedCount[TEAM_ALLIANCE] = 0;
+    m_towerDamagedCount[TEAM_HORDE] = 0;
+    m_towerDestroyedCount[TEAM_HORDE] = 0;
+}
+
+void OutdoorPvPWG::SendInitWorldStatesTo(Player *player) const
+{
+    WorldPacket data(SMSG_INIT_WORLD_STATES, (4+4+4+2+(m_buildingStates.size()*8)));
+    data << uint32(571);
+    data << uint32(ZONE_WINTERGRASP);
+    data << uint32(0);
+    data << uint16(4+2+4+m_buildingStates.size());
+
+    data << uint32(3803) << uint32(getDefenderTeam() == TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3802) << uint32(getDefenderTeam() != TEAM_ALLIANCE ? 1 : 0);
+    data << uint32(3801) << uint32(isWarTime() ? 0 : 1);
+    data << uint32(3710) << uint32(isWarTime() ? 1 : 0);
+
+    for (uint32 i = 0; i < 2; ++i)
+        data << ClockWorldState[i] << m_clock[i];
+
+    data << uint32(3490) << uint32(m_vehicles[TEAM_HORDE].size());
+    data << uint32(3491) << m_workshopCount[TEAM_HORDE] * MAX_VEHICLE_PER_WORKSHOP;
+    data << uint32(3680) << uint32(m_vehicles[TEAM_ALLIANCE].size());
+    data << uint32(3681) << m_workshopCount[TEAM_ALLIANCE] * MAX_VEHICLE_PER_WORKSHOP;
+
+    for (BuildingStateMap::const_iterator itr = m_buildingStates.begin(); itr != m_buildingStates.end(); ++itr)
+        itr->second->FillData(data);
+
+    if (player)
+        player->GetSession()->SendPacket(&data);
+    else
+        BroadcastPacket(data);
+}
+
+void OutdoorPvPWG::BroadcastStateChange(BuildingState *state) const
+{
+    if (m_sendUpdate)
+        for (uint32 team = 0; team < 2; ++team)
+            for (PlayerSet::const_iterator p_itr = m_players[team].begin(); p_itr != m_players[team].end(); ++p_itr)
+                state->SendUpdate(*p_itr);
+}
+
+// Called at Start and Battle End
+bool OutdoorPvPWG::UpdateCreatureInfo(Creature *creature)
+{
+    if (!creature)
+        return false;
+    uint32 entry = creature->GetEntry();
+
+    switch(GetCreatureType(entry))
+    {
+        case CREATURE_TURRET:
+        {
+            if (isWarTime())
+            {
+                if (!creature->isAlive())
+                    creature->Respawn(true);
+                creature->setFaction(WintergraspFaction[getDefenderTeam()]);
+                creature->SetVisible(true);
+            } else {
+                if (creature->IsVehicle() && creature->GetVehicleKit())
+                    creature->GetVehicleKit()->RemoveAllPassengers();
+                creature->SetVisible(false);
+                creature->setFaction(35);
+            }
+            return false;
+        }
+        case CREATURE_OTHER:
+        {
+            if (isWarTime())
+            {
+                creature->SetVisible(false);
+                creature->setFaction(35);
+            } else {
+                creature->RestoreFaction();
+                creature->SetVisible(true);
+            }
+            return false;
+        }
+        case CREATURE_SPIRIT_GUIDE:
+        {
+            if (isWarTime())
+            {
+                /* Uncomment if want to disable ressurect for both factions at the same time at fortress graveyard
+                if (creature->GetAreaId() == 4575) // Select Fortress Spirit
+                {
+                    FortressSpirit = creature;
+                    if (getDefenderTeam() == TEAM_ALLIANCE) // Fortress Spirit Alliance
+                            FortressSpirit->UpdateEntry(CRE_SPI_A);
+                    if (getDefenderTeam() == TEAM_HORDE) // Fortress Spirit Horde
+                        FortressSpirit->UpdateEntry(CRE_SPI_H);
+                }*/
+                creature->SetVisible(true);
+            }
+            else
+                creature->SetVisible(false);
+            return false;
+        }
+        case CREATURE_SPIRIT_HEALER:
+            creature->SetVisible(isWarTime() ? false : true);
+            return false;
+        case CREATURE_ENGINEER:
+           return false;
+        case CREATURE_SIEGE_VEHICLE:
+            if (!isWarTime())
+            {
+                if (creature->IsVehicle() && creature->GetVehicleKit())
+                    creature->GetVehicleKit()->RemoveAllPassengers();
+                creature->DisappearAndDie();
+            }
+            return false;
+        case CREATURE_QUESTGIVER:
+        {
+           creature->AI()->EnterEvadeMode();
+           creature->SetReactState(REACT_PASSIVE);
+        }
+           return false;
+        case CREATURE_GUARD:
+        case CREATURE_SPECIAL:
+        {
+            //TDB users comment this block if your guards doesn't spawn by pairs A+H at fortress
+            if (creature->GetAreaId()==4575)
+            {
+                switch (entry)
+                {
+                    case 30740://Alliance champion
+                    case 32308://Alliance guard
+                    {
+                        if (getDefenderTeam() == TEAM_ALLIANCE)
+                            creature->SetPhaseMask(1, true);
+                        else 
+                            creature->SetPhaseMask(2, true);
+                        break;
+                    }
+                    case 30739://Horde champion
+                    case 32307://Horde guard
+                    {
+                        if (getDefenderTeam() == TEAM_ALLIANCE)
+                            creature->SetPhaseMask(2, true);
+                        else 
+                            creature->SetPhaseMask(1, true);
+                        break;
+                    }
+                }
+                _RespawnCreatureIfNeeded(creature, entry);
+                creature->AI()->EnterEvadeMode();
+                return false;
+            }
+            else //End of block to comment  */
+            {
+                TeamPairMap::const_iterator itr = m_creEntryPair.find(creature->GetCreatureData()->id);
+                if (itr != m_creEntryPair.end())
+                {
+                    entry = getDefenderTeam() == TEAM_ALLIANCE ? itr->second : itr->first;
+                    _RespawnCreatureIfNeeded(creature, entry);
+                    creature->AI()->EnterEvadeMode();
+                }
+                return false;
+            }
+        }
+        default:
+            return false;
+    }
+}
+
+bool OutdoorPvPWG::UpdateQuestGiverPosition(uint32 guid, Creature *creature)
+{
+    assert(guid);
+    Position pos = m_qgPosMap[std::pair<uint32, bool>(guid, getDefenderTeam() == TEAM_HORDE)];
+
+    if (creature && creature->IsInWorld())
+    {
+        // if not questgiver or position is the same, do nothing
+        if (creature->GetPositionX() == pos.GetPositionX() &&
+            creature->GetPositionY() == pos.GetPositionY() &&
+            creature->GetPositionZ() == pos.GetPositionZ())
+            return false;
+
+        if (creature->isAlive() && creature->isInCombat())
+        {
+            creature->CombatStop(true);
+            creature->getHostileRefManager().deleteReferences();
+        }
+        creature->SetHomePosition(pos);
+        if (creature->GetEntry() != 30400 || creature->GetEntry() != 30499)
+            creature->SetReactState(REACT_AGGRESSIVE);
+        creature->DestroyForNearbyPlayers();
+        if (!creature->GetMap()->IsLoaded(pos.GetPositionX(), pos.GetPositionY()))
+            creature->GetMap()->LoadGrid(pos.GetPositionX(), pos.GetPositionY());
+        creature->GetMap()->CreatureRelocation(creature, pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ(), pos.GetOrientation());
+        if (!creature->isAlive())
+            creature->Respawn(true);
+    }
+    else
+        sObjectMgr->MoveCreData(guid, 571, pos);
+
+    return true;
+}
+
+// Return false = Need to rebuild at battle End/Start
+//        true  = no need to rebuild (ie: Banners or teleporters)
+bool OutdoorPvPWG::UpdateGameObjectInfo(GameObject *go) const
+{
+    uint32 attFaction;
+    uint32 defFaction;
+
+    if (isWarTime())
+    {
+        attFaction = WintergraspFaction[getAttackerTeam()];
+        defFaction = WintergraspFaction[getDefenderTeam()];
+    }
+    else
+    {
+        attFaction = 35;
+        defFaction = 35;
+    }
+
+    if (!go || !go->GetGOInfo())
+       return true;
+
+    switch(go->GetGOInfo()->displayId)
+    {
+        case 8244: // Defender's Portal - Vehicle Teleporter
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getDefenderTeam()]);
+            return true;
+        case 7967: // Titan relic
+            go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[getAttackerTeam()]);
+            return true;
+        case 8165: // Wintergrasp Keep Door
+        case 7877: // Wintergrasp Fortress Wall
+        case 7878: // Wintergrasp Keep Tower
+        case 7906: // Wintergrasp Fortress Gate
+        case 7909: // Wintergrasp Wall
+            go->SetUInt32Value(GAMEOBJECT_FACTION, defFaction);
+            return false;
+        case 8256://Alliance Banner
+        case 5651://Alliance Banner
+             if (getDefenderTeam() == TEAM_ALLIANCE)
+             {
+                 if (go->GetAreaId()==4575 || go->GetAreaId()==4539 || go->GetAreaId()==4538)
+                     go->SetPhaseMask(1, true);
+                 else go->SetPhaseMask(2, true);
+             } else {
+                 if (go->GetAreaId()==4575 || go->GetAreaId()==4539 || go->GetAreaId()==4538)
+                     go->SetPhaseMask(2, true);
+                 else go->SetPhaseMask(1, true);
+             }
+             return true;
+        case 8257://Horde Banner
+        case 5652://Horde Banner
+             if (getDefenderTeam() == TEAM_ALLIANCE)
+             {
+                 if (go->GetAreaId()==4575 || go->GetAreaId()==4539 || go->GetAreaId()==4538)
+                     go->SetPhaseMask(2, true);
+                 else go->SetPhaseMask(1, true);
+             } else {
+                 if (go->GetAreaId()==4575 || go->GetAreaId()==4539 || go->GetAreaId()==4538)
+                     go->SetPhaseMask(1, true);
+                 else go->SetPhaseMask(2, true);
+             }
+             return true;
+        case 7900: // Flamewatch Tower - Shadowsight Tower - Winter's Edge Tower
+            go->SetUInt32Value(GAMEOBJECT_FACTION, attFaction);
+            return false;
+        case 8208: // Goblin Workshop
+        {
+            OPvPCapturePointWG *workshop = GetWorkshopByGOGuid(go->GetGUID());
+            if (workshop)
+                go->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[workshop->m_buildingState->GetTeam()]);
+        }
+            return false;
+    }
+
+    // Note: this is only for test, still need db support
+    TeamPairMap::const_iterator itr = m_goDisplayPair.find(go->GetGOInfo()->displayId);
+    if (itr != m_goDisplayPair.end())
+    {
+        go->SetUInt32Value(GAMEOBJECT_DISPLAYID, getDefenderTeam() == TEAM_ALLIANCE ?
+            itr->second : itr->first);
+        return true;
+    }
+    return false;
+}
+
+void OutdoorPvPWG::HandlePlayerEnterZone(Player * plr, uint32 zone)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+        if (plr->getLevel() < 75)
+        {
+            plr->CastSpell(plr, SPELL_TELEPORT_DALARAN, true);
+            return;
+        }
+        if (plr->getLevel() > 74)
+        {
+            if (!plr->HasAura(SPELL_RECRUIT) && !plr->HasAura(SPELL_CORPORAL)
+                && !plr->HasAura(SPELL_LIEUTENANT))
+                plr->CastSpell(plr, SPELL_RECRUIT, true);
+
+            if (plr->GetTeamId() == getAttackerTeam())
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            } else if (m_towerDestroyedCount[getAttackerTeam()])
+                    plr->SetAuraStack(SPELL_TOWER_CONTROL, plr, m_towerDestroyedCount[getAttackerTeam()]);
+        }
+    }
+
+    SendInitWorldStatesTo(plr);
+    OutdoorPvP::HandlePlayerEnterZone(plr, zone);
+    UpdateTenacityStack();
+}
+
+void OutdoorPvPWG::HandlePlayerResurrects(Player* pPlayer, uint32 zone)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (isWarTime())
+    {
+        if (pPlayer->getLevel() > 74)
+        {
+            // Tenacity
+            if (pPlayer->GetTeamId() == TEAM_ALLIANCE && m_tenacityStack > 0 ||
+                pPlayer->GetTeamId() == TEAM_HORDE && m_tenacityStack < 0)
+            {
+                if (pPlayer->HasAura(SPELL_TENACITY))
+                    pPlayer->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+                int32 newStack = m_tenacityStack < 0 ? -m_tenacityStack : m_tenacityStack;
+                if (newStack > 20)
+                    newStack = 20;
+                pPlayer->SetAuraStack(SPELL_TENACITY, pPlayer, newStack);
+            }
+
+            if (pPlayer->GetTeamId() == getAttackerTeam())
+            {
+                if (m_towerDestroyedCount[getAttackerTeam()] < 3)
+                    pPlayer->SetAuraStack(SPELL_TOWER_CONTROL, pPlayer, 3 - m_towerDestroyedCount[getAttackerTeam()]);
+            } else if (m_towerDestroyedCount[getAttackerTeam()])
+                    pPlayer->SetAuraStack(SPELL_TOWER_CONTROL, pPlayer, m_towerDestroyedCount[getAttackerTeam()]);
+        }
+    }
+    OutdoorPvP::HandlePlayerResurrects(pPlayer, zone);
+}
+
+void OutdoorPvPWG::HandlePlayerLeaveZone(Player* pPlayer, uint32 zone)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return;
+
+    if (!pPlayer->GetSession()->PlayerLogout())
+    {
+        if (pPlayer->GetVehicle())
+            pPlayer->GetVehicle()->Dismiss();
+        pPlayer->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        pPlayer->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        pPlayer->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        pPlayer->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        pPlayer->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+    }
+    pPlayer->RemoveAurasDueToSpell(SPELL_TENACITY);
+    OutdoorPvP::HandlePlayerLeaveZone(pPlayer, zone);
+    UpdateTenacityStack();
+}
+
+void OutdoorPvPWG::PromotePlayer(Player *killer) const
+{
+    Aura * aur;
+    if (aur = killer->GetAura(SPELL_RECRUIT))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_RECRUIT);
+            killer->CastSpell(killer, SPELL_CORPORAL, true);
+            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK1);
+        } else killer->CastSpell(killer, SPELL_RECRUIT, true);
+    }
+    else if (aur = killer->GetAura(SPELL_CORPORAL))
+    {
+        if (aur->GetStackAmount() >= 5)
+        {
+            killer->RemoveAura(SPELL_CORPORAL);
+            killer->CastSpell(killer, SPELL_LIEUTENANT, true);
+            ChatHandler(killer).PSendSysMessage(LANG_BG_WG_RANK2);
+        } else killer->CastSpell(killer, SPELL_CORPORAL, true);
+    }
+}
+
+void OutdoorPvPWG::HandleKill(Player *killer, Unit *victim)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED) || !isWarTime())
+        return;
+
+    bool ok = false;
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+    {
+        if (victim->getLevel() >= 70)
+            ok = true;
+        killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+    } else {
+        switch (GetCreatureType(victim->GetEntry()))
+        {
+            case CREATURE_SIEGE_VEHICLE:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL_V, victim);
+                ok = true;
+                break;
+            case CREATURE_GUARD:
+                killer->RewardPlayerAndGroupAtEvent(CRE_PVP_KILL, victim);
+                ok = true;
+                break;
+            case CREATURE_TURRET:
+                ok = true;
+                break;
+        }
+    }
+
+    if (ok)
+    {
+        if (Group *pGroup = killer->GetGroup())
+        {
+            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                if (itr->getSource()->IsAtGroupRewardDistance(killer) && itr->getSource()->getLevel() > 74)
+                    PromotePlayer(itr->getSource());
+        } else if (killer->getLevel() > 74)
+            PromotePlayer(killer);
+    }
+}
+
+// Recalculates Tenacity and applies it to Players / Vehicles
+void OutdoorPvPWG::UpdateTenacityStack()
+{
+    if (!isWarTime())
+        return;
+
+    TeamId team = TEAM_NEUTRAL;
+    uint32 allianceNum = 0;
+    uint32 hordeNum = 0;
+    int32 newStack = 0;
+
+    for (PlayerSet::iterator itr = m_players[TEAM_ALLIANCE].begin(); itr != m_players[TEAM_ALLIANCE].end(); ++itr)
+        if ((*itr)->getLevel() > 74)
+            ++allianceNum;
+
+    for (PlayerSet::iterator itr = m_players[TEAM_HORDE].begin(); itr != m_players[TEAM_HORDE].end(); ++itr)
+        if ((*itr)->getLevel() > 74)
+            ++hordeNum;
+
+    if (allianceNum && hordeNum)
+    {
+        if (allianceNum < hordeNum)
+            newStack = int32((float(hordeNum) / float(allianceNum) - 1)*4); // positive, should cast on alliance
+        else if (allianceNum > hordeNum)
+            newStack = int32((1 - float(allianceNum) / float(hordeNum))*4); // negative, should cast on horde
+    }
+
+    if (newStack == m_tenacityStack)
+        return;
+
+    if (m_tenacityStack > 0 && newStack <= 0) // old buff was on alliance
+        team = TEAM_ALLIANCE;
+    else if (m_tenacityStack < 0 && newStack >= 0) // old buff was on horde
+        team = TEAM_HORDE;
+
+    m_tenacityStack = newStack;
+
+    // Remove old buff
+    if (team != TEAM_NEUTRAL)
+    {
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if ((*itr)->getLevel() > 74)
+                (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
+
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY_VEHICLE);
+    }
+
+    // Apply new buff
+    if (newStack)
+    {
+        team = newStack > 0 ? TEAM_ALLIANCE : TEAM_HORDE;
+        if (newStack < 0)
+            newStack = -newStack;
+        if (newStack > 20)
+            newStack = 20;
+
+        for (PlayerSet::const_iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            if ((*itr)->getLevel() > 74)
+                (*itr)->SetAuraStack(SPELL_TENACITY, (*itr), newStack);
+
+        for (CreatureSet::const_iterator itr = m_vehicles[team].begin(); itr != m_vehicles[team].end(); ++itr)
+            (*itr)->SetAuraStack(SPELL_TENACITY_VEHICLE, (*itr), newStack);
+    }
+}
+
+void OutdoorPvPWG::UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod)
+{
+    uint32 value = timer%mod;
+    if (m_clock[digit] != value)
+    {
+        m_clock[digit] = value;
+        SendUpdateWorldState(ClockWorldState[digit], uint32(timer + time(NULL)));
+        sWorld->SetWintergrapsTimer(uint32(timer + time(NULL)), digit);
+    }
+}
+
+void OutdoorPvPWG::UpdateClock()
+{
+    uint32 timer = m_timer / 1000;
+    if (!isWarTime())
+        UpdateClockDigit(timer, 1, 10);
+    else
+        UpdateClockDigit(timer, 0, 10);
+
+    //Announce in all world, comment it if you don't like/need it
+    // Announce 30 minutes left
+    if ((m_timer>1800000) && (m_timer<1802000) && (m_wartime==false))
+        sWorld->SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_30);
+
+    // Announce 10 minutes left
+    if ((m_timer>600000) && (m_timer<602000) && (m_wartime==false))
+        sWorld->SendWorldText(LANG_BG_WG_WORLD_ANNOUNCE_10);
+}
+
+bool OutdoorPvPWG::Update(uint32 diff)
+{
+    if (!sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_ENABLED))
+        return false;
+
+    if (m_timer > diff)
+    {
+        m_timer -= diff;
+
+        if (isWarTime())
+        {
+            OutdoorPvP::Update(diff); // update capture points
+
+            /*********************************************************/
+            /***        BATTLEGROUND RESSURECTION SYSTEM           ***/
+            /*********************************************************/
+
+            //this should be handled by spell system
+            m_LastResurrectTime += diff;
+            if (m_LastResurrectTime >= RESURRECTION_INTERVAL)
+            {
+                if (GetReviveQueueSize())
+                {
+                    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+                    {
+                        Creature* sh = NULL;
+                        for (std::vector<uint64>::const_iterator itr2 = (itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+                        {
+                            Player *plr = sObjectMgr->GetPlayer(*itr2);
+                            if (!plr)
+                                continue;
+                            if (!sh && plr->IsInWorld())
+                            {
+                                sh = plr->GetMap()->GetCreature(itr->first);
+                                // only for visual effect
+                                if (sh)
+                                    // Spirit Heal, effect 117
+                                    sh->CastSpell(sh, SPELL_SPIRIT_HEAL, true);
+                            }
+
+                            // Resurrection visual
+                            if (sh && plr->GetDistance2d(sh) <= 18.0f)
+                            {
+                                plr->CastSpell(plr, SPELL_RESURRECTION_VISUAL, true);
+                                m_ResurrectQueue.push_back(*itr2);
+                            }
+                        }
+                        (itr->second).clear();
+                    }
+
+                    m_ReviveQueue.clear();
+                    m_LastResurrectTime = 0;
+                } else m_LastResurrectTime = 0;
+            }
+            else if (m_LastResurrectTime > 500)    // Resurrect players only half a second later, to see spirit heal effect on NPC
+            {
+                for (std::vector<uint64>::const_iterator itr = m_ResurrectQueue.begin(); itr != m_ResurrectQueue.end(); ++itr)
+                {
+                    Player *plr = sObjectMgr->GetPlayer(*itr);
+                    if (!plr)
+                        continue;
+                    plr->ResurrectPlayer(1.0f);
+                    plr->CastSpell(plr, 6962, true);
+                    plr->CastSpell(plr, SPELL_SPIRIT_HEAL_MANA, true);
+                    sObjectAccessor->ConvertCorpseForPlayer(*itr);
+                }
+                m_ResurrectQueue.clear();
+            }
+        }
+        UpdateClock();
+    } else {
+        m_sendUpdate = false;
+        int32 entry = LANG_BG_WG_DEFENDED;
+
+        if (m_changeDefender)
+        {
+            m_changeDefender = false;
+            m_defender = getAttackerTeam();
+            entry = LANG_BG_WG_CAPTURED;
+           if (m_changeAlly == true || m_changeHorde == true) // If wg is switching (.wg switch)
+           {
+           RebuildAllBuildings();
+           m_changeAlly = false;
+           m_changeHorde = false;
+           }
+        }
+        if (isWarTime())
+        {
+            if (m_timer != 1) // 1 = forceStopBattle
+                sWorld->SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(entry), sObjectMgr->GetTrinityStringForDBCLocale(getDefenderTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+            EndBattle();
+        } else {
+            if (m_timer != 1)
+                sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_STARTS));
+            StartBattle();
+        }
+
+        UpdateAllWorldObject();
+        UpdateClock();
+        SendInitWorldStatesTo();
+        m_sendUpdate = true;
+    }
+
+    if (m_WSSaveTimer < diff)
+    {
+        sWorld->setWorldState(WORLDSTATE_WINTERGRASP_WARTIME, m_wartime);
+        sWorld->setWorldState(WORLDSTATE_WINTERGRASP_TIMER, m_timer);
+        sWorld->setWorldState(WORLDSTATE_WINTERGRASP_DEFENDERS, m_defender);
+        m_WSSaveTimer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_SAVESTATE_PERIOD);
+    } else m_WSSaveTimer -= diff;
+
+   return false;
+}
+
+void OutdoorPvPWG::forceStartBattle()
+{// Uptime will do all the work
+    m_wartime = false;
+
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_START));
+    }
+    sWorld->SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceStopBattle()
+{// Uptime will do all the work.
+
+    if (!isWarTime())
+        m_wartime = true;
+    if (m_timer != 1)
+    {
+        m_timer = 1;
+        sWorld->SendZoneText(ZONE_WINTERGRASP, sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_BATTLE_FORCE_STOP));
+    }
+       sWorld->SendWintergraspState();
+}
+
+void OutdoorPvPWG::forceChangeTeam()
+{
+    m_changeDefender = true;
+    m_timer = 1;
+    m_changeAlly = true;
+    m_changeHorde = true;
+
+    sWorld->SendZoneText(ZONE_WINTERGRASP, fmtstring(sObjectMgr->GetTrinityStringForDBCLocale(LANG_BG_WG_SWITCH_FACTION), sObjectMgr->GetTrinityStringForDBCLocale(getAttackerTeam() == TEAM_ALLIANCE ? LANG_BG_AB_ALLY : LANG_BG_AB_HORDE)));
+    if (isWarTime())
+        forceStartBattle();
+    else
+        forceStopBattle();
+}
+
+// Can be forced by gm's while in battle so have to reset in case it was wartime
+void OutdoorPvPWG::StartBattle()
+{
+    uint32 CountDef=0;
+    uint32 CountAtk=0;
+    m_wartime = true;
+    m_timer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_BATTLE_TIME) * MINUTE * IN_MILLISECONDS;
+
+    //Remove Essence of Wintergrasp to all players
+    sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, TEAM_NEUTRAL);
+    sWorld->UpdateAreaDependentAuras();
+
+    // Remove All Wintergrasp auras. Add Recruit rank and Tower Control
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+    {
+        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if ((*itr)->getLevel() < 75)
+            (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
+        else
+        {
+            CountAtk++;
+            (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+            (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
+            (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
+            (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+            (*itr)->SetAuraStack(SPELL_TOWER_CONTROL, (*itr), 3);
+            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
+        }
+    }
+
+    // Remove All Wintergrasp auras. Add Recruit rank
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+        (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+        (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+        (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        if ((*itr)->getLevel() < 75)
+            (*itr)->CastSpell((*itr), SPELL_TELEPORT_DALARAN, true);
+        else
+        {
+            CountDef++;
+            (*itr)->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+            (*itr)->RemoveAurasByType(SPELL_AURA_FLY);
+            (*itr)->CastSpell((*itr), 45472, true); //prevent die if fall
+            (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_START_BATTLE); // START Battle
+            (*itr)->CastSpell(*itr, SPELL_RECRUIT, true);
+        }
+    }
+
+    if (sWorld->getBoolConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ENABLE))
+    {
+        if ((CountAtk < sWorld->getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_ATK)) || (CountDef < sWorld->getIntConfig(CONFIG_CONFIG_OUTDOORPVP_WINTERGRASP_ANTIFARM_DEF)))
+        {
+            if (CountAtk<=CountDef)
+                sWorld->SendWorldText(LANG_BG_WG_WORLD_NO_ATK);
+            if (CountDef<CountAtk)
+            {
+                sWorld->SendWorldText(LANG_BG_WG_WORLD_NO_DEF);
+                m_changeDefender=true;
+            }
+            forceStopBattle();
+            return;
+        }
+    }
+
+    //Uncomment to tele Defenders inside Fortress
+    //TeamCastSpell(getDefenderTeam(), SPELL_TELEPORT_FORTRESS);
+
+    UpdateTenacityStack();
+    // Update timer in players battlegrounds tab
+    sWorld->SendWintergraspState();
+}
+
+void OutdoorPvPWG::EndBattle()
+{
+    // Cast Essence of Wintergrasp to all players (CheckCast will determine who to cast)
+    sWorld->setWorldState(WORLDSTATE_WINTERGRASP_CONTROLING_FACTION, getDefenderTeam());
+    sWorld->UpdateAreaDependentAuras();
+    //Sound on End Battle
+    for (PlayerSet::iterator itr = m_players[getDefenderTeam()].begin(); itr != m_players[getDefenderTeam()].end(); ++itr)
+    {
+        if (getDefenderTeam()==TEAM_ALLIANCE)
+            TeamIDsound=OutdoorPvP_WG_SOUND_ALLIANCE_WINS; //Allience Win
+        else
+            TeamIDsound=OutdoorPvP_WG_SOUND_HORDE_WINS;  //Horde Win
+        (*itr)->PlayDirectSound(TeamIDsound) ; // SoundOnEndWin
+    }
+    for (PlayerSet::iterator itr = m_players[getAttackerTeam()].begin(); itr != m_players[getAttackerTeam()].end(); ++itr)
+        (*itr)->PlayDirectSound(OutdoorPvP_WG_SOUND_NEAR_VICTORY) ; // SoundOnEndLoose
+    for (uint32 team = 0; team < 2; ++team)
+    {
+        // destroyed all vehicles
+        while(!m_vehicles[team].empty())
+        {
+            Creature *veh = *m_vehicles[team].begin();
+            m_vehicles[team].erase(m_vehicles[team].begin());
+            veh->setDeathState(JUST_DIED);
+        }
+
+        if (m_players[team].empty())
+            continue;
+
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+            // When WG ends the zone is cleaned including corpses, revive all players if dead
+            if ((*itr)->isDead())
+            {
+                (*itr)->ResurrectPlayer(1.0f);
+                sObjectAccessor->ConvertCorpseForPlayer((*itr)->GetGUID());
+            }
+            (*itr)->RemoveAurasDueToSpell(SPELL_TENACITY);
+            (*itr)->CombatStop(true);
+            (*itr)->getHostileRefManager().deleteReferences();
+        }
+
+        if (m_timer == 1) // Battle End was forced so no reward.
+        {
+            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+            {
+                (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+                (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+                (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+                (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+                (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+            }
+            continue;
+        }
+
+        // calculate rewards
+        uint32 intactNum = 0;
+        uint32 damagedNum = 0;
+        for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+            if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+                if (workshop->m_buildingState->GetTeam() == team)
+                {
+                    if (workshop->m_buildingState->damageState == DAMAGE_DAMAGED)
+                        ++damagedNum;
+                    else if (workshop->m_buildingState->damageState == DAMAGE_INTACT)
+                        ++intactNum;
+                }
+        uint32 spellRewardId = team == getDefenderTeam() ? SPELL_VICTORY_REWARD : SPELL_DEFEAT_REWARD;
+        uint32 baseHonor = 0;
+        uint32 marks = 0;
+        uint32 playersWithRankNum = 0;
+        uint32 honor = 0;
+
+        if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+        {
+            // Calculate Level 70+ with Corporal or Lieutenant rank
+            for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+                if ((*itr)->getLevel() > 74 && ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL)))
+                    ++playersWithRankNum;
+            baseHonor = team == getDefenderTeam() ? sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_WIN_BATTLE) : sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_LOSE_BATTLE);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_TOWER) * m_towerDamagedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DESTROYED_TOWER) * m_towerDestroyedCount[OTHER_TEAM(team)]);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTACT_BUILDING) * intactNum);
+            baseHonor += (sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_DAMAGED_BUILDING) * damagedNum);
+            if (playersWithRankNum)
+                baseHonor /= playersWithRankNum;
+        }
+
+        for (PlayerSet::iterator itr = m_players[team].begin(); itr != m_players[team].end(); ++itr)
+        {
+            if ((*itr)->getLevel() < 75)
+                continue; // No rewards for level <75
+
+            // give rewards
+            if (sWorld->getBoolConfig(CONFIG_OUTDOORPVP_WINTERGRASP_CUSTOM_HONOR))
+            {
+                if (team == getDefenderTeam())
+                {
+                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 3;
+                        honor = baseHonor;
+                    }
+                    else if ((*itr)->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 2;
+                        honor = baseHonor;
+                    } else {
+                        marks = 1;
+                        honor = 0;
+                    }
+                } else {
+                    if ((*itr)->HasAura(SPELL_LIEUTENANT))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    }
+                    else if ((*itr)->HasAura(SPELL_CORPORAL))
+                    {
+                        marks = 1;
+                        honor = baseHonor;
+                    } else {
+                        marks = 0;
+                        honor = 0;
+                    }
+                }
+                (*itr)->RewardHonor(NULL, 1, honor);
+                RewardMarkOfHonor(*itr, marks);
+                (*itr)->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, spellRewardId);
+            } else {
+                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
+                {
+                    // TODO - Honor from SpellReward should be shared by team players
+                    // TODO - Marks should be given depending on Rank but 3 are given
+                    // each time so Won't give any to recruits
+                    (*itr)->CastSpell(*itr, spellRewardId, true);
+                    for (uint32 i = 0; i < intactNum; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_INTACT_BUILDING, true);
+                    for (uint32 i = 0; i < damagedNum; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_BUILDING, true);
+                    for (uint32 i = 0; i < m_towerDamagedCount[OTHER_TEAM(team)]; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DAMAGED_TOWER, true);
+                    for (uint32 i = 0; i < m_towerDestroyedCount[OTHER_TEAM(team)]; ++i)
+                        (*itr)->CastSpell(*itr, SPELL_DESTROYED_TOWER, true);
+                }
+            }
+            if (team == getDefenderTeam())
+            {
+                if ((*itr)->HasAura(SPELL_LIEUTENANT) || (*itr)->HasAura(SPELL_CORPORAL))
+                {
+                    (*itr)->AreaExploredOrEventHappens(A_VICTORY_IN_WG);
+                    (*itr)->AreaExploredOrEventHappens(H_VICTORY_IN_WG);
+                }
+            }
+            (*itr)->RemoveAurasDueToSpell(SPELL_RECRUIT);
+            (*itr)->RemoveAurasDueToSpell(SPELL_CORPORAL);
+            (*itr)->RemoveAurasDueToSpell(SPELL_LIEUTENANT);
+            (*itr)->RemoveAurasDueToSpell(SPELL_TOWER_CONTROL);
+            (*itr)->RemoveAurasDueToSpell(SPELL_SPIRITUAL_IMMUNITY);
+        }
+    }
+
+    m_wartime = false;
+    m_timer = sWorld->getIntConfig(CONFIG_OUTDOORPVP_WINTERGRASP_INTERVAL) * MINUTE * IN_MILLISECONDS;
+    RemoveOfflinePlayerWGAuras();
+    // Update timer in players battlegrounds tab
+    sWorld->SendWintergraspState();
+    // update go factions
+    for (GameObjectSet::iterator itr = m_gobjects.begin(); itr != m_gobjects.end(); ++itr)
+       UpdateGameObjectInfo(*itr);
+}
+
+bool OutdoorPvPWG::CanBuildVehicle(OPvPCapturePointWG *workshop) const
+{
+    TeamId team = workshop->m_buildingState->GetTeam();
+    if (team == TEAM_NEUTRAL)
+        return false;
+
+    return isWarTime()
+        && workshop->m_buildingState->damageState != DAMAGE_DESTROYED
+        && m_vehicles[team].size() < m_workshopCount[team] * MAX_VEHICLE_PER_WORKSHOP;
+}
+
+uint32 OutdoorPvPWG::GetData(uint32 id)
+{
+    // if can build more vehicles
+    if (OPvPCapturePointWG *workshop = GetWorkshopByEngGuid(id))
+        return CanBuildVehicle(workshop) ? 1 : 0;
+
+    return 0;
+}
+
+void OutdoorPvPWG::RewardMarkOfHonor(Player *plr, uint32 count)
+{
+    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
+    if (plr->HasAura(SPELL_AURA_PLAYER_INACTIVE))
+        return;
+    if (count == 0)
+        return;
+
+    ItemPosCountVec dest;
+    uint32 no_space_count = 0;
+    uint8 msg = plr->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, WG_MARK_OF_HONOR, count, &no_space_count);
+
+    if (msg == EQUIP_ERR_ITEM_NOT_FOUND)
+    {
+        sLog->outErrorDb("Wintergrasp reward item (Entry %u) not exist in `item_template`.", WG_MARK_OF_HONOR);
+        return;
+    }
+
+    if (msg != EQUIP_ERR_OK) // convert to possible store amount
+        count -= no_space_count;
+
+    if (count != 0 && !dest.empty()) // can add some
+        if (Item* item = plr->StoreNewItem(dest, WG_MARK_OF_HONOR, true, 0))
+            plr->SendNewItem(item, count, true, false);
+}
+
+void OutdoorPvPWG::LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli)
+{
+    m_qgPosMap[std::pair<uint32, bool>(guid, true)] = posHorde,
+    m_qgPosMap[std::pair<uint32, bool>(guid, false)] = posAlli,
+    m_questgivers[guid] = NULL;
+    if (getDefenderTeam() == TEAM_ALLIANCE)
+        sObjectMgr->MoveCreData(guid, 571, posAlli);
+    if (getDefenderTeam() == TEAM_HORDE)
+        sObjectMgr->MoveCreData(guid, 571, posHorde);
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshop(uint32 lowguid) const
+{
+    if (OPvPCapturePoint *cp = GetCapturePoint(lowguid))
+        return dynamic_cast<OPvPCapturePointWG*>(cp);
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByEngGuid(uint32 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_engGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+OPvPCapturePointWG *OutdoorPvPWG::GetWorkshopByGOGuid(uint64 lowguid) const
+{
+    for (OutdoorPvP::OPvPCapturePointMap::const_iterator itr = m_capturePoints.begin(); itr != m_capturePoints.end(); ++itr)
+        if (OPvPCapturePointWG *workshop = dynamic_cast<OPvPCapturePointWG*>(itr->second))
+            if (workshop->m_workshopGuid == lowguid)
+                return workshop;
+    return NULL;
+}
+
+/*########################################################
+ * Copy of Battleground system to make Spirit Guides Work
+ *#######################################################*/
+void OutdoorPvPWG::SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid)
+{
+    WorldPacket data(SMSG_AREA_SPIRIT_HEALER_TIME, 12);
+    uint32 time_ = 30000 - GetLastResurrectTime();      // resurrect every 30 seconds
+    if (time_ == uint32(-1))
+        time_ = 0;
+    data << guid << time_;
+    pl->GetSession()->SendPacket(&data);
+}
+
+void OutdoorPvPWG::AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid)
+{
+    m_ReviveQueue[npc_guid].push_back(player_guid);
+
+    Player *plr = sObjectMgr->GetPlayer(player_guid);
+    if (!plr)
+        return;
+
+    plr->CastSpell(plr, SPELL_WAITING_FOR_RESURRECT, true);
+}
+
+void OutdoorPvPWG::RemovePlayerFromResurrectQueue(uint64 player_guid)
+{
+    for (std::map<uint64, std::vector<uint64> >::iterator itr = m_ReviveQueue.begin(); itr != m_ReviveQueue.end(); ++itr)
+    {
+        for (std::vector<uint64>::iterator itr2 =(itr->second).begin(); itr2 != (itr->second).end(); ++itr2)
+        {
+            if (*itr2 == player_guid)
+            {
+                (itr->second).erase(itr2);
+
+                Player *plr = sObjectMgr->GetPlayer(player_guid);
+                if (!plr)
+                    return;
+
+                plr->RemoveAurasDueToSpell(SPELL_WAITING_FOR_RESURRECT);
+
+                return;
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateAllianceDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = sObjectMgr->GetPlayer(*itr);
+            if (!plr)
+                continue;
+
+            if (plr->getFaction() == ALLIANCE)
+            {
+                if (ClosestGrave)
+                    plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+                else
+                    ClosestGrave = sObjectMgr->GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+            }
+        }
+    }
+}
+
+void OutdoorPvPWG::RelocateHordeDeadPlayers(Creature *cr)
+{
+    if (!cr || GetCreatureType(cr->GetEntry()) != CREATURE_SPIRIT_GUIDE)
+        return;
+
+    // Those who are waiting to resurrect at this node are taken to the closest own node's graveyard
+    std::vector<uint64> ghost_list = m_ReviveQueue[cr->GetGUID()];
+    if (!ghost_list.empty())
+    {
+        WorldSafeLocsEntry const *ClosestGrave = NULL;
+        for (std::vector<uint64>::const_iterator itr = ghost_list.begin(); itr != ghost_list.end(); ++itr)
+        {
+            Player* plr = sObjectMgr->GetPlayer(*itr);
+            if (!plr)
+                continue;
+            if (plr->getFaction() == HORDE)
+            {
+                if (ClosestGrave)
+                    plr->TeleportTo(plr->GetMapId(), ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, plr->GetOrientation());
+                else
+                    ClosestGrave = sObjectMgr->GetClosestGraveYard(plr->GetPositionX(), plr->GetPositionY(), plr->GetPositionZ(), plr->GetMapId(), plr->GetTeam());
+            }
+        }
+    }
+}
+
+OPvPCapturePointWG::OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state) : OPvPCapturePoint(opvp), m_spiGuid(0), m_spiritguide(NULL), m_spiritguide_horde(NULL), m_spiritguide_alliance(NULL), m_engGuid(0), m_engineer(NULL), m_buildingState(state), m_wintergrasp(opvp) {}
+
+void OPvPCapturePointWG::SetTeamByBuildingState()
+{
+    if (m_buildingState->GetTeam() == TEAM_ALLIANCE)
+    {
+        m_value = m_maxValue;
+        m_State = OBJECTIVESTATE_ALLIANCE;
+    }
+    else if (m_buildingState->GetTeam() == TEAM_HORDE)
+    {
+        m_value = -m_maxValue;
+        m_State = OBJECTIVESTATE_HORDE;
+    } else {
+        m_value = 0;
+        m_State = OBJECTIVESTATE_NEUTRAL;
+    }
+
+    if (m_team != m_buildingState->GetTeam())
+    {
+        TeamId oldTeam = m_team;
+        m_team = m_buildingState->GetTeam();
+        ChangeTeam(oldTeam);
+    }
+
+    SendChangePhase();
+}
+
+void OPvPCapturePointWG::ChangeTeam(TeamId oldTeam)
+{
+    entry = 0;
+    guide_entry = 0;
+    guide_entry_fortress_horde = 0;
+    guide_entry_fortress_alliance = 0;
+
+    if (oldTeam != TEAM_NEUTRAL)
+        m_wintergrasp->ModifyWorkshopCount(oldTeam, false);
+
+    if (m_team != TEAM_NEUTRAL)
+    {
+        entry = m_team == TEAM_ALLIANCE ? CRE_ENG_A : CRE_ENG_H;
+        guide_entry = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_H;
+        guide_entry_fortress_horde = m_team == TEAM_HORDE ? CRE_SPI_H : CRE_SPI_H;
+        guide_entry_fortress_alliance = m_team == TEAM_ALLIANCE ? CRE_SPI_A : CRE_SPI_A;
+        m_wintergrasp->ModifyWorkshopCount(m_team, true);
+    }
+
+    if (m_capturePoint)
+        GameObject::SetGoArtKit(CapturePointArtKit[m_team], m_capturePoint, m_capturePointGUID);
+
+    m_buildingState->SetTeam(m_team);
+    // TODO: this may be sent twice
+    m_wintergrasp->BroadcastStateChange(m_buildingState);
+
+    if (m_buildingState->building)
+        m_buildingState->building->SetUInt32Value(GAMEOBJECT_FACTION, WintergraspFaction[m_team]);
+
+    if (entry)
+    {
+        if (m_engGuid)
+        {
+            *m_engEntry = entry;
+            _RespawnCreatureIfNeeded(m_engineer, entry);
+        }
+        if (m_spiGuid)
+        {
+            if (m_wintergrasp->getAttackerTeam() == TEAM_ALLIANCE)
+            {
+                *m_spiEntry = guide_entry;
+                _RespawnCreatureIfNeeded(m_spiritguide_horde, guide_entry_fortress_horde);
+                m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide_horde); // Horde
+                _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+                m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide); // Alliance
+            } else {
+                *m_spiEntry = guide_entry;
+                _RespawnCreatureIfNeeded(m_spiritguide_alliance, guide_entry_fortress_alliance);
+                m_wintergrasp->RelocateAllianceDeadPlayers(m_spiritguide_alliance); // Alliance
+                _RespawnCreatureIfNeeded(m_spiritguide, guide_entry);
+                m_wintergrasp->RelocateHordeDeadPlayers(m_spiritguide); // Horde
+            }
+        }
+    } else if (m_engineer)
+        m_engineer->SetVisible(false);
+}
+
+class OutdoorPvP_wintergrasp : public OutdoorPvPScript
+{
+    public:
+        OutdoorPvP_wintergrasp() : OutdoorPvPScript("outdoorpvp_wg") { }
+
+        OutdoorPvP* GetOutdoorPvP() const
+        {
+            return new OutdoorPvPWG();
+        }
+};
+
+void AddSC_outdoorpvp_wg()
+{
+    new OutdoorPvP_wintergrasp();
+}
\ No newline at end of file
diff -r 1014d6336f88 -r cdfe675ad96b src/server/scripts/OutdoorPvP/OutdoorPvPWG.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/server/scripts/OutdoorPvP/OutdoorPvPWG.h	Sat Jun 11 15:55:56 2011 -0500
@@ -0,0 +1,344 @@
+/*
+ * Copyright (C) 2008 - 2011 Trinity <http://www.trinitycore.org/>
+ *
+ * Copyright (C) 2011 Patch supported by ChaosUA & TCRU community http://trinity-core.ru/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef OUTDOOR_PVP_WG_
+#define OUTDOOR_PVP_WG_
+
+#include "OutdoorPvP.h"
+#include "BattlegroundMgr.h"
+#include "Player.h"
+
+#define ZONE_DALARAN             4395
+#define ZONE_WINTERGRASP         4197
+#define POS_X_CENTER             5100
+#define MAX_VEHICLE_PER_WORKSHOP    4
+
+const uint32 WintergraspFaction[3] = {1802, 1801, 35};
+const uint32 WG_MARK_OF_HONOR = 43589;
+const uint32 VehNumWorldState[2] = {3680,3490};
+const uint32 MaxVehNumWorldState[2] = {3681,3491};
+const uint32 ClockWorldState[2] = {3781,4354};
+const uint8 CapturePointArtKit[3] = {2, 1, 21};
+char const *fmtstring(char const *format, ...);
+const Team TeamId2Team[3] = {ALLIANCE, HORDE, TEAM_OTHER};
+
+enum OutdoorPvPWGSpell
+{
+    // Wartime auras
+    SPELL_RECRUIT                                = 37795,
+    SPELL_CORPORAL                               = 33280,
+    SPELL_LIEUTENANT                             = 55629,
+    SPELL_TENACITY                               = 58549,
+    SPELL_TENACITY_VEHICLE                       = 59911,
+    SPELL_TOWER_CONTROL                          = 62064,
+    SPELL_SPIRITUAL_IMMUNITY                     = 58729,
+
+    // Reward spells
+    SPELL_VICTORY_REWARD                         = 56902,
+    SPELL_DEFEAT_REWARD                          = 58494,
+    SPELL_DAMAGED_TOWER                          = 59135,
+    SPELL_DESTROYED_TOWER                        = 59136,
+    SPELL_DAMAGED_BUILDING                       = 59201,
+    SPELL_INTACT_BUILDING                        = 59203,
+
+    SPELL_TELEPORT_ALLIENCE_CAMP                 = 58632,
+    SPELL_TELEPORT_HORDE_CAMP                    = 58633,
+    SPELL_TELEPORT_FORTRESS                      = 59096,
+
+    SPELL_TELEPORT_DALARAN                       = 53360,
+    SPELL_VICTORY_AURA                           = 60044,
+};
+
+const uint16 GameEventWintergraspDefender[2] = {50, 51};
+
+enum OutdoorPvP_WG_Sounds
+{
+    OutdoorPvP_WG_SOUND_KEEP_CLAIMED            = 8192,
+    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_ALLIANCE  = 8173,
+    OutdoorPvP_WG_SOUND_KEEP_CAPTURED_HORDE     = 8213,
+    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_ALLIANCE = 8212,
+    OutdoorPvP_WG_SOUND_KEEP_ASSAULTED_HORDE    = 8174,
+    OutdoorPvP_WG_SOUND_NEAR_VICTORY            = 8456,
+    OutdoorPvP_WG_SOUND_HORDE_WINS              = 8454,
+    OutdoorPvP_WG_SOUND_ALLIANCE_WINS           = 8455,
+    OutdoorPvP_WG_SOUND_WORKSHOP_Horde          = 6205,
+    OutdoorPvP_WG_SOUND_WORKSHOP_ALLIANCE       = 6298,
+    OutdoorPvP_WG_HORDE_CAPTAIN                 = 8333,
+    OutdoorPvP_WG_ALLIANCE_CAPTAIN              = 8232,
+    OutdoorPvP_WG_SOUND_START_BATTLE            = 3439, //Standart BG Start sound
+};
+
+enum DataId
+{
+     DATA_ENGINEER_DIE,
+};
+
+enum OutdoorPvP_WG_KeepStatus
+{
+    OutdoorPvP_WG_KEEP_TYPE_NEUTRAL             = 0,
+    OutdoorPvP_WG_KEEP_TYPE_CONTESTED           = 1,
+    OutdoorPvP_WG_KEEP_STATUS_ALLY_CONTESTED    = 1,
+    OutdoorPvP_WG_KEEP_STATUS_HORDE_CONTESTED   = 2,
+    OutdoorPvP_WG_KEEP_TYPE_OCCUPIED            = 3,
+    OutdoorPvP_WG_KEEP_STATUS_ALLY_OCCUPIED     = 3,
+    OutdoorPvP_WG_KEEP_STATUS_HORDE_OCCUPIED    = 4
+};
+
+enum OutdoorPVPWGStatus
+{
+    WORLDSTATE_WINTERGRASP_WARTIME            = 31001,
+    WORLDSTATE_WINTERGRASP_TIMER              = 31002,
+    WORLDSTATE_WINTERGRASP_DEFENDERS          = 31003,
+    WORLDSTATE_WINTERGRASP_CONTROLING_FACTION = 31004,
+    WORLDSTATE_VALUE_COUNT,
+};
+
+enum OutdoorPvPWGCreType
+{
+    CREATURE_OTHER,
+    CREATURE_SIEGE_VEHICLE,
+    CREATURE_TURRET,
+    CREATURE_ENGINEER,
+    CREATURE_GUARD,
+    CREATURE_SPECIAL,
+    CREATURE_SPIRIT_GUIDE,
+    CREATURE_SPIRIT_HEALER,
+    CREATURE_QUESTGIVER,
+};
+
+enum OutdoorPvPWGBuildingType
+{
+    BUILDING_WALL,
+    BUILDING_WORKSHOP,
+    BUILDING_TOWER,
+};
+
+enum OutdoorPvPWGDamageState
+{ // Do not change order
+    DAMAGE_INTACT,
+    DAMAGE_DAMAGED,
+    DAMAGE_DESTROYED,
+};
+
+typedef uint32 TeamPair[2];
+
+enum OutdoorPvPWGQuest
+{
+    A_VICTORY_IN_WG                              = 13181,
+    H_VICTORY_IN_WG                              = 13183,
+    CRE_PVP_KILL                                 = 31086, //Quest Objective - Fixme: this should be handled by DB
+    CRE_PVP_KILL_V                               = 31093, //Quest Objective - Fixme: this should be handled by DB.
+    TOWER_PVP_DESTROYED                          = 35074, //Quest Objective - Toppling the Towers & Southern Sabotage
+};
+
+enum OutdoorPvPWGCreEntry
+{
+    CRE_ENG_A                                    = 30499,
+    CRE_ENG_H                                    = 30400,
+    CRE_SPI_A                                    = 31842,
+    CRE_SPI_H                                    = 31841,
+};
+
+const TeamPair OutdoorPvPWGCreEntryPair[] =
+{
+    {32307, 32308}, // Guards
+    {30739, 30740}, // Champions
+    {32296, 32294}, // Quartermaster
+    {39173, 39172}, // Ros'slai & Marshal Magruder
+    {32615, 32626}, // Warbringer & Brigadier General
+    {0,0} // Do not delete Used in LoadTeamPair
+};
+
+const TeamPair OutdoorPvPWGGODisplayPair[] =
+{
+    {5651, 5652},
+    {8256, 8257},
+    {0,0} // Do not delete Used in LoadTeamPair
+};
+
+const uint32 AreaPOIIconId[3][3] = {{7,8,9},{4,5,6},{1,2,3}};
+typedef std::list<const AreaPOIEntry *> AreaPOIList;
+
+struct BuildingState
+{
+    explicit BuildingState(uint32 _worldState, TeamId _team, bool asDefault)
+         : worldState(_worldState), health(0)
+         , defaultTeam(asDefault ? _team : OTHER_TEAM(_team)), damageState(DAMAGE_INTACT), team(_team)
+         , building(NULL), graveTeam(NULL), type(BUILDING_WALL) {}
+    uint32 worldState;
+    uint32 health;
+    TeamId defaultTeam;
+    OutdoorPvPWGDamageState damageState;
+    TeamId team;
+    GameObject *building;
+    uint32 *graveTeam;
+    OutdoorPvPWGBuildingType type;
+
+    void SendUpdate(Player *player) const
+    {
+        player->SendUpdateWorldState(worldState, AreaPOIIconId[team][damageState]);
+    }
+
+    void FillData(WorldPacket &data) const
+    {
+        data << worldState << AreaPOIIconId[team][damageState];
+    }
+
+    TeamId GetTeam() const { return team; }
+    void SetTeam(TeamId t)
+    {
+        team = t;
+        if(graveTeam)
+            if (uint32 newTeam = TeamId2Team[t])
+                *graveTeam = newTeam;
+    }
+};
+
+typedef std::map<uint32, uint32> TeamPairMap;
+class OPvPCapturePointWG;
+
+class OutdoorPvPWG : public OutdoorPvP
+{
+    protected:
+        typedef std::map<uint32, BuildingState *> BuildingStateMap;
+        typedef std::set<Creature*> CreatureSet;
+        typedef std::set<GameObject*> GameObjectSet;
+        typedef std::map<std::pair<uint32, bool>, Position> QuestGiverPositionMap;
+        typedef std::map<uint32, Creature*> QuestGiverMap;
+
+    public:
+        OutdoorPvPWG();
+        bool SetupOutdoorPvP();
+        int TeamIDsound;
+        uint32 GetCreatureEntry(uint32 guidlow, const CreatureData *data);
+        void OnCreatureCreate(Creature *creature);
+        void OnGameObjectCreate(GameObject *go);
+        void OnCreatureRemove(Creature *creature);
+        void OnGameObjectRemove(GameObject *go);
+        void ProcessEvent(GameObject *obj, uint32 eventId);
+        void HandlePlayerEnterZone(Player *plr, uint32 zone);
+        void HandlePlayerLeaveZone(Player *plr, uint32 zone);
+        void HandlePlayerResurrects(Player * plr, uint32 zone);
+        void HandleKill(Player *killer, Unit *victim);
+        bool Update(uint32 diff);
+        void BroadcastStateChange(BuildingState *state) const;
+        uint32 GetData(uint32 id);
+        void ModifyWorkshopCount(TeamId team, bool add);
+        uint32 GetTimer() const { return m_timer / 1000; };
+        bool isWarTime() const { return m_wartime; };
+        void setTimer(uint32 timer) { if (timer >= 0) m_timer = timer; };
+        uint32 GetNumPlayersA() const { return m_players[TEAM_ALLIANCE].size(); };
+        uint32 GetNumPlayersH() const { return m_players[TEAM_HORDE].size(); };
+        TeamId getDefenderTeam() const { return m_defender; };
+        TeamId getAttackerTeam() const { return OTHER_TEAM(m_defender); };
+        void forceChangeTeam();
+        void forceStopBattle();
+        void forceStartBattle();
+        // Temporal BG specific till 3.2
+        void SendAreaSpiritHealerQueryOpcode(Player *pl, const uint64& guid);
+        void AddPlayerToResurrectQueue(uint64 npc_guid, uint64 player_guid);
+        void RemovePlayerFromResurrectQueue(uint64 player_guid);
+        void RelocateAllianceDeadPlayers(Creature *cr);
+        void RelocateHordeDeadPlayers(Creature *cr);
+        // BG end
+        void SendInitWorldStatesTo(Player *player = NULL) const;
+        uint32 m_timer;
+        bool m_changeAlly;
+        bool m_changeHorde;
+
+    protected:
+        // Temporal BG specific till 3.2
+        std::vector<uint64> m_ResurrectQueue;               // Player GUID
+        uint32 m_LastResurrectTime;
+        // Spirit Guide guid + Player list GUIDS
+        std::map<uint64, std::vector<uint64> >  m_ReviveQueue;
+
+        uint32 GetLastResurrectTime() const { return m_LastResurrectTime; }
+        uint32 GetReviveQueueSize() const { return m_ReviveQueue.size(); }
+        // BG end
+        TeamId m_defender;
+        int32 m_tenacityStack;
+
+        BuildingStateMap m_buildingStates;
+        BuildingState *m_gate;
+
+        CreatureSet m_creatures;
+        CreatureSet m_vehicles[2];
+        GameObjectSet m_gobjects;
+        GameObjectSet m_gobjectsDestroyable;
+        QuestGiverMap m_questgivers;
+
+        TeamPairMap m_creEntryPair, m_goDisplayPair;
+        QuestGiverPositionMap m_qgPosMap;
+
+        bool m_wartime;
+        bool m_changeDefender;
+        uint32 m_clock[2];
+        uint32 m_workshopCount[2];
+        uint32 m_towerDestroyedCount[2];
+        uint32 m_towerDamagedCount[2];
+        uint32 m_WSSaveTimer;
+
+        OPvPCapturePointWG *GetWorkshop(uint32 lowguid) const;
+        OPvPCapturePointWG *GetWorkshopByEngGuid(uint32 lowguid) const;
+        OPvPCapturePointWG *GetWorkshopByGOGuid(uint64 lowguid) const;
+
+        void StartBattle();
+        void EndBattle();
+        void UpdateClock();
+        void UpdateClockDigit(uint32 &timer, uint32 digit, uint32 mod);
+        void PromotePlayer(Player *player) const;
+        void UpdateTenacityStack();
+        void UpdateAllWorldObject();
+        bool UpdateCreatureInfo(Creature *creature);
+        bool UpdateGameObjectInfo(GameObject *go) const;
+        bool CanBuildVehicle(OPvPCapturePointWG *workshop) const;
+        OutdoorPvPWGCreType GetCreatureType(uint32 entry) const;
+
+        void RebuildAllBuildings();
+        void RemoveOfflinePlayerWGAuras();
+        void RewardMarkOfHonor(Player *player, uint32 count);
+        void MoveQuestGiver(uint32 guid);
+        void LoadQuestGiverMap(uint32 guid, Position posHorde, Position posAlli);
+        bool UpdateQuestGiverPosition(uint32 guid, Creature *creature);
+};
+
+class OPvPCapturePointWG : public OPvPCapturePoint
+{
+    public:
+        explicit OPvPCapturePointWG(OutdoorPvPWG *opvp, BuildingState *state);
+        void SetTeamByBuildingState();
+        void ChangeState() { }
+        void ChangeTeam(TeamId oldteam);
+        uint32 *m_spiEntry;
+        uint32 m_spiGuid;
+        Creature *m_spiritguide;
+        Creature *m_spiritguide_horde;
+        Creature *m_spiritguide_alliance;
+        uint32 *m_engEntry;
+        uint32 m_engGuid;
+        Creature *m_engineer;
+        uint32 m_workshopGuid;
+        BuildingState *m_buildingState;
+
+    protected:
+        OutdoorPvPWG *m_wintergrasp;
+};
+#endif
\ No newline at end of file
diff -r 1014d6336f88 -r cdfe675ad96b src/server/worldserver/worldserver.conf.dist
--- a/src/server/worldserver/worldserver.conf.dist	Fri Jun 10 22:03:11 2011 -0500
+++ b/src/server/worldserver/worldserver.conf.dist	Sat Jun 11 15:55:56 2011 -0500
@@ -23,6 +23,7 @@
 #    NETWORK CONFIG
 #    CONSOLE AND REMOTE ACCESS
 #    CHARACTER DELETE OPTIONS
+#    WINTERGRASP_CONFIG
 #    CUSTOM SERVER OPTIONS
 #
 ###################################################################################################
@@ -2771,3 +2772,101 @@
 
 #
 ###################################################################################################
+ 
+###################################################################################################
+# WINTERGRASP_CONFIG
+#
+#   OutdoorPvP.Wintergrasp.Enabled
+#       Determines whether the Wintergrasp battle is enabled or not.
+#        Default: 0 = Disable
+#                 1 = Enable
+#
+#   OutdoorPvP.Wintergrasp.SaveState.Period
+#      Interval of Save Wintergrasp State Data  to restore it after crash/shutdown/restart
+#      Interval (in milliseconds)
+#      Default (10000 milliseconds)
+#      Warning:  Do not set it less 1 second!
+#
+#   OutdoorPvP.Wintergrasp.StartTime
+#       The start time of the first battle after server starts (in minutes)
+#       Default: 30
+#
+#   OutdoorPvP.Wintergrasp.BattleTime
+#       Time limit of a battle (in minutes)
+#       Default: 30
+#
+#   OutdoorPvP.Wintergrasp.Interval
+#       Interval between battles (in minutes)
+#       Default: 150
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorRewards
+#       Defines whether custom honor rewards should be given to player
+#        for partaking in the Wintergrasp Battle.
+#        Default: 0 = Disable
+#                 1 = Enable
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorBattleWin
+#       Defines the amount of honor points that should be given to the
+#        team winning the Wintergrasp Battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 3000
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorBattleLose
+#       Defines the amount of honor points that should be given to the
+#        team losing the Wintergrasp Battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 1250
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorDamageTower
+#       Defines the amount of honor points that should be given to the
+#        team for damaging a tower.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower
+#       Defines the amount of honor points that should be given to the
+#        team for destroying a tower.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding
+#       Defines the amount of honor points that should be given to the
+#        team for damaged buildings after the battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 750
+#
+#   OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding
+#      Defines the amount of honor points that should be given to the
+#        team for intact buildings after the battle.
+#       Requires OutdoorPvP.Wintergrasp.CustomHonorRewards = 1.
+#       Default: 1500
+#
+#   OutdoorPvP.Wintergrasp.Antifarm.Enable
+#		Enable or Disable antifarm system
+#              (Default: 0)
+#
+#   OutdoorPvP.Wintergrasp.Antifarm.Atk
+#		Min count atack players for antifarm
+#              (Default: 5)
+#
+#   OutdoorPvP.Wintergrasp.Antifarm.Def
+#		Min count defense players for antifarm
+#              (Default: 5)
+#
+##########################################################
+
+OutdoorPvP.Wintergrasp.Enabled = 1
+OutdoorPvP.Wintergrasp.SaveState.Period = 60000
+OutdoorPvP.Wintergrasp.StartTime = 30
+OutdoorPvP.Wintergrasp.BattleTime = 30
+OutdoorPvP.Wintergrasp.Interval = 150
+OutdoorPvP.Wintergrasp.CustomHonorRewards = 0
+OutdoorPvP.Wintergrasp.CustomHonorBattleWin = 3000
+OutdoorPvP.Wintergrasp.CustomHonorBattleLose = 1250
+OutdoorPvP.Wintergrasp.CustomHonorDamageTower = 750
+OutdoorPvP.Wintergrasp.CustomHonorDestroyedTower = 750
+OutdoorPvP.Wintergrasp.CustomHonorDamagedBuilding = 750
+OutdoorPvP.Wintergrasp.CustomHonorIntactBuilding = 1500
+OutdoorPvP.Wintergrasp.Antifarm.Enable = 0
+OutdoorPvP.Wintergrasp.Antifarm.Atk = 5
+OutdoorPvP.Wintergrasp.Antifarm.Def = 5
\ No newline at end of file
